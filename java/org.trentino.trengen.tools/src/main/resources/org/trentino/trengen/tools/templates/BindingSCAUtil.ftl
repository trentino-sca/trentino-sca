// Generated by Trentino TDIL Compact soap generator. do not modify

<#macro requestResponse context direction>
<#assign pkgName="protobuf."+context.tidlInterfaceModel.qualifiedName>
package ${pkgName};

import "${typesFilename}";
option optimize_for = LITE_RUNTIME;
message ${context.tidlInterfaceModel.name}${direction}{

<#foreach method in context.tidlInterfaceModel.functions>
    message ${method.methodId}${direction}{
 <#assign i=1>     
 <#foreach argument in method.arguments>
 <#if (!argument.hasOut && direction=="Request")||((argument.hasOut || argument.hasInOut) && direction=="Response")>
        optional ${tmapper.name(argument.type)} ${argument.name}=${i};
 <#assign i=i+1>
 </#if>
 </#foreach>
 <#if !method.returnTypeVoid && direction=="Response">
       optional ${tmapper.name(method.returnType)} ${method.methodId}Response=${i};
 </#if>
      }
      
</#foreach>
<#assign i=1>
<#foreach method in context.tidlInterfaceModel.functions>
     optional ${method.methodId}${direction} ${method.methodId}${direction}Object=${i};
<#assign i=i+1>
</#foreach>

}
</#macro>

<#-- generate the modifier for the fucntion parameter e.g const -->
<#macro fpmod arg><#if !arg.hasOut && !arg.hasInOut>const</#if></#macro>
<#-- generate the reference modifier for the  parameter e.g & if necessary -->
<#macro refmod arg><#if arg.complexType>&</#if></#macro>
<#macro methodDefArgs method tmapper> ${method.name} (<#list method.arguments as x><#assign j = tmapper.name(x.type)?index_of("string")><#assign i = tmapper.name(x.type)?index_of("char*")><@fpmod arg=x/> ${tmapper.name(x.type)}<#if j!= -1 || i!=-1 >&</#if><@refmod arg=x.type/> ${x.name}<#if x_has_next>,</#if></#list>) <#if method.exceptions?has_content>throw (<#list method.exceptions as exception><#if tmapper.name(exception.type)!="">${tmapper.name(exception.type)}<#if exception_has_next>,</#if></#if></#list>)</#if></#macro>

