<#import "BindingSCAUtil.ftl" as bscautil>
// ****************************************************************************
// Generated by Trengen. Do not modify
// ****************************************************************************
#pragma warning(push)
#pragma warning(disable:4290)
#include "TrentinoGenBindingProxy.h"
#pragma warning(pop)
<#foreach protoBufContext in remotableReferences>
#include "<#foreach part in protoBufContext.tidlInterfaceModel.nameSpaceParts>${part}</#foreach>${protoBufContext.className}ProbobufMessages.h"
</#foreach>


<#foreach protoBufContext in remotableReferences>
<#if protoBufContext.hasBeanUtil()>
#include "<#foreach part in protoBufContext.tidlInterfaceModel.nameSpaceParts>${part}</#foreach>${protoBufContext.className}BeanUtils.h"
</#if>
</#foreach>


<#foreach usingV in contextBiningSCA.itfUsing>
using namespace ${usingV};
</#foreach>

typedef boost::shared_ptr<google::protobuf::MessageLite> MessagePtr;


<#foreach protoBufContext in remotableReferences>
<@printProxyMethods protoBufContext=protoBufContext></@printProxyMethods>

</#foreach>

<#macro printProxyMethods protoBufContext>
<#assign tmapper=protoBufContext.tmapper>
<#assign pbtmapper=protoBufContext.pbtmapper>
<#assign model=protoBufContext.tidlInterfaceModel >
<#assign className=model.qualifiedName>
<#assign className=className?replace(".","_")+"BindingProxy">
<#assign namespace=model.namespace?replace(".","::")>
//*************************************************************************************************
//BindingProxy class definition ${className}
//*************************************************************************************************
<#assign mUtil ="m"+className+"Util">
<#if protoBufContext.hasBeanUtil()>
${namespace}::${model.name}BeanUtils ${mUtil};
</#if>
//Exceptionhanling

    void ${className}throwUserExceptionIfNecessary(const trentino::bindingsca::csoap::Soap& response)
	 {
		const bool hasFault =  response.envelope().body().has_faultmessage();
		if(hasFault==true)
			throw std::runtime_error(response.envelope().body().faultmessage().detail());
	 }

//methods of binding proxy ${className}

<#foreach method in model.functions>
<#assign action=method.methodId+"_action">
<#assign rn=method.methodId+"_referenceName">
//const char* ${action} ="${method.methodId}";
//const char* ${rn}="${protoBufContext.referenceServiceInterface.referenceName}";

 ${tmapper.name(method.returnType)} Trentino::Gen::${className}::<@bscautil.methodDefArgs method=method tmapper=tmapper></@bscautil.methodDefArgs>
	 {
		protobuf::${namespace}::${model.name}::${model.name}Request_${method.methodId}Request req;
		<#foreach arg in method.arguments>
		<#if !arg.hasOut>
		<#assign argT = arg.type>
		<#if argT.primitive>
		req.set_${arg.name?lower_case}(${arg.name});
		<#elseif argT.enumeration>
		   {
			  ${pbtmapper.qName(argT)} pb;
			  ${mUtil}.copyProperties(${arg.name}, &pb);
			  req.set_${arg.name?lower_case}(pb);
		   }
		<#else>
			{
			  ${pbtmapper.qName(argT)}* pb = req.mutable_${arg.name?lower_case}();
			  ${mUtil}.copyProperties(${arg.name}, pb);
			}
		</#if>
		</#if>
		</#foreach>
       
       trentino::bindingsca::csoap::Soap response;
       mDelegate->send(&req,&response, "${method.methodId}", "${protoBufContext.referenceServiceInterface.referenceName}");
       
       ${className}throwUserExceptionIfNecessary(response);
       
       const std::string respContent = response.envelope().body().content();
       protobuf::${namespace}::${model.name}::${model.name}Response_${method.methodId}Response resp; 
       resp.ParseFromString(respContent);
       
       <#foreach arg in method.arguments>
       		<#if arg.hasOut || arg.hasInOut>
       		<#assign argT = arg.type>
		 {
		  const ${pbtmapper.qName(argT)}& pbres=resp.${arg.name?lower_case}();
		  ${mUtil}.copyProperties(pbres, ${arg.name});
		 }
       		</#if>
       </#foreach>
       <#if !method.returnType.void>
       <#assign argT = method.returnType>
	   <#if method.returnType.primitive>
	     return resp.${method.methodId?lower_case}response();
	   <#else>
	    const ${pbtmapper.qName(argT)}& pbres = resp.${method.methodId?lower_case}response();
	    ${tmapper.name(method.returnType)} ret;
	    ${mUtil}.copyProperties(pbres, ret);
	    return ret;
   		   </#if>


       </#if>
 	 }
 	 
 	 
</#foreach>

</#macro>