// ****************************************************************************
// Generated by Trengen. Do not modify
// **************************************************************************** 
<#import "ReflectionGenerator_cpp.ftl" as reflxUtil>

//header
#include "${headerFileName}.h"
#include "TrentinoGenContributionInfo.h"
<#assign ReflxStaticVariableCount = 1>

//standard
#include <boost/scoped_ptr.hpp>
#include <string.h>

#include <Global/TrentinoGlobal.h>
#include <Runtime/Invocation/TrentinoInvocationInvocationData.h>
#include <Runtime/Invocation/TrentinoInvocationInvocationContext.h> //! \todo: currently not used
#include <Runtime/Invocation/TrentinoInvocationInvokerBase.h>
#include <Runtime/RuntimeModel/TrentinoRuntimeModelWireBase.h>
#include <Runtime/RuntimeModel/TrentinoRuntimeModelServiceBase.h>
#include <Runtime/ReflectionRuntime/TrentinoReflectionRegistration.h>
#include <Runtime/Invocation/TrentinoInvocationGen.h>
<#-- this is the class to create a class for each impl -->

//specific
#pragma warning(push)
#pragma warning(disable:4290)
<#foreach include in includesList>
#include "${include}"
</#foreach>
#pragma warning(pop)

<#foreach usingDir in context.usingDirectives>
using namespace ${usingDir};
</#foreach>

namespace Trentino{
namespace Gen{


namespace
{
   //*************************************************************************************************
   //                                          WRAPPERS
   //*************************************************************************************************
<@traceServiceInterfacesList serviceInterfacesList = serviceInterfacesList> </@traceServiceInterfacesList>
} 



   //*************************************************************************************************
   //                                          PROXIES
   //*************************************************************************************************  

<@traceReferenceInterfacesList referenceInterfacesList = referenceInterfacesList> </@traceReferenceInterfacesList>


   //*************************************************************************************************
   //                                          REFLECTION CODE
   //*************************************************************************************************
  
 <@reflxUtil.init> </@reflxUtil.init>   
 <@reflxUtil.traceReflectionObjectList reflectionObjectList = reflectionObjectList> </@reflxUtil.traceReflectionObjectList>  
  
}//namespace Gen
}//namespace Trentino

<#-------------------------------------------------------------------------------------------->
<#--------------------------------------Wrapper Generation-------------------------------------->
<#-------------------------------------------------------------------------------------------->
<#-- for each implementation a class should be generated within the reflection code-->
<#macro traceServiceInterfacesList serviceInterfacesList>
<#foreach serviceInterface in serviceInterfacesList>
<@createWrapper serviceInterface = serviceInterface> </@createWrapper>
</#foreach>
</#macro>

<#macro createWrapper serviceInterface>
<#assign wrapperName = serviceInterface.interfaceClassName>
<#assign wrapperMethodName = serviceInterface.interfaceClassNamespaces?replace("::","_")+"Wrapper_invoke">
<#assign wrapperFullName = serviceInterface.interfaceClassNamespacesSemicolonSeperated>
    <#foreach interfaceMethod in serviceInterface.interfaceMethods>
     ${interfaceMethod.returnType} ${wrapperMethodName}_${interfaceMethod.id}(${wrapperFullName}* myInstance<#list interfaceMethod.arguments as x>,${x.type} ${x.name}</#list>){
      return myInstance->${interfaceMethod.name}(<#list interfaceMethod.arguments as x>${x.name}<#if x_has_next>,</#if></#list>);
     }
    </#foreach>
    
	// invoke method for wrapper: ${serviceInterface.interfaceClassNamespaces}
	void ${wrapperMethodName}(
		const Trentino::Invocation::InvocationData& data 
		,const Trentino::Invocation::InvocationContext& /*ctx*/
		,${wrapperFullName}* myInstance, void* retVal)
	{
		assert(myInstance != nullptr);
		const std::string& op = data.operation();
		<#foreach Method in serviceInterface.interfaceMethods><@createInwokerForWrapperInterface interfaceMethod = Method invokerName = wrapperName invokerFullName = wrapperFullName> </@createInwokerForWrapperInterface><#if Method_has_next>else</#if></#foreach>
	}
 
   <#assign ReflxStaticVariableCount = ReflxStaticVariableCount+1>
</#macro>
<#------ macro for generate the inner part of the invoke method --->
<#macro createInwokerForWrapperInterface  interfaceMethod invokerName invokerFullName >      
      if(op =="${interfaceMethod.id}" )
      {
        ${interfaceMethod.returnType} (*${interfaceMethod.name})(${wrapperFullName}*<#list interfaceMethod.arguments as x>,${x.type}</#list>) = &${wrapperMethodName}_${interfaceMethod.id};
        invoke(myInstance,retVal,data,${interfaceMethod.name});
      }
 </#macro>
 
<#-------------------------------------------------------------------------------------------->
<#--------------------------------------Proxy Generation-------------------------------------->
<#-------------------------------------------------------------------------------------------->
<#-- for each reference a proxy needs to be generated-->
<#macro traceReferenceInterfacesList referenceInterfacesList>
<#foreach referenceInterface in referenceInterfacesList>
<@createProxy referenceInterface = referenceInterface> </@createProxy>
</#foreach>
</#macro>

<#-- for each reference a proxy needs to be generated-->
<#macro createProxy referenceInterface>
<#assign proxyName = referenceInterface.interfaceClassName>
<#assign proxyNamespace = referenceInterface.interfaceClassNamespaces>
<#assign proxyClassName = proxyNamespace+"Proxy" >
<#assign proxyClass = referenceInterface.interfaceClassNamespacesSemicolonSeperated>
//*************************************************************************************************
//Proxy class definition ${proxyClassName}
//*************************************************************************************************
      ${proxyClassName}::${proxyClassName}(Trentino::RuntimeModel::WireBase* wire):mWire(wire){}  
<#foreach interfaceMethod in referenceInterface.interfaceMethods>
<@createInterfaceMethodDefinition interfaceMethod = interfaceMethod proxyClassName = proxyClassName> </@createInterfaceMethodDefinition>
</#foreach>
<@createInterfaceMethodCreateReflection proxyClass = proxyClass proxyClassName = proxyClassName> </@createInterfaceMethodCreateReflection>
</#macro>

<#macro createInterfaceMethodDefinition interfaceMethod proxyClassName>
 ${interfaceMethod.returnType} ${proxyClassName}::${interfaceMethod.name}(<#list interfaceMethod.arguments as x> ${x.type} ${x.name}<#if x_has_next>,</#if></#list>)
 { 
      Trentino::Invocation::InvocationData::Parameters params;
      <#assign argCount = interfaceMethod.arguments?size>
      params.reserve(${argCount});
      <#foreach argument in interfaceMethod.arguments>
      trentino_gen_internal_push_back(${argument.name},params);    
      </#foreach>
      <#assign returnType = interfaceMethod.returnType>
      invoke_helper<${returnType}> helper;
      helper.invoke("${interfaceMethod.id}",params,mWire);
      return helper.get();
   }
</#macro>

<#---------------------------------createInterfaceMethodCreateReflection------------------->
<#---------------------------------Reflection for interface method------------------------->
<#macro createInterfaceMethodCreateReflection proxyClass proxyClassName> 
  //class declaration&definition
  //****************************************************************************************************
  //                                         Initializer${proxyClassName}Rflx
  //****************************************************************************************************
  //! \brief based on implementation.cpp/class (including the parsing of namespaces in the header)
  //! most parts are static right??
  //****************************************************************************************************
   class Initializer${proxyClassName}Rflx
   {
      //****************************************************************************************************
      //                                         newObjectWithParam()
      //****************************************************************************************************
      //! \brief
      //! \param void *
      //! \param void * retVal
      //! \param void * params[]
      //! \return void TRENTINO_STDCALL
      //****************************************************************************************************
      static void TRENTINO_STDCALL newObjectWithParam(void* /*thisPtr*/, void* retVal, void* params[])
      {
         *reinterpret_cast<${proxyClassName}**>(retVal) = 
            new ${proxyClassName}(
            *reinterpret_cast<Trentino::RuntimeModel::WireBase**>(params[0]));   
      }

      //****************************************************************************************************
      //                                         deleteObject()
      //****************************************************************************************************
      //! \brief
      //! \param void * thisPtr
      //! \param void *
      //! \param void * *
      //! \return void TRENTINO_STDCALL
      //****************************************************************************************************
      static void TRENTINO_STDCALL deleteObject(void* thisPtr, void* /*retVal*/, void* /*params*/[])
      {
         ${proxyClassName}* p = 
         static_cast<${proxyClassName}*>(thisPtr);
         delete p;
      }


      //construction
   public:
      //****************************************************************************************************
      //                   Initializer${proxyClassName}Rflx()
      //****************************************************************************************************
      Initializer${proxyClassName}Rflx()
      {
         // METHOD SIGNATURES
         static const Trentino::Reflection::Data::Method::Param deleteParam[] = {{"${proxyClassName} *"}};
         static const Trentino::Reflection::Data::Method::Param newParam[] = {{"Trentino::RuntimeModel::Wire *"}};
         static Trentino::Reflection::Data::Method::MetaData mdm[] = {
            { "new", "${proxyClassName} *", newParam, COUNT_OF(newParam), newObjectWithParam }, 
            { "delete", nullptr, deleteParam, COUNT_OF(deleteParam), deleteObject },
         };

         // OBJECT
         static Trentino::Reflection::Data::Object::MetaData mdo = { 
            "${proxyClassName}", 
            nullptr, 
            mdm,
            COUNT_OF(mdm),
         };
         mmdoHandle = &mdo;
         Trentino::Reflection::Registration::registerMetaData(GenContributionInfo::getDataRegistry(),*mmdoHandle);
      }

      //****************************************************************************************************
      //                ~Initializer${proxyClassName}Rflx()
      //****************************************************************************************************
      ~Initializer${proxyClassName}Rflx()
      {
         Trentino::Reflection::Registration::unregisterMetaData(GenContributionInfo::getDataRegistry(),*mmdoHandle);
      }

      //data
   private:
      Trentino::Reflection::Data::Object::MetaData* mmdoHandle;

   }; //class Initializer${proxyClassName}Rflx
   static Initializer${proxyClassName}Rflx mInitializer${proxyClassName}Rflx${ReflxStaticVariableCount};
   <#assign ReflxStaticVariableCount = ReflxStaticVariableCount+1>	
</#macro>