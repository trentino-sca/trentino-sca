<#import "BindingSCAUtil.ftl" as bscautil>
// ****************************************************************************
// Generated by Trengen. Do not modify
// ****************************************************************************
#pragma warning(push)
#pragma warning(disable:4290)
#include "TrentinoGenIpcBindingProxy.h"
#pragma warning(pop)

#include "TrentinoGenIPCTypes.h"
#include "TrentinoGenIPCTypesConverter.h"


<#foreach usingV in contextBiningIPC.itfUsing>
using namespace ${usingV};
</#foreach>


<#foreach protoBufContext in remotableReferences>
<@printProxyMethods protoBufContext=protoBufContext></@printProxyMethods>

</#foreach>

<#macro printProxyMethods protoBufContext>
<#assign tmapper=protoBufContext.tmapper>
<#assign model=protoBufContext.tidlInterfaceModel >
<#assign className=model.qualifiedName>
<#assign className=className?replace(".","_")+"BindingProxy">
<#assign namespace=model.namespace?replace(".","::")>
//*************************************************************************************************
//BindingProxy class definition ${className}
//*************************************************************************************************
<#assign mUtil ="m"+className+"Util">
<#if protoBufContext.hasBeanUtil()>
${namespace}::${model.name}IPCBeanUtils ${mUtil};
</#if>
//Exceptionhanling

  /*  void ${className}throwUserExceptionIfNecessary(const trentino::bindingsca::csoap::Soap& response)
	 {
		const bool hasFault =  response.envelope().body().has_faultmessage();
		if(hasFault==true)
			throw std::runtime_error(response.envelope().body().faultmessage().detail());
	 }*/

//methods of binding proxy ${className}

<#foreach method in model.functions>
<#assign action=method.methodId+"_action">
<#assign rn=method.methodId+"_referenceName">
//const char* ${action} ="${method.methodId}";
//const char* ${rn}="${protoBufContext.referenceServiceInterface.referenceName}";

 ${tmapper.name(method.returnType)} Trentino::Gen::${className}::<@bscautil.methodDefArgs method=method tmapper=tmapper></@bscautil.methodDefArgs>
	 {
	 	
	  <#assign request = method.methodId + "_request">
	 	${namespace}::IpcMemoryMapObj_${method.methodId}* ${request} = managed_shm.construct< ${namespace}::IpcMemoryMapObj_${method.methodId}>("${method.methodId}")(&managed_shm);;
		<#foreach arg in method.arguments>
		<#assign name = arg.name>
     	<#assign tn=arg.type.qualifiedName?replace(".","::")>
		<#if !arg.hasOut>
		<#assign argT = arg.type>
		<#if argT.primitive>
		${request}->set_${arg.name?lower_case}(${arg.name});
		<#elseif argT.enumeration>
		   
		   
			  <#foreach part in model.nameSpaceParts>${part}::</#foreach>IPC${arg.className} pb;
			  ${mUtil}.copyProperties(${arg.name}, &pb);
			  ${request}->set_${arg.name?lower_case}(pb);

		<#else>
			
			
			  //managed_shm.destroy<<#foreach part in model.nameSpaceParts>${part}::</#foreach>IPC${arg.className}>("ipc_${arg.name}");
			  <#if arg.type.primitive>
			  //<#foreach part in model.nameSpaceParts>${part}::</#foreach>IPC${arg.className}* ipc_${arg.name} =  managed_shm.construct<<#foreach part in model.nameSpaceParts>${part}::</#foreach>IPC${arg.className}>("ipc_${arg.name}")();
			  <#else>
			  //<#foreach part in model.nameSpaceParts>${part}::</#foreach>IPC${arg.className}* ipc_${arg.name} =  managed_shm.construct<<#foreach part in model.nameSpaceParts>${part}::</#foreach>IPC${arg.className}>("ipc_${arg.name}")(&managed_shm);
			   </#if>
			  //${mUtil}.copyProperties(${arg.name}, ipc_${arg.name});
			  ${mUtil}.copyProperties(${arg.name}, ${request}->${arg.name}());
			  //${request}->set_${arg.name?lower_case}_ptr(ipc_${arg.name});
		</#if>
		</#if>
		</#foreach>
       
       	<#foreach arg in method.arguments>
		<#if !arg.hasOut>
		<#assign argT = arg.type>
		<#if argT.primitive>
		<#elseif argT.enumeration>
		<#else>
			//destroy what ever constructed to send 
			//  managed_shm.destroy<<#foreach part in model.nameSpaceParts>${part}::</#foreach>IPC${arg.className}>("ipc_${arg.name}");
		</#if>
		</#if>
		</#foreach>
      
       mDelegate->send((Trentino::Binding::IPC::IpcMemoryMapObj*)${request}, "${method.methodId}", "${protoBufContext.referenceServiceInterface.referenceName}");
       
       
       <#foreach arg in method.arguments>
       		<#if arg.hasOut || arg.hasInOut>
       		<#assign argT = arg.type>

		  <#foreach part in model.nameSpaceParts>${part}::</#foreach>IPC${arg.className}* ipcResponse = ${request}->${arg.name?lower_case}().get();
		  ${mUtil}.copyProperties(ipcResponse, &${arg.name});
		  managed_shm.destroy<${namespace}::IpcMemoryMapObj_${method.methodId}>("${method.methodId}");
       		</#if>
       </#foreach>
       <#if !method.returnType.void>
       <#assign argT = method.returnType>
	   <#if method.returnType.primitive>
	   //yy
	     managed_shm.destroy<${namespace}::IpcMemoryMapObj_${method.methodId}>("${method.methodId}");
	     return ${request}->returnValue();
	   <#else>
	   //olaaa
	    <#foreach part in model.nameSpaceParts>${part}::</#foreach>IPC${method.returnType.className}* ipcResponse = ${request}->returnValue().get();
	    ${tmapper.name(method.returnType)} ret;
	    ${mUtil}.copyProperties(ipcResponse, &ret);
	    managed_shm.destroy<${namespace}::IpcMemoryMapObj_${method.methodId}>("${method.methodId}");
	    return ret;
	    //return ${request}->returnValue();
   		</#if>


       </#if>
 	 }
 	 
 	 
</#foreach>

</#macro>