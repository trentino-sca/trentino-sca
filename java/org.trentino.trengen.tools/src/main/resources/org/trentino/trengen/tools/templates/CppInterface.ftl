<#import "CppInterface.cpp_code.ftl" as util>
<#import "BindingSCAUtil.ftl" as bscautil>
// Generated by Trentino TDIL CPP interface generator. do not modify
<#macro printTypd context typeDesc margin inline>
${margin}//****************************************************************************************************
${margin}//                                         ${typeDesc.name}
${margin}//****************************************************************************************************
${margin}//! \brief 
${margin}//****************************************************************************************************
<#if typeDesc.enumeration>
${margin}enum ${typeDesc.name}{
<#foreach field in typeDesc.fields>
${margin}	${field.name},
</#foreach>
${margin}}; //enum ${typeDesc.name}
<#else>
${margin}class <#if !inline>${exportName}_IMPORT_EXPORT</#if> ${typeDesc.name}{

<#if typeDesc.hasEnclosedClasses() >
${margin}public:
<#foreach t in typeDesc.getEnclosedClasses()>
<#assign nmargin=margin+"	">
<@printTypd context=context typeDesc=t margin=nmargin inline=inline/>
</#foreach>
</#if>


${margin}public:
${margin}// constructor and destructor---------------------------------------
${margin}	${typeDesc.name}();
${margin}	~${typeDesc.name}();

${margin}public:
${margin}// accessors -------------------------------------------------------
<#foreach field in typeDesc.fields>
<#assign name=tmapper.name(field.getType())/>
	<#assign j = name?index_of("string")>
	<#assign i = name?index_of("char*")>
 	<#if j!= -1 || i!=-1 >
${margin}	const ${name}& ${field.name}() const;
${margin}	void set_${field.name}(const std::string& value);
${margin}	void set_${field.name}(const char* value);
 	</#if>
	<#if (tmapper.isPrimitive(field.getType())==true && j== -1 && i==-1)||field.type.enumeration>
${margin}	void set_${field.name}(${name} value);
${margin}	${name} ${field.name}() const; 
	<#elseif tmapper.isComplexType(field.getType())==true && j== -1 && i==-1>
${margin}	void set_${field.name}(${name}& value);
${margin}	const ${name}& ${field.name}() const;
${margin}   ${name}& mutable_${field.name}();
${margin}	bool has_${field.name}() const;
	</#if>
</#foreach>
 
${margin}private:
${margin}//private fields
<#foreach field in typeDesc.fields>
<#assign name=tmapper.name(field.getType())/>
	<#assign j = name?index_of("string")>
	<#assign i = name?index_of("char*")>
	<#if (j!= -1 || i!=-1 || tmapper.isPrimitive(field.type)==false)&& !field.type.enumeration>
${margin}	${name} ${field.name}_;
	<#else>
${margin}	${name} ${field.name}_;
	</#if>
</#foreach>

${margin}}; //class ${typeDesc.name}
</#if>
 
</#macro>

#ifndef ${context.fileName}H
#define ${context.fileName}H

<#if context.hasInclude()>
<#foreach include in context.includes>
#include "${include}"
</#foreach>

</#if>
<#-- create the definition used for import export-->
<#assign exportName="" />
<#foreach part in context.tidlInterfaceModel.getNameSpacePartsUpperCase()>
<#assign exportName=exportName+"_"+part/>
</#foreach>
<#assign exportName=exportName?substring(1) />
<#if context.tidlInterfaceModel.useType("int")> 
#include <boost/cstdint.hpp>
</#if>
<#if context.tidlInterfaceModel.useType("string")> 
#include <string>

</#if>
<#if context.tidlInterfaceModel.useType("int")> 
typedef  boost::int32_t  tint32_t;
typedef  boost::uint32_t  tuint32_t;
typedef  boost::int64_t  tint64_t;
typedef  boost::uint64_t  tuint64_t;

</#if>
<#foreach part in context.tidlInterfaceModel.nameSpaceParts>
namespace ${part}{
</#foreach>

<#foreach typeDesc in context.tidlInterfaceModel.enclosedClasses>
<#if !typeDesc.enclosed &&  !typeDesc.enumeration >
//forward declaration ${typeDesc.name}
	class ${typeDesc.name};
</#if>
</#foreach>
<#foreach typeDesc in context.tidlInterfaceModel.nonEnclosedClasses>
<#if !typeDesc.enclosed >
<@printTypd context=context typeDesc=typeDesc margin="	" inline=inline/>
</#if>
</#foreach>

	//****************************************************************************************************
	//                                         ${context.tidlInterfaceModel.name}
	//****************************************************************************************************
	//! \brief 
	//****************************************************************************************************
	class <#if !inline>${exportName}_IMPORT_EXPORT</#if> ${context.tidlInterfaceModel.name}{

<#if context.hasEnclosedNonEnumTypes() >
	public:
<#foreach typeDesc in context.tidlInterfaceModel.enclosedClasses>
<#if !typeDesc.enumeration>
	//forward declaration ${typeDesc.name}
	class ${typeDesc.name};
</#if>
</#foreach>

</#if>
<#if context.hasEnclosedTypes() >
	public:
	
<#foreach typeDesc in context.tidlInterfaceModel.enclosedClasses>
<#if typeDesc.enclosed >
<@printTypd context=context typeDesc=typeDesc margin="		" inline=inline/>
</#if>
</#foreach>
</#if>
  //services
	public:
<#foreach method in context.tidlInterfaceModel.functions>
	virtual ${tmapper.name(method.returnType)} <@bscautil.methodDefArgs method=method tmapper=tmapper ></@bscautil.methodDefArgs>=0;
</#foreach>
  
	}; //class ${context.tidlInterfaceModel.name}
<#if inline=true>

<@util.generateCppInterfaceImpl context=context inline="inline  "/>

</#if>
<#foreach part in context.tidlInterfaceModel.nameSpaceParts>
} //namespace ${part}
</#foreach>



#endif //${context.fileName}H