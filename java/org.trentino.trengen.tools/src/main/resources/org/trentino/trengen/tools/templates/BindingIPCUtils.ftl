// ****************************************************************************
// Generated by Trengen. Do not modify
// **************************************************************************** 

#ifndef TrentinoGenIPCUtilsH
#define TrentinoGenIPCUtilsH

#include <boost/cstdint.hpp>
#include <boost/interprocess/offset_ptr.hpp>
#include <string>
#include <boost/interprocess/managed_shared_memory.hpp> 

#include <BindingIpcServer/TrentinoBindingIpcMemoryMapObj.h>

<#foreach include in includes>
#include "${include}"
</#foreach>

typedef  boost::int32_t  tint32_t;
typedef  boost::uint32_t  tuint32_t;
typedef  boost::int64_t  tint64_t;
typedef  boost::uint64_t  tuint64_t;

<#macro traceParamsFieldsPrivate type>
<#foreach field in type.fields>
	<#assign name=tmapper.name(field.getType())/>
	<#assign j = name?index_of("string")>
	<#assign i = name?index_of("char*")>
 	<#if j!= -1 || i!=-1 >
		${name} ${field.name}_;
	 </#if>
	<#if (tmapper.isPrimitive(field.type)==true && j== -1 && i==-1)||type.enumeration>
		${name} ${field.name}_; 
	<#elseif tmapper.isComplexType(field.type)==true && j== -1 && i==-1>
		<#assign name=field.className/>
		boost::interprocess::offset_ptr<IPC${name}> ${field.name}_;
	</#if>
</#foreach>
</#macro>

<#macro traceParamsFieldsPublic type>
<#foreach field in type.fields>
	<#assign name=tmapper.name(field.getType())/>
	<#assign j = name?index_of("string")>
	<#assign i = name?index_of("char*")>
 	<#if j!= -1 || i!=-1 >
		const ${name}& ${field.name}() const;
		void set_${field.name}(const std::string& value);
		void set_${field.name}(const char* value);
		void set_${field.name}(const char* value, size_t size);
		
	 </#if>
	<#if (tmapper.isPrimitive(field.type)==true && j== -1 && i==-1)||type.enumeration>
		void set_${field.name}(${name} value);
		${name} ${field.name}() const; 
		
	<#elseif tmapper.isComplexType(field.type)==true && j== -1 && i==-1>
	    <#assign name=field.className/>
		boost::interprocess::offset_ptr<IPC${name}> ${field.name}();
		void set_${field.name}_ptr(IPC${name}* ${field.name});
		bool has_${field.name}() const;
	</#if>
</#foreach>
</#macro>

<#macro traceParams arg argName>
<#assign name=tmapper.name(arg.type)/>
	<#assign j = name?index_of("string")>
	<#assign i = name?index_of("char*")>
 	<#if j!= -1 || i!=-1 >
		const ${name}& ${argName}() const;
		void set_${argName}(const std::string& value);
		void set_${argName}(const char* value);
		void set_${argName}(const char* value, size_t size);
	 </#if>
	<#if (tmapper.isPrimitive(arg.type)==true && j== -1 && i==-1)||arg.type.enumeration>
		void set_${argName}(${name} value);
		${name} ${argName}() const; 
	<#elseif tmapper.isComplexType(arg.type)==true && j== -1 && i==-1>
		<#assign name=arg.className/>
		boost::interprocess::offset_ptr<IPC${name}> ${argName}();
		void set_${argName}_ptr(IPC${name}* ${argName});
		bool has_${argName}() const;
	</#if>
</#macro>


<#macro traceParamsImpl arg argName className>
<#assign name=tmapper.name(arg.type)/>
	<#assign j = name?index_of("string")>
	<#assign i = name?index_of("char*")>
 	<#if j!= -1 || i!=-1 >
inline const ${name}& IpcMemoryMapObj_${className}::${argName}() const{
	return *${argName}_;
}

inline void IpcMemoryMapObj_${className}::set_${argName}(const std::string& value){
	if (${argName}_ == 0 ){
    	${argName}_ = new std::string;
  	}
  	${argName}_->assign(value);
}

inline void IpcMemoryMapObj_${className}::set_${argName}(const char* value){
	if (${argName}_ == 0){
		${argName}_ = new std::string;
  	}
  	${argName}_->assign(value);
}

inline void IpcMemoryMapObj_${className}::set_${argName}(const char* value, size_t size){
	if (${argName}_ == 0){
    	${argName}_ = new std::string;
  	}
  	${argName}_->assign(reinterpret_cast<const char*>(value), size);
}
</#if>
<#if (tmapper.isPrimitive(arg.type)==true && j== -1 && i==-1)||arg.type.enumeration>
inline void IpcMemoryMapObj_${className}::set_${argName}(${name} value){
	${argName}_ = value;
}

inline ${name} IpcMemoryMapObj_${className}::${argName}() const{
	return ${argName}_;
}
<#elseif tmapper.isComplexType(arg.type)==true && j== -1 && i==-1>
<#assign name=arg.className/>
inline boost::interprocess::offset_ptr<IPC${name}> IpcMemoryMapObj_${className}::${argName}(){
	return ${argName}_;
}

inline void IpcMemoryMapObj_${className}::set_${argName}_ptr(IPC${name}* ${argName}){
	${argName}_ = ${argName};
}

inline bool IpcMemoryMapObj_${className}::has_${argName}() const{
	return ${argName}_ != NULL;
}
</#if>
</#macro>

<#macro traceParamsFieldsImpl type className>
<#foreach field in type.fields>
<#assign name=tmapper.name(field.type)/>
	<#assign j = name?index_of("string")>
	<#assign i = name?index_of("char*")>
 	<#if j!= -1 || i!=-1 >
inline const ${name}& IPC${className}::${field.name}() const{
	return ${field.name}_;
}

inline void IPC${className}::set_${field.name}(const std::string& value){
	//if (${field.name}_ == 0 ){
    	//${field.name}_ = new std::string;
  	//}
  	${field.name}_.assign(value);
}

inline void IPC${className}::set_${field.name}(const char* value){
	//if (${field.name}_ == 0){
	//	${field.name}_ = new std::string;
  	//}
  	${field.name}_.assign(value);
}

inline void IPC${className}::set_${field.name}(const char* value, size_t size){
	//if (${field.name}_ == 0){
    	//${field.name}_ = new std::string;
  	//}
  	${field.name}_.assign(reinterpret_cast<const char*>(value), size);
}
</#if>
<#if (tmapper.isPrimitive(field.type)==true && j== -1 && i==-1)||type.enumeration>
inline void IPC${className}::set_${field.name}(${name} value){
	${field.name}_ = value;
}

inline ${name} IPC${className}::${field.name}() const{
	return ${field.name}_;
}
<#elseif tmapper.isComplexType(field.type)==true && j== -1 && i==-1>
<#assign name=field.type.className/>
inline boost::interprocess::offset_ptr<IPC${name}> IPC${className}::${field.name}(){
	return ${field.name}_;
}

inline void IPC${className}::set_${field.name}_ptr(IPC${name}* ${field.name}){
	${field.name}_ = ${field.name};
}

inline bool IPC${className}::has_${field.name}() const{
	return ${field.name}_ != NULL;
}
</#if>

</#foreach>
</#macro>

<#foreach ref in remotableReferences>
<#assign model=ref.tidlInterfaceModel>
<#foreach part in model.nameSpaceParts>
namespace ${part}{
</#foreach>

/////////////////////////////////////////////////////////////////////////////classes
<#foreach typeDesc in model.enclosedClasses>
<#if typeDesc.enclosed >
class IPC${typeDesc.className}; //forward decleration
</#if>
</#foreach>

<#assign classn=""/>
<#foreach typeDesc in model.enclosedClasses>
<#if typeDesc.enclosed >
<#assign classn=typeDesc.className/>
class IPC${classn} {
private:
<@traceParamsFieldsPrivate type=typeDesc />
public:
		IPC${classn}();
		~IPC${classn}();
<@traceParamsFieldsPublic type=typeDesc />
}; 

IPC${classn}::IPC${classn}(){
}

IPC${classn}::~IPC${classn}(){
}

<@traceParamsFieldsImpl type = typeDesc className = typeDesc.className />

</#if>
</#foreach>
/////////////////////////////////////////////////////////////////////////////populate classes
<#assign classn=""/>
<#foreach typeDesc in model.enclosedClasses>
<#if typeDesc.enclosed >
<#assign classn=typeDesc.className/>
IPC${typeDesc.className}* populate_IPC${typeDesc.className}(${typeDesc.namespace}::${typeDesc.className}* value, boost::interprocess::managed_shared_memory& managed_shm); // declerations
</#if>
</#foreach>


<#assign classn=""/>
<#foreach typeDesc in model.enclosedClasses>
<#if typeDesc.enclosed >
<#assign classn=typeDesc.className/>
IPC${typeDesc.className}* populate_IPC${typeDesc.className}(${typeDesc.namespace}::${typeDesc.className}* value, boost::interprocess::managed_shared_memory& managed_shm)
{
	<#foreach field in typeDesc.fields>
		<#assign name=tmapper.name(field.getType())/>
		<#assign j = name?index_of("string")>
		<#assign i = name?index_of("char*")>
		<#if tmapper.isComplexType(field.type)==true && j== -1 && i==-1>
			<#assign name=field.className/>
			IPC${name}* memMappedObj_${field.name} = populate_IPC${name}(value->mutable_${field.name}(), managed_shm);
		</#if>
	</#foreach>
	
		IPC${typeDesc.className}* ipcObj = managed_shm.construct<IPC${typeDesc.className}>("IPC${typeDesc.className}")();
		
	<#foreach field in typeDesc.fields>
		<#assign name=tmapper.name(field.getType())/>
		<#assign j = name?index_of("string")>
		<#assign i = name?index_of("char*")>
	 	<#if tmapper.isComplexType(field.type)==true && j== -1 && i==-1>
			<#assign name=field.className/>
			ipcObj->set_${field.name}_ptr(memMappedObj_${field.name});
		</#if>
	</#foreach>
	
	<#foreach field in typeDesc.fields>
		<#assign name=tmapper.name(field.getType())/>
		<#assign j = name?index_of("string")>
		<#assign i = name?index_of("char*")>
	 	<#if j!= -1 || i!=-1 >
			ipcObj->set_${field.name}(value->${field.name}());
	 	<#elseif (tmapper.isPrimitive(field.type)==true && j== -1 && i==-1)||typeDesc.enumeration>
			ipcObj->set_${field.name}(value->${field.name}());
		</#if>
	</#foreach>
	return ipcObj;
	
}

</#if>
</#foreach>


/////////////////////////////////////////////////////////////////////////////ipc method classes
<#foreach method in model.functions>

class IpcMemoryMapObj_${method.name}: public Trentino::Binding::IPC::IpcMemoryMapObj {
	private:
		//input parameters
		<#foreach arg in method.arguments>
		<#assign name=tmapper.name(arg.type)/>
		<#assign j = name?index_of("string")>
		<#assign i = name?index_of("char*")>
	 	<#if j!= -1 || i!=-1 >
		boost::interprocess::offset_ptr<${tmapper.name(arg.type)} ${arg.name}_;
		</#if>
		<#if (tmapper.isPrimitive(arg.type)==true && j== -1 && i==-1)||arg.type.enumeration>
		${tmapper.name(arg.type)} ${arg.name}_;
		<#elseif tmapper.isComplexType(arg.type)==true && j== -1 && i==-1>
		boost::interprocess::offset_ptr<IPC${arg.type.className}> ${arg.name}_;
		</#if>
		</#foreach>
		//return values	
		<#foreach argRet in method.returnArguments>
		<#assign name=tmapper.name(argRet.type)/>
		<#assign j = name?index_of("string")>
		<#assign i = name?index_of("char*")>
	 	<#if j!= -1 || i!=-1 >
		boost::interprocess::offset_ptr<${tmapper.name(argRet.type)}> returnValue_;
		</#if>
		<#if (tmapper.isPrimitive(argRet.type)==true && j== -1 && i==-1)||argRet.type.enumeration>
		${tmapper.name(argRet.type)} returnValue_;
		<#elseif tmapper.isComplexType(argRet.type)==true && j== -1 && i==-1>
		boost::interprocess::offset_ptr<IPC${argRet.className}> returnValue_;
		</#if>
		</#foreach>	
	public:
		IpcMemoryMapObj_${method.name}();
	    ~IpcMemoryMapObj_${method.name}();
	    
		<#foreach arg in method.arguments>
			<@traceParams arg = arg argName = arg.name></@traceParams>	
			
		</#foreach>
		
		<#foreach argRet in method.returnArguments>
			<@traceParams arg = argRet argName = "returnValue"></@traceParams>
		</#foreach>	
};
	
//implementation

inline IpcMemoryMapObj_${method.name}::IpcMemoryMapObj_${method.name}()
{
}

inline IpcMemoryMapObj_${method.name}::~IpcMemoryMapObj_${method.name}()
{
}
		
<#foreach arg in method.arguments>
	<@traceParamsImpl arg = arg argName = arg.name className =method.name></@traceParamsImpl>	
</#foreach>

<#foreach argRet in method.returnArguments>
	<@traceParamsImpl arg = argRet argName = "returnValue" className =method.name></@traceParamsImpl>	
</#foreach>	

</#foreach>	
<#foreach part in model.nameSpaceParts>
}
</#foreach>

</#foreach>

#endif TrentinoGenIPCUtilsH