// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ws_addressing.proto

#ifndef PROTOBUF_ws_5faddressing_2eproto__INCLUDED
#define PROTOBUF_ws_5faddressing_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace compact_soap {

// Internal implementation detail -- do not call these.
void BINDINGSCA_IMPORT_EXPORT protobuf_AddDesc_ws_5faddressing_2eproto();
void protobuf_AssignDesc_ws_5faddressing_2eproto();
void protobuf_ShutdownFile_ws_5faddressing_2eproto();

class Addressing;
class Addressing_EndpointReferenceType;
class Addressing_MultipleAny;
class Addressing_ServiceNameType;

// ===================================================================

class BINDINGSCA_IMPORT_EXPORT Addressing_EndpointReferenceType : public ::google::protobuf::Message {
 public:
  Addressing_EndpointReferenceType();
  virtual ~Addressing_EndpointReferenceType();
  
  Addressing_EndpointReferenceType(const Addressing_EndpointReferenceType& from);
  
  inline Addressing_EndpointReferenceType& operator=(const Addressing_EndpointReferenceType& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Addressing_EndpointReferenceType& default_instance();
  
  void Swap(Addressing_EndpointReferenceType* other);
  
  // implements Message ----------------------------------------------
  
  Addressing_EndpointReferenceType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Addressing_EndpointReferenceType& from);
  void MergeFrom(const Addressing_EndpointReferenceType& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string address = 1;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 1;
  inline const ::std::string& address() const;
  inline void set_address(const ::std::string& value);
  inline void set_address(const char* value);
  inline void set_address(const char* value, size_t size);
  inline ::std::string* mutable_address();
  inline ::std::string* release_address();
  
  // optional .compact_soap.Addressing.MultipleAny referenceProperties = 2;
  inline bool has_referenceproperties() const;
  inline void clear_referenceproperties();
  static const int kReferencePropertiesFieldNumber = 2;
  inline const ::compact_soap::Addressing_MultipleAny& referenceproperties() const;
  inline ::compact_soap::Addressing_MultipleAny* mutable_referenceproperties();
  inline ::compact_soap::Addressing_MultipleAny* release_referenceproperties();
  
  // optional .compact_soap.Addressing.MultipleAny referenceParameters = 3;
  inline bool has_referenceparameters() const;
  inline void clear_referenceparameters();
  static const int kReferenceParametersFieldNumber = 3;
  inline const ::compact_soap::Addressing_MultipleAny& referenceparameters() const;
  inline ::compact_soap::Addressing_MultipleAny* mutable_referenceparameters();
  inline ::compact_soap::Addressing_MultipleAny* release_referenceparameters();
  
  // optional string portType = 4;
  inline bool has_porttype() const;
  inline void clear_porttype();
  static const int kPortTypeFieldNumber = 4;
  inline const ::std::string& porttype() const;
  inline void set_porttype(const ::std::string& value);
  inline void set_porttype(const char* value);
  inline void set_porttype(const char* value, size_t size);
  inline ::std::string* mutable_porttype();
  inline ::std::string* release_porttype();
  
  // optional .compact_soap.Addressing.ServiceNameType serviceName = 5;
  inline bool has_servicename() const;
  inline void clear_servicename();
  static const int kServiceNameFieldNumber = 5;
  inline const ::compact_soap::Addressing_ServiceNameType& servicename() const;
  inline ::compact_soap::Addressing_ServiceNameType* mutable_servicename();
  inline ::compact_soap::Addressing_ServiceNameType* release_servicename();
  
  // @@protoc_insertion_point(class_scope:compact_soap.Addressing.EndpointReferenceType)
 private:
  inline void set_has_address();
  inline void clear_has_address();
  inline void set_has_referenceproperties();
  inline void clear_has_referenceproperties();
  inline void set_has_referenceparameters();
  inline void clear_has_referenceparameters();
  inline void set_has_porttype();
  inline void clear_has_porttype();
  inline void set_has_servicename();
  inline void clear_has_servicename();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* address_;
  ::compact_soap::Addressing_MultipleAny* referenceproperties_;
  ::compact_soap::Addressing_MultipleAny* referenceparameters_;
  ::std::string* porttype_;
  ::compact_soap::Addressing_ServiceNameType* servicename_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void BINDINGSCA_IMPORT_EXPORT protobuf_AddDesc_ws_5faddressing_2eproto();
  friend void protobuf_AssignDesc_ws_5faddressing_2eproto();
  friend void protobuf_ShutdownFile_ws_5faddressing_2eproto();
  
  void InitAsDefaultInstance();
  static Addressing_EndpointReferenceType* default_instance_;
};
// -------------------------------------------------------------------

class BINDINGSCA_IMPORT_EXPORT Addressing_MultipleAny : public ::google::protobuf::Message {
 public:
  Addressing_MultipleAny();
  virtual ~Addressing_MultipleAny();
  
  Addressing_MultipleAny(const Addressing_MultipleAny& from);
  
  inline Addressing_MultipleAny& operator=(const Addressing_MultipleAny& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Addressing_MultipleAny& default_instance();
  
  void Swap(Addressing_MultipleAny* other);
  
  // implements Message ----------------------------------------------
  
  Addressing_MultipleAny* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Addressing_MultipleAny& from);
  void MergeFrom(const Addressing_MultipleAny& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated string property = 1;
  inline int property_size() const;
  inline void clear_property();
  static const int kPropertyFieldNumber = 1;
  inline const ::std::string& property(int index) const;
  inline ::std::string* mutable_property(int index);
  inline void set_property(int index, const ::std::string& value);
  inline void set_property(int index, const char* value);
  inline void set_property(int index, const char* value, size_t size);
  inline ::std::string* add_property();
  inline void add_property(const ::std::string& value);
  inline void add_property(const char* value);
  inline void add_property(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& property() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_property();
  
  // @@protoc_insertion_point(class_scope:compact_soap.Addressing.MultipleAny)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::std::string> property_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void BINDINGSCA_IMPORT_EXPORT protobuf_AddDesc_ws_5faddressing_2eproto();
  friend void protobuf_AssignDesc_ws_5faddressing_2eproto();
  friend void protobuf_ShutdownFile_ws_5faddressing_2eproto();
  
  void InitAsDefaultInstance();
  static Addressing_MultipleAny* default_instance_;
};
// -------------------------------------------------------------------

class BINDINGSCA_IMPORT_EXPORT Addressing_ServiceNameType : public ::google::protobuf::Message {
 public:
  Addressing_ServiceNameType();
  virtual ~Addressing_ServiceNameType();
  
  Addressing_ServiceNameType(const Addressing_ServiceNameType& from);
  
  inline Addressing_ServiceNameType& operator=(const Addressing_ServiceNameType& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Addressing_ServiceNameType& default_instance();
  
  void Swap(Addressing_ServiceNameType* other);
  
  // implements Message ----------------------------------------------
  
  Addressing_ServiceNameType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Addressing_ServiceNameType& from);
  void MergeFrom(const Addressing_ServiceNameType& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string portName = 1;
  inline bool has_portname() const;
  inline void clear_portname();
  static const int kPortNameFieldNumber = 1;
  inline const ::std::string& portname() const;
  inline void set_portname(const ::std::string& value);
  inline void set_portname(const char* value);
  inline void set_portname(const char* value, size_t size);
  inline ::std::string* mutable_portname();
  inline ::std::string* release_portname();
  
  // @@protoc_insertion_point(class_scope:compact_soap.Addressing.ServiceNameType)
 private:
  inline void set_has_portname();
  inline void clear_has_portname();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* portname_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void BINDINGSCA_IMPORT_EXPORT protobuf_AddDesc_ws_5faddressing_2eproto();
  friend void protobuf_AssignDesc_ws_5faddressing_2eproto();
  friend void protobuf_ShutdownFile_ws_5faddressing_2eproto();
  
  void InitAsDefaultInstance();
  static Addressing_ServiceNameType* default_instance_;
};
// -------------------------------------------------------------------

class BINDINGSCA_IMPORT_EXPORT Addressing : public ::google::protobuf::Message {
 public:
  Addressing();
  virtual ~Addressing();
  
  Addressing(const Addressing& from);
  
  inline Addressing& operator=(const Addressing& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Addressing& default_instance();
  
  void Swap(Addressing* other);
  
  // implements Message ----------------------------------------------
  
  Addressing* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Addressing& from);
  void MergeFrom(const Addressing& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef Addressing_EndpointReferenceType EndpointReferenceType;
  typedef Addressing_MultipleAny MultipleAny;
  typedef Addressing_ServiceNameType ServiceNameType;
  
  // accessors -------------------------------------------------------
  
  // optional .compact_soap.Addressing.EndpointReferenceType endpointReference = 1;
  inline bool has_endpointreference() const;
  inline void clear_endpointreference();
  static const int kEndpointReferenceFieldNumber = 1;
  inline const ::compact_soap::Addressing_EndpointReferenceType& endpointreference() const;
  inline ::compact_soap::Addressing_EndpointReferenceType* mutable_endpointreference();
  inline ::compact_soap::Addressing_EndpointReferenceType* release_endpointreference();
  
  // optional string messageID = 2;
  inline bool has_messageid() const;
  inline void clear_messageid();
  static const int kMessageIDFieldNumber = 2;
  inline const ::std::string& messageid() const;
  inline void set_messageid(const ::std::string& value);
  inline void set_messageid(const char* value);
  inline void set_messageid(const char* value, size_t size);
  inline ::std::string* mutable_messageid();
  inline ::std::string* release_messageid();
  
  // optional string to = 4;
  inline bool has_to() const;
  inline void clear_to();
  static const int kToFieldNumber = 4;
  inline const ::std::string& to() const;
  inline void set_to(const ::std::string& value);
  inline void set_to(const char* value);
  inline void set_to(const char* value, size_t size);
  inline ::std::string* mutable_to();
  inline ::std::string* release_to();
  
  // optional string action = 5;
  inline bool has_action() const;
  inline void clear_action();
  static const int kActionFieldNumber = 5;
  inline const ::std::string& action() const;
  inline void set_action(const ::std::string& value);
  inline void set_action(const char* value);
  inline void set_action(const char* value, size_t size);
  inline ::std::string* mutable_action();
  inline ::std::string* release_action();
  
  // optional string from = 6;
  inline bool has_from() const;
  inline void clear_from();
  static const int kFromFieldNumber = 6;
  inline const ::std::string& from() const;
  inline void set_from(const ::std::string& value);
  inline void set_from(const char* value);
  inline void set_from(const char* value, size_t size);
  inline ::std::string* mutable_from();
  inline ::std::string* release_from();
  
  // optional .compact_soap.Addressing.EndpointReferenceType replyTo = 7;
  inline bool has_replyto() const;
  inline void clear_replyto();
  static const int kReplyToFieldNumber = 7;
  inline const ::compact_soap::Addressing_EndpointReferenceType& replyto() const;
  inline ::compact_soap::Addressing_EndpointReferenceType* mutable_replyto();
  inline ::compact_soap::Addressing_EndpointReferenceType* release_replyto();
  
  // optional .compact_soap.Addressing.EndpointReferenceType faultTo = 8;
  inline bool has_faultto() const;
  inline void clear_faultto();
  static const int kFaultToFieldNumber = 8;
  inline const ::compact_soap::Addressing_EndpointReferenceType& faultto() const;
  inline ::compact_soap::Addressing_EndpointReferenceType* mutable_faultto();
  inline ::compact_soap::Addressing_EndpointReferenceType* release_faultto();
  
  // @@protoc_insertion_point(class_scope:compact_soap.Addressing)
 private:
  inline void set_has_endpointreference();
  inline void clear_has_endpointreference();
  inline void set_has_messageid();
  inline void clear_has_messageid();
  inline void set_has_to();
  inline void clear_has_to();
  inline void set_has_action();
  inline void clear_has_action();
  inline void set_has_from();
  inline void clear_has_from();
  inline void set_has_replyto();
  inline void clear_has_replyto();
  inline void set_has_faultto();
  inline void clear_has_faultto();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::compact_soap::Addressing_EndpointReferenceType* endpointreference_;
  ::std::string* messageid_;
  ::std::string* to_;
  ::std::string* action_;
  ::std::string* from_;
  ::compact_soap::Addressing_EndpointReferenceType* replyto_;
  ::compact_soap::Addressing_EndpointReferenceType* faultto_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void BINDINGSCA_IMPORT_EXPORT protobuf_AddDesc_ws_5faddressing_2eproto();
  friend void protobuf_AssignDesc_ws_5faddressing_2eproto();
  friend void protobuf_ShutdownFile_ws_5faddressing_2eproto();
  
  void InitAsDefaultInstance();
  static Addressing* default_instance_;
};
// ===================================================================


// ===================================================================

// Addressing_EndpointReferenceType

// optional string address = 1;
inline bool Addressing_EndpointReferenceType::has_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Addressing_EndpointReferenceType::set_has_address() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Addressing_EndpointReferenceType::clear_has_address() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Addressing_EndpointReferenceType::clear_address() {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    address_->clear();
  }
  clear_has_address();
}
inline const ::std::string& Addressing_EndpointReferenceType::address() const {
  return *address_;
}
inline void Addressing_EndpointReferenceType::set_address(const ::std::string& value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void Addressing_EndpointReferenceType::set_address(const char* value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void Addressing_EndpointReferenceType::set_address(const char* value, size_t size) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Addressing_EndpointReferenceType::mutable_address() {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  return address_;
}
inline ::std::string* Addressing_EndpointReferenceType::release_address() {
  clear_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = address_;
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .compact_soap.Addressing.MultipleAny referenceProperties = 2;
inline bool Addressing_EndpointReferenceType::has_referenceproperties() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Addressing_EndpointReferenceType::set_has_referenceproperties() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Addressing_EndpointReferenceType::clear_has_referenceproperties() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Addressing_EndpointReferenceType::clear_referenceproperties() {
  if (referenceproperties_ != NULL) referenceproperties_->::compact_soap::Addressing_MultipleAny::Clear();
  clear_has_referenceproperties();
}
inline const ::compact_soap::Addressing_MultipleAny& Addressing_EndpointReferenceType::referenceproperties() const {
  return referenceproperties_ != NULL ? *referenceproperties_ : *default_instance_->referenceproperties_;
}
inline ::compact_soap::Addressing_MultipleAny* Addressing_EndpointReferenceType::mutable_referenceproperties() {
  set_has_referenceproperties();
  if (referenceproperties_ == NULL) referenceproperties_ = new ::compact_soap::Addressing_MultipleAny;
  return referenceproperties_;
}
inline ::compact_soap::Addressing_MultipleAny* Addressing_EndpointReferenceType::release_referenceproperties() {
  clear_has_referenceproperties();
  ::compact_soap::Addressing_MultipleAny* temp = referenceproperties_;
  referenceproperties_ = NULL;
  return temp;
}

// optional .compact_soap.Addressing.MultipleAny referenceParameters = 3;
inline bool Addressing_EndpointReferenceType::has_referenceparameters() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Addressing_EndpointReferenceType::set_has_referenceparameters() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Addressing_EndpointReferenceType::clear_has_referenceparameters() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Addressing_EndpointReferenceType::clear_referenceparameters() {
  if (referenceparameters_ != NULL) referenceparameters_->::compact_soap::Addressing_MultipleAny::Clear();
  clear_has_referenceparameters();
}
inline const ::compact_soap::Addressing_MultipleAny& Addressing_EndpointReferenceType::referenceparameters() const {
  return referenceparameters_ != NULL ? *referenceparameters_ : *default_instance_->referenceparameters_;
}
inline ::compact_soap::Addressing_MultipleAny* Addressing_EndpointReferenceType::mutable_referenceparameters() {
  set_has_referenceparameters();
  if (referenceparameters_ == NULL) referenceparameters_ = new ::compact_soap::Addressing_MultipleAny;
  return referenceparameters_;
}
inline ::compact_soap::Addressing_MultipleAny* Addressing_EndpointReferenceType::release_referenceparameters() {
  clear_has_referenceparameters();
  ::compact_soap::Addressing_MultipleAny* temp = referenceparameters_;
  referenceparameters_ = NULL;
  return temp;
}

// optional string portType = 4;
inline bool Addressing_EndpointReferenceType::has_porttype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Addressing_EndpointReferenceType::set_has_porttype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Addressing_EndpointReferenceType::clear_has_porttype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Addressing_EndpointReferenceType::clear_porttype() {
  if (porttype_ != &::google::protobuf::internal::kEmptyString) {
    porttype_->clear();
  }
  clear_has_porttype();
}
inline const ::std::string& Addressing_EndpointReferenceType::porttype() const {
  return *porttype_;
}
inline void Addressing_EndpointReferenceType::set_porttype(const ::std::string& value) {
  set_has_porttype();
  if (porttype_ == &::google::protobuf::internal::kEmptyString) {
    porttype_ = new ::std::string;
  }
  porttype_->assign(value);
}
inline void Addressing_EndpointReferenceType::set_porttype(const char* value) {
  set_has_porttype();
  if (porttype_ == &::google::protobuf::internal::kEmptyString) {
    porttype_ = new ::std::string;
  }
  porttype_->assign(value);
}
inline void Addressing_EndpointReferenceType::set_porttype(const char* value, size_t size) {
  set_has_porttype();
  if (porttype_ == &::google::protobuf::internal::kEmptyString) {
    porttype_ = new ::std::string;
  }
  porttype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Addressing_EndpointReferenceType::mutable_porttype() {
  set_has_porttype();
  if (porttype_ == &::google::protobuf::internal::kEmptyString) {
    porttype_ = new ::std::string;
  }
  return porttype_;
}
inline ::std::string* Addressing_EndpointReferenceType::release_porttype() {
  clear_has_porttype();
  if (porttype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = porttype_;
    porttype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .compact_soap.Addressing.ServiceNameType serviceName = 5;
inline bool Addressing_EndpointReferenceType::has_servicename() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Addressing_EndpointReferenceType::set_has_servicename() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Addressing_EndpointReferenceType::clear_has_servicename() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Addressing_EndpointReferenceType::clear_servicename() {
  if (servicename_ != NULL) servicename_->::compact_soap::Addressing_ServiceNameType::Clear();
  clear_has_servicename();
}
inline const ::compact_soap::Addressing_ServiceNameType& Addressing_EndpointReferenceType::servicename() const {
  return servicename_ != NULL ? *servicename_ : *default_instance_->servicename_;
}
inline ::compact_soap::Addressing_ServiceNameType* Addressing_EndpointReferenceType::mutable_servicename() {
  set_has_servicename();
  if (servicename_ == NULL) servicename_ = new ::compact_soap::Addressing_ServiceNameType;
  return servicename_;
}
inline ::compact_soap::Addressing_ServiceNameType* Addressing_EndpointReferenceType::release_servicename() {
  clear_has_servicename();
  ::compact_soap::Addressing_ServiceNameType* temp = servicename_;
  servicename_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// Addressing_MultipleAny

// repeated string property = 1;
inline int Addressing_MultipleAny::property_size() const {
  return property_.size();
}
inline void Addressing_MultipleAny::clear_property() {
  property_.Clear();
}
inline const ::std::string& Addressing_MultipleAny::property(int index) const {
  return property_.Get(index);
}
inline ::std::string* Addressing_MultipleAny::mutable_property(int index) {
  return property_.Mutable(index);
}
inline void Addressing_MultipleAny::set_property(int index, const ::std::string& value) {
  property_.Mutable(index)->assign(value);
}
inline void Addressing_MultipleAny::set_property(int index, const char* value) {
  property_.Mutable(index)->assign(value);
}
inline void Addressing_MultipleAny::set_property(int index, const char* value, size_t size) {
  property_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Addressing_MultipleAny::add_property() {
  return property_.Add();
}
inline void Addressing_MultipleAny::add_property(const ::std::string& value) {
  property_.Add()->assign(value);
}
inline void Addressing_MultipleAny::add_property(const char* value) {
  property_.Add()->assign(value);
}
inline void Addressing_MultipleAny::add_property(const char* value, size_t size) {
  property_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Addressing_MultipleAny::property() const {
  return property_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Addressing_MultipleAny::mutable_property() {
  return &property_;
}

// -------------------------------------------------------------------

// Addressing_ServiceNameType

// optional string portName = 1;
inline bool Addressing_ServiceNameType::has_portname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Addressing_ServiceNameType::set_has_portname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Addressing_ServiceNameType::clear_has_portname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Addressing_ServiceNameType::clear_portname() {
  if (portname_ != &::google::protobuf::internal::kEmptyString) {
    portname_->clear();
  }
  clear_has_portname();
}
inline const ::std::string& Addressing_ServiceNameType::portname() const {
  return *portname_;
}
inline void Addressing_ServiceNameType::set_portname(const ::std::string& value) {
  set_has_portname();
  if (portname_ == &::google::protobuf::internal::kEmptyString) {
    portname_ = new ::std::string;
  }
  portname_->assign(value);
}
inline void Addressing_ServiceNameType::set_portname(const char* value) {
  set_has_portname();
  if (portname_ == &::google::protobuf::internal::kEmptyString) {
    portname_ = new ::std::string;
  }
  portname_->assign(value);
}
inline void Addressing_ServiceNameType::set_portname(const char* value, size_t size) {
  set_has_portname();
  if (portname_ == &::google::protobuf::internal::kEmptyString) {
    portname_ = new ::std::string;
  }
  portname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Addressing_ServiceNameType::mutable_portname() {
  set_has_portname();
  if (portname_ == &::google::protobuf::internal::kEmptyString) {
    portname_ = new ::std::string;
  }
  return portname_;
}
inline ::std::string* Addressing_ServiceNameType::release_portname() {
  clear_has_portname();
  if (portname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = portname_;
    portname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// Addressing

// optional .compact_soap.Addressing.EndpointReferenceType endpointReference = 1;
inline bool Addressing::has_endpointreference() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Addressing::set_has_endpointreference() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Addressing::clear_has_endpointreference() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Addressing::clear_endpointreference() {
  if (endpointreference_ != NULL) endpointreference_->::compact_soap::Addressing_EndpointReferenceType::Clear();
  clear_has_endpointreference();
}
inline const ::compact_soap::Addressing_EndpointReferenceType& Addressing::endpointreference() const {
  return endpointreference_ != NULL ? *endpointreference_ : *default_instance_->endpointreference_;
}
inline ::compact_soap::Addressing_EndpointReferenceType* Addressing::mutable_endpointreference() {
  set_has_endpointreference();
  if (endpointreference_ == NULL) endpointreference_ = new ::compact_soap::Addressing_EndpointReferenceType;
  return endpointreference_;
}
inline ::compact_soap::Addressing_EndpointReferenceType* Addressing::release_endpointreference() {
  clear_has_endpointreference();
  ::compact_soap::Addressing_EndpointReferenceType* temp = endpointreference_;
  endpointreference_ = NULL;
  return temp;
}

// optional string messageID = 2;
inline bool Addressing::has_messageid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Addressing::set_has_messageid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Addressing::clear_has_messageid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Addressing::clear_messageid() {
  if (messageid_ != &::google::protobuf::internal::kEmptyString) {
    messageid_->clear();
  }
  clear_has_messageid();
}
inline const ::std::string& Addressing::messageid() const {
  return *messageid_;
}
inline void Addressing::set_messageid(const ::std::string& value) {
  set_has_messageid();
  if (messageid_ == &::google::protobuf::internal::kEmptyString) {
    messageid_ = new ::std::string;
  }
  messageid_->assign(value);
}
inline void Addressing::set_messageid(const char* value) {
  set_has_messageid();
  if (messageid_ == &::google::protobuf::internal::kEmptyString) {
    messageid_ = new ::std::string;
  }
  messageid_->assign(value);
}
inline void Addressing::set_messageid(const char* value, size_t size) {
  set_has_messageid();
  if (messageid_ == &::google::protobuf::internal::kEmptyString) {
    messageid_ = new ::std::string;
  }
  messageid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Addressing::mutable_messageid() {
  set_has_messageid();
  if (messageid_ == &::google::protobuf::internal::kEmptyString) {
    messageid_ = new ::std::string;
  }
  return messageid_;
}
inline ::std::string* Addressing::release_messageid() {
  clear_has_messageid();
  if (messageid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = messageid_;
    messageid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string to = 4;
inline bool Addressing::has_to() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Addressing::set_has_to() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Addressing::clear_has_to() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Addressing::clear_to() {
  if (to_ != &::google::protobuf::internal::kEmptyString) {
    to_->clear();
  }
  clear_has_to();
}
inline const ::std::string& Addressing::to() const {
  return *to_;
}
inline void Addressing::set_to(const ::std::string& value) {
  set_has_to();
  if (to_ == &::google::protobuf::internal::kEmptyString) {
    to_ = new ::std::string;
  }
  to_->assign(value);
}
inline void Addressing::set_to(const char* value) {
  set_has_to();
  if (to_ == &::google::protobuf::internal::kEmptyString) {
    to_ = new ::std::string;
  }
  to_->assign(value);
}
inline void Addressing::set_to(const char* value, size_t size) {
  set_has_to();
  if (to_ == &::google::protobuf::internal::kEmptyString) {
    to_ = new ::std::string;
  }
  to_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Addressing::mutable_to() {
  set_has_to();
  if (to_ == &::google::protobuf::internal::kEmptyString) {
    to_ = new ::std::string;
  }
  return to_;
}
inline ::std::string* Addressing::release_to() {
  clear_has_to();
  if (to_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = to_;
    to_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string action = 5;
inline bool Addressing::has_action() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Addressing::set_has_action() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Addressing::clear_has_action() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Addressing::clear_action() {
  if (action_ != &::google::protobuf::internal::kEmptyString) {
    action_->clear();
  }
  clear_has_action();
}
inline const ::std::string& Addressing::action() const {
  return *action_;
}
inline void Addressing::set_action(const ::std::string& value) {
  set_has_action();
  if (action_ == &::google::protobuf::internal::kEmptyString) {
    action_ = new ::std::string;
  }
  action_->assign(value);
}
inline void Addressing::set_action(const char* value) {
  set_has_action();
  if (action_ == &::google::protobuf::internal::kEmptyString) {
    action_ = new ::std::string;
  }
  action_->assign(value);
}
inline void Addressing::set_action(const char* value, size_t size) {
  set_has_action();
  if (action_ == &::google::protobuf::internal::kEmptyString) {
    action_ = new ::std::string;
  }
  action_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Addressing::mutable_action() {
  set_has_action();
  if (action_ == &::google::protobuf::internal::kEmptyString) {
    action_ = new ::std::string;
  }
  return action_;
}
inline ::std::string* Addressing::release_action() {
  clear_has_action();
  if (action_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = action_;
    action_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string from = 6;
inline bool Addressing::has_from() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Addressing::set_has_from() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Addressing::clear_has_from() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Addressing::clear_from() {
  if (from_ != &::google::protobuf::internal::kEmptyString) {
    from_->clear();
  }
  clear_has_from();
}
inline const ::std::string& Addressing::from() const {
  return *from_;
}
inline void Addressing::set_from(const ::std::string& value) {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  from_->assign(value);
}
inline void Addressing::set_from(const char* value) {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  from_->assign(value);
}
inline void Addressing::set_from(const char* value, size_t size) {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  from_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Addressing::mutable_from() {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  return from_;
}
inline ::std::string* Addressing::release_from() {
  clear_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = from_;
    from_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .compact_soap.Addressing.EndpointReferenceType replyTo = 7;
inline bool Addressing::has_replyto() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Addressing::set_has_replyto() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Addressing::clear_has_replyto() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Addressing::clear_replyto() {
  if (replyto_ != NULL) replyto_->::compact_soap::Addressing_EndpointReferenceType::Clear();
  clear_has_replyto();
}
inline const ::compact_soap::Addressing_EndpointReferenceType& Addressing::replyto() const {
  return replyto_ != NULL ? *replyto_ : *default_instance_->replyto_;
}
inline ::compact_soap::Addressing_EndpointReferenceType* Addressing::mutable_replyto() {
  set_has_replyto();
  if (replyto_ == NULL) replyto_ = new ::compact_soap::Addressing_EndpointReferenceType;
  return replyto_;
}
inline ::compact_soap::Addressing_EndpointReferenceType* Addressing::release_replyto() {
  clear_has_replyto();
  ::compact_soap::Addressing_EndpointReferenceType* temp = replyto_;
  replyto_ = NULL;
  return temp;
}

// optional .compact_soap.Addressing.EndpointReferenceType faultTo = 8;
inline bool Addressing::has_faultto() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Addressing::set_has_faultto() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Addressing::clear_has_faultto() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Addressing::clear_faultto() {
  if (faultto_ != NULL) faultto_->::compact_soap::Addressing_EndpointReferenceType::Clear();
  clear_has_faultto();
}
inline const ::compact_soap::Addressing_EndpointReferenceType& Addressing::faultto() const {
  return faultto_ != NULL ? *faultto_ : *default_instance_->faultto_;
}
inline ::compact_soap::Addressing_EndpointReferenceType* Addressing::mutable_faultto() {
  set_has_faultto();
  if (faultto_ == NULL) faultto_ = new ::compact_soap::Addressing_EndpointReferenceType;
  return faultto_;
}
inline ::compact_soap::Addressing_EndpointReferenceType* Addressing::release_faultto() {
  clear_has_faultto();
  ::compact_soap::Addressing_EndpointReferenceType* temp = faultto_;
  faultto_ = NULL;
  return temp;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace compact_soap

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ws_5faddressing_2eproto__INCLUDED
