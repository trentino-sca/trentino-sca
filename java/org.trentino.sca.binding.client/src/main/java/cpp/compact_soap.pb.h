// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: compact_soap.proto

#ifndef PROTOBUF_compact_5fsoap_2eproto__INCLUDED
#define PROTOBUF_compact_5fsoap_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include "ws_addressing.pb.h"
// @@protoc_insertion_point(includes)

namespace compact_soap {

// Internal implementation detail -- do not call these.
void BINDINGSCA_IMPORT_EXPORT protobuf_AddDesc_compact_5fsoap_2eproto();
void protobuf_AssignDesc_compact_5fsoap_2eproto();
void protobuf_ShutdownFile_compact_5fsoap_2eproto();

class Soap;
class Soap_Header;
class Soap_Body;
class Soap_Fault;
class Soap_faultreason;
class Soap_faultcode;
class Soap_subcode;
class Soap_Envelope;

enum Soap_faultcodeEnum {
  Soap_faultcodeEnum_DataEncodingUnknown = 0,
  Soap_faultcodeEnum_MustUnderstand = 1,
  Soap_faultcodeEnum_Receiver = 2,
  Soap_faultcodeEnum_Sender = 3,
  Soap_faultcodeEnum_VersionMismatch = 4
};
BINDINGSCA_IMPORT_EXPORT bool Soap_faultcodeEnum_IsValid(int value);
const Soap_faultcodeEnum Soap_faultcodeEnum_faultcodeEnum_MIN = Soap_faultcodeEnum_DataEncodingUnknown;
const Soap_faultcodeEnum Soap_faultcodeEnum_faultcodeEnum_MAX = Soap_faultcodeEnum_VersionMismatch;
const int Soap_faultcodeEnum_faultcodeEnum_ARRAYSIZE = Soap_faultcodeEnum_faultcodeEnum_MAX + 1;

BINDINGSCA_IMPORT_EXPORT const ::google::protobuf::EnumDescriptor* Soap_faultcodeEnum_descriptor();
inline const ::std::string& Soap_faultcodeEnum_Name(Soap_faultcodeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    Soap_faultcodeEnum_descriptor(), value);
}
inline bool Soap_faultcodeEnum_Parse(
    const ::std::string& name, Soap_faultcodeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Soap_faultcodeEnum>(
    Soap_faultcodeEnum_descriptor(), name, value);
}
// ===================================================================

class BINDINGSCA_IMPORT_EXPORT Soap_Header : public ::google::protobuf::Message {
 public:
  Soap_Header();
  virtual ~Soap_Header();
  
  Soap_Header(const Soap_Header& from);
  
  inline Soap_Header& operator=(const Soap_Header& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Soap_Header& default_instance();
  
  void Swap(Soap_Header* other);
  
  // implements Message ----------------------------------------------
  
  Soap_Header* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Soap_Header& from);
  void MergeFrom(const Soap_Header& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .compact_soap.Addressing addressing = 1;
  inline bool has_addressing() const;
  inline void clear_addressing();
  static const int kAddressingFieldNumber = 1;
  inline const ::compact_soap::Addressing& addressing() const;
  inline ::compact_soap::Addressing* mutable_addressing();
  inline ::compact_soap::Addressing* release_addressing();
  
  // @@protoc_insertion_point(class_scope:compact_soap.Soap.Header)
 private:
  inline void set_has_addressing();
  inline void clear_has_addressing();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::compact_soap::Addressing* addressing_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void BINDINGSCA_IMPORT_EXPORT protobuf_AddDesc_compact_5fsoap_2eproto();
  friend void protobuf_AssignDesc_compact_5fsoap_2eproto();
  friend void protobuf_ShutdownFile_compact_5fsoap_2eproto();
  
  void InitAsDefaultInstance();
  static Soap_Header* default_instance_;
};
// -------------------------------------------------------------------

class BINDINGSCA_IMPORT_EXPORT Soap_Body : public ::google::protobuf::Message {
 public:
  Soap_Body();
  virtual ~Soap_Body();
  
  Soap_Body(const Soap_Body& from);
  
  inline Soap_Body& operator=(const Soap_Body& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Soap_Body& default_instance();
  
  void Swap(Soap_Body* other);
  
  // implements Message ----------------------------------------------
  
  Soap_Body* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Soap_Body& from);
  void MergeFrom(const Soap_Body& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .compact_soap.Soap.Fault faultMessage = 1;
  inline bool has_faultmessage() const;
  inline void clear_faultmessage();
  static const int kFaultMessageFieldNumber = 1;
  inline const ::compact_soap::Soap_Fault& faultmessage() const;
  inline ::compact_soap::Soap_Fault* mutable_faultmessage();
  inline ::compact_soap::Soap_Fault* release_faultmessage();
  
  // optional bytes content = 2;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 2;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const void* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  
  // @@protoc_insertion_point(class_scope:compact_soap.Soap.Body)
 private:
  inline void set_has_faultmessage();
  inline void clear_has_faultmessage();
  inline void set_has_content();
  inline void clear_has_content();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::compact_soap::Soap_Fault* faultmessage_;
  ::std::string* content_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void BINDINGSCA_IMPORT_EXPORT protobuf_AddDesc_compact_5fsoap_2eproto();
  friend void protobuf_AssignDesc_compact_5fsoap_2eproto();
  friend void protobuf_ShutdownFile_compact_5fsoap_2eproto();
  
  void InitAsDefaultInstance();
  static Soap_Body* default_instance_;
};
// -------------------------------------------------------------------

class BINDINGSCA_IMPORT_EXPORT Soap_Fault : public ::google::protobuf::Message {
 public:
  Soap_Fault();
  virtual ~Soap_Fault();
  
  Soap_Fault(const Soap_Fault& from);
  
  inline Soap_Fault& operator=(const Soap_Fault& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Soap_Fault& default_instance();
  
  void Swap(Soap_Fault* other);
  
  // implements Message ----------------------------------------------
  
  Soap_Fault* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Soap_Fault& from);
  void MergeFrom(const Soap_Fault& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .compact_soap.Soap.faultcode Code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline const ::compact_soap::Soap_faultcode& code() const;
  inline ::compact_soap::Soap_faultcode* mutable_code();
  inline ::compact_soap::Soap_faultcode* release_code();
  
  // optional .compact_soap.Soap.faultreason Reason = 2;
  inline bool has_reason() const;
  inline void clear_reason();
  static const int kReasonFieldNumber = 2;
  inline const ::compact_soap::Soap_faultreason& reason() const;
  inline ::compact_soap::Soap_faultreason* mutable_reason();
  inline ::compact_soap::Soap_faultreason* release_reason();
  
  // optional string Node = 3;
  inline bool has_node() const;
  inline void clear_node();
  static const int kNodeFieldNumber = 3;
  inline const ::std::string& node() const;
  inline void set_node(const ::std::string& value);
  inline void set_node(const char* value);
  inline void set_node(const char* value, size_t size);
  inline ::std::string* mutable_node();
  inline ::std::string* release_node();
  
  // optional string Role = 4;
  inline bool has_role() const;
  inline void clear_role();
  static const int kRoleFieldNumber = 4;
  inline const ::std::string& role() const;
  inline void set_role(const ::std::string& value);
  inline void set_role(const char* value);
  inline void set_role(const char* value, size_t size);
  inline ::std::string* mutable_role();
  inline ::std::string* release_role();
  
  // optional bytes Detail = 5;
  inline bool has_detail() const;
  inline void clear_detail();
  static const int kDetailFieldNumber = 5;
  inline const ::std::string& detail() const;
  inline void set_detail(const ::std::string& value);
  inline void set_detail(const char* value);
  inline void set_detail(const void* value, size_t size);
  inline ::std::string* mutable_detail();
  inline ::std::string* release_detail();
  
  // @@protoc_insertion_point(class_scope:compact_soap.Soap.Fault)
 private:
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_reason();
  inline void clear_has_reason();
  inline void set_has_node();
  inline void clear_has_node();
  inline void set_has_role();
  inline void clear_has_role();
  inline void set_has_detail();
  inline void clear_has_detail();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::compact_soap::Soap_faultcode* code_;
  ::compact_soap::Soap_faultreason* reason_;
  ::std::string* node_;
  ::std::string* role_;
  ::std::string* detail_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void BINDINGSCA_IMPORT_EXPORT protobuf_AddDesc_compact_5fsoap_2eproto();
  friend void protobuf_AssignDesc_compact_5fsoap_2eproto();
  friend void protobuf_ShutdownFile_compact_5fsoap_2eproto();
  
  void InitAsDefaultInstance();
  static Soap_Fault* default_instance_;
};
// -------------------------------------------------------------------

class BINDINGSCA_IMPORT_EXPORT Soap_faultreason : public ::google::protobuf::Message {
 public:
  Soap_faultreason();
  virtual ~Soap_faultreason();
  
  Soap_faultreason(const Soap_faultreason& from);
  
  inline Soap_faultreason& operator=(const Soap_faultreason& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Soap_faultreason& default_instance();
  
  void Swap(Soap_faultreason* other);
  
  // implements Message ----------------------------------------------
  
  Soap_faultreason* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Soap_faultreason& from);
  void MergeFrom(const Soap_faultreason& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated string Text = 1;
  inline int text_size() const;
  inline void clear_text();
  static const int kTextFieldNumber = 1;
  inline const ::std::string& text(int index) const;
  inline ::std::string* mutable_text(int index);
  inline void set_text(int index, const ::std::string& value);
  inline void set_text(int index, const char* value);
  inline void set_text(int index, const char* value, size_t size);
  inline ::std::string* add_text();
  inline void add_text(const ::std::string& value);
  inline void add_text(const char* value);
  inline void add_text(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& text() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_text();
  
  // @@protoc_insertion_point(class_scope:compact_soap.Soap.faultreason)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::std::string> text_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void BINDINGSCA_IMPORT_EXPORT protobuf_AddDesc_compact_5fsoap_2eproto();
  friend void protobuf_AssignDesc_compact_5fsoap_2eproto();
  friend void protobuf_ShutdownFile_compact_5fsoap_2eproto();
  
  void InitAsDefaultInstance();
  static Soap_faultreason* default_instance_;
};
// -------------------------------------------------------------------

class BINDINGSCA_IMPORT_EXPORT Soap_faultcode : public ::google::protobuf::Message {
 public:
  Soap_faultcode();
  virtual ~Soap_faultcode();
  
  Soap_faultcode(const Soap_faultcode& from);
  
  inline Soap_faultcode& operator=(const Soap_faultcode& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Soap_faultcode& default_instance();
  
  void Swap(Soap_faultcode* other);
  
  // implements Message ----------------------------------------------
  
  Soap_faultcode* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Soap_faultcode& from);
  void MergeFrom(const Soap_faultcode& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .compact_soap.Soap.faultcodeEnum Value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline ::compact_soap::Soap_faultcodeEnum value() const;
  inline void set_value(::compact_soap::Soap_faultcodeEnum value);
  
  // optional .compact_soap.Soap.subcode Subcode = 2;
  inline bool has_subcode() const;
  inline void clear_subcode();
  static const int kSubcodeFieldNumber = 2;
  inline const ::compact_soap::Soap_subcode& subcode() const;
  inline ::compact_soap::Soap_subcode* mutable_subcode();
  inline ::compact_soap::Soap_subcode* release_subcode();
  
  // @@protoc_insertion_point(class_scope:compact_soap.Soap.faultcode)
 private:
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_subcode();
  inline void clear_has_subcode();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::compact_soap::Soap_subcode* subcode_;
  int value_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void BINDINGSCA_IMPORT_EXPORT protobuf_AddDesc_compact_5fsoap_2eproto();
  friend void protobuf_AssignDesc_compact_5fsoap_2eproto();
  friend void protobuf_ShutdownFile_compact_5fsoap_2eproto();
  
  void InitAsDefaultInstance();
  static Soap_faultcode* default_instance_;
};
// -------------------------------------------------------------------

class BINDINGSCA_IMPORT_EXPORT Soap_subcode : public ::google::protobuf::Message {
 public:
  Soap_subcode();
  virtual ~Soap_subcode();
  
  Soap_subcode(const Soap_subcode& from);
  
  inline Soap_subcode& operator=(const Soap_subcode& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Soap_subcode& default_instance();
  
  void Swap(Soap_subcode* other);
  
  // implements Message ----------------------------------------------
  
  Soap_subcode* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Soap_subcode& from);
  void MergeFrom(const Soap_subcode& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string Value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  
  // optional .compact_soap.Soap.subcode Subcode = 2;
  inline bool has_subcode() const;
  inline void clear_subcode();
  static const int kSubcodeFieldNumber = 2;
  inline const ::compact_soap::Soap_subcode& subcode() const;
  inline ::compact_soap::Soap_subcode* mutable_subcode();
  inline ::compact_soap::Soap_subcode* release_subcode();
  
  // @@protoc_insertion_point(class_scope:compact_soap.Soap.subcode)
 private:
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_subcode();
  inline void clear_has_subcode();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* value_;
  ::compact_soap::Soap_subcode* subcode_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void BINDINGSCA_IMPORT_EXPORT protobuf_AddDesc_compact_5fsoap_2eproto();
  friend void protobuf_AssignDesc_compact_5fsoap_2eproto();
  friend void protobuf_ShutdownFile_compact_5fsoap_2eproto();
  
  void InitAsDefaultInstance();
  static Soap_subcode* default_instance_;
};
// -------------------------------------------------------------------

class BINDINGSCA_IMPORT_EXPORT Soap_Envelope : public ::google::protobuf::Message {
 public:
  Soap_Envelope();
  virtual ~Soap_Envelope();
  
  Soap_Envelope(const Soap_Envelope& from);
  
  inline Soap_Envelope& operator=(const Soap_Envelope& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Soap_Envelope& default_instance();
  
  void Swap(Soap_Envelope* other);
  
  // implements Message ----------------------------------------------
  
  Soap_Envelope* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Soap_Envelope& from);
  void MergeFrom(const Soap_Envelope& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .compact_soap.Soap.Header header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::compact_soap::Soap_Header& header() const;
  inline ::compact_soap::Soap_Header* mutable_header();
  inline ::compact_soap::Soap_Header* release_header();
  
  // optional .compact_soap.Soap.Body body = 2;
  inline bool has_body() const;
  inline void clear_body();
  static const int kBodyFieldNumber = 2;
  inline const ::compact_soap::Soap_Body& body() const;
  inline ::compact_soap::Soap_Body* mutable_body();
  inline ::compact_soap::Soap_Body* release_body();
  
  // @@protoc_insertion_point(class_scope:compact_soap.Soap.Envelope)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_body();
  inline void clear_has_body();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::compact_soap::Soap_Header* header_;
  ::compact_soap::Soap_Body* body_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void BINDINGSCA_IMPORT_EXPORT protobuf_AddDesc_compact_5fsoap_2eproto();
  friend void protobuf_AssignDesc_compact_5fsoap_2eproto();
  friend void protobuf_ShutdownFile_compact_5fsoap_2eproto();
  
  void InitAsDefaultInstance();
  static Soap_Envelope* default_instance_;
};
// -------------------------------------------------------------------

class BINDINGSCA_IMPORT_EXPORT Soap : public ::google::protobuf::Message {
 public:
  Soap();
  virtual ~Soap();
  
  Soap(const Soap& from);
  
  inline Soap& operator=(const Soap& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Soap& default_instance();
  
  void Swap(Soap* other);
  
  // implements Message ----------------------------------------------
  
  Soap* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Soap& from);
  void MergeFrom(const Soap& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef Soap_Header Header;
  typedef Soap_Body Body;
  typedef Soap_Fault Fault;
  typedef Soap_faultreason faultreason;
  typedef Soap_faultcode faultcode;
  typedef Soap_subcode subcode;
  typedef Soap_Envelope Envelope;
  
  typedef Soap_faultcodeEnum faultcodeEnum;
  static const faultcodeEnum DataEncodingUnknown = Soap_faultcodeEnum_DataEncodingUnknown;
  static const faultcodeEnum MustUnderstand = Soap_faultcodeEnum_MustUnderstand;
  static const faultcodeEnum Receiver = Soap_faultcodeEnum_Receiver;
  static const faultcodeEnum Sender = Soap_faultcodeEnum_Sender;
  static const faultcodeEnum VersionMismatch = Soap_faultcodeEnum_VersionMismatch;
  static inline bool faultcodeEnum_IsValid(int value) {
    return Soap_faultcodeEnum_IsValid(value);
  }
  static const faultcodeEnum faultcodeEnum_MIN =
    Soap_faultcodeEnum_faultcodeEnum_MIN;
  static const faultcodeEnum faultcodeEnum_MAX =
    Soap_faultcodeEnum_faultcodeEnum_MAX;
  static const int faultcodeEnum_ARRAYSIZE =
    Soap_faultcodeEnum_faultcodeEnum_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  faultcodeEnum_descriptor() {
    return Soap_faultcodeEnum_descriptor();
  }
  static inline const ::std::string& faultcodeEnum_Name(faultcodeEnum value) {
    return Soap_faultcodeEnum_Name(value);
  }
  static inline bool faultcodeEnum_Parse(const ::std::string& name,
      faultcodeEnum* value) {
    return Soap_faultcodeEnum_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional .compact_soap.Soap.Envelope envelope = 1;
  inline bool has_envelope() const;
  inline void clear_envelope();
  static const int kEnvelopeFieldNumber = 1;
  inline const ::compact_soap::Soap_Envelope& envelope() const;
  inline ::compact_soap::Soap_Envelope* mutable_envelope();
  inline ::compact_soap::Soap_Envelope* release_envelope();
  
  // @@protoc_insertion_point(class_scope:compact_soap.Soap)
 private:
  inline void set_has_envelope();
  inline void clear_has_envelope();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::compact_soap::Soap_Envelope* envelope_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void BINDINGSCA_IMPORT_EXPORT protobuf_AddDesc_compact_5fsoap_2eproto();
  friend void protobuf_AssignDesc_compact_5fsoap_2eproto();
  friend void protobuf_ShutdownFile_compact_5fsoap_2eproto();
  
  void InitAsDefaultInstance();
  static Soap* default_instance_;
};
// ===================================================================


// ===================================================================

// Soap_Header

// optional .compact_soap.Addressing addressing = 1;
inline bool Soap_Header::has_addressing() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Soap_Header::set_has_addressing() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Soap_Header::clear_has_addressing() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Soap_Header::clear_addressing() {
  if (addressing_ != NULL) addressing_->::compact_soap::Addressing::Clear();
  clear_has_addressing();
}
inline const ::compact_soap::Addressing& Soap_Header::addressing() const {
  return addressing_ != NULL ? *addressing_ : *default_instance_->addressing_;
}
inline ::compact_soap::Addressing* Soap_Header::mutable_addressing() {
  set_has_addressing();
  if (addressing_ == NULL) addressing_ = new ::compact_soap::Addressing;
  return addressing_;
}
inline ::compact_soap::Addressing* Soap_Header::release_addressing() {
  clear_has_addressing();
  ::compact_soap::Addressing* temp = addressing_;
  addressing_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// Soap_Body

// optional .compact_soap.Soap.Fault faultMessage = 1;
inline bool Soap_Body::has_faultmessage() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Soap_Body::set_has_faultmessage() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Soap_Body::clear_has_faultmessage() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Soap_Body::clear_faultmessage() {
  if (faultmessage_ != NULL) faultmessage_->::compact_soap::Soap_Fault::Clear();
  clear_has_faultmessage();
}
inline const ::compact_soap::Soap_Fault& Soap_Body::faultmessage() const {
  return faultmessage_ != NULL ? *faultmessage_ : *default_instance_->faultmessage_;
}
inline ::compact_soap::Soap_Fault* Soap_Body::mutable_faultmessage() {
  set_has_faultmessage();
  if (faultmessage_ == NULL) faultmessage_ = new ::compact_soap::Soap_Fault;
  return faultmessage_;
}
inline ::compact_soap::Soap_Fault* Soap_Body::release_faultmessage() {
  clear_has_faultmessage();
  ::compact_soap::Soap_Fault* temp = faultmessage_;
  faultmessage_ = NULL;
  return temp;
}

// optional bytes content = 2;
inline bool Soap_Body::has_content() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Soap_Body::set_has_content() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Soap_Body::clear_has_content() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Soap_Body::clear_content() {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& Soap_Body::content() const {
  return *content_;
}
inline void Soap_Body::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void Soap_Body::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void Soap_Body::set_content(const void* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Soap_Body::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  return content_;
}
inline ::std::string* Soap_Body::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// Soap_Fault

// optional .compact_soap.Soap.faultcode Code = 1;
inline bool Soap_Fault::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Soap_Fault::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Soap_Fault::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Soap_Fault::clear_code() {
  if (code_ != NULL) code_->::compact_soap::Soap_faultcode::Clear();
  clear_has_code();
}
inline const ::compact_soap::Soap_faultcode& Soap_Fault::code() const {
  return code_ != NULL ? *code_ : *default_instance_->code_;
}
inline ::compact_soap::Soap_faultcode* Soap_Fault::mutable_code() {
  set_has_code();
  if (code_ == NULL) code_ = new ::compact_soap::Soap_faultcode;
  return code_;
}
inline ::compact_soap::Soap_faultcode* Soap_Fault::release_code() {
  clear_has_code();
  ::compact_soap::Soap_faultcode* temp = code_;
  code_ = NULL;
  return temp;
}

// optional .compact_soap.Soap.faultreason Reason = 2;
inline bool Soap_Fault::has_reason() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Soap_Fault::set_has_reason() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Soap_Fault::clear_has_reason() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Soap_Fault::clear_reason() {
  if (reason_ != NULL) reason_->::compact_soap::Soap_faultreason::Clear();
  clear_has_reason();
}
inline const ::compact_soap::Soap_faultreason& Soap_Fault::reason() const {
  return reason_ != NULL ? *reason_ : *default_instance_->reason_;
}
inline ::compact_soap::Soap_faultreason* Soap_Fault::mutable_reason() {
  set_has_reason();
  if (reason_ == NULL) reason_ = new ::compact_soap::Soap_faultreason;
  return reason_;
}
inline ::compact_soap::Soap_faultreason* Soap_Fault::release_reason() {
  clear_has_reason();
  ::compact_soap::Soap_faultreason* temp = reason_;
  reason_ = NULL;
  return temp;
}

// optional string Node = 3;
inline bool Soap_Fault::has_node() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Soap_Fault::set_has_node() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Soap_Fault::clear_has_node() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Soap_Fault::clear_node() {
  if (node_ != &::google::protobuf::internal::kEmptyString) {
    node_->clear();
  }
  clear_has_node();
}
inline const ::std::string& Soap_Fault::node() const {
  return *node_;
}
inline void Soap_Fault::set_node(const ::std::string& value) {
  set_has_node();
  if (node_ == &::google::protobuf::internal::kEmptyString) {
    node_ = new ::std::string;
  }
  node_->assign(value);
}
inline void Soap_Fault::set_node(const char* value) {
  set_has_node();
  if (node_ == &::google::protobuf::internal::kEmptyString) {
    node_ = new ::std::string;
  }
  node_->assign(value);
}
inline void Soap_Fault::set_node(const char* value, size_t size) {
  set_has_node();
  if (node_ == &::google::protobuf::internal::kEmptyString) {
    node_ = new ::std::string;
  }
  node_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Soap_Fault::mutable_node() {
  set_has_node();
  if (node_ == &::google::protobuf::internal::kEmptyString) {
    node_ = new ::std::string;
  }
  return node_;
}
inline ::std::string* Soap_Fault::release_node() {
  clear_has_node();
  if (node_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = node_;
    node_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Role = 4;
inline bool Soap_Fault::has_role() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Soap_Fault::set_has_role() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Soap_Fault::clear_has_role() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Soap_Fault::clear_role() {
  if (role_ != &::google::protobuf::internal::kEmptyString) {
    role_->clear();
  }
  clear_has_role();
}
inline const ::std::string& Soap_Fault::role() const {
  return *role_;
}
inline void Soap_Fault::set_role(const ::std::string& value) {
  set_has_role();
  if (role_ == &::google::protobuf::internal::kEmptyString) {
    role_ = new ::std::string;
  }
  role_->assign(value);
}
inline void Soap_Fault::set_role(const char* value) {
  set_has_role();
  if (role_ == &::google::protobuf::internal::kEmptyString) {
    role_ = new ::std::string;
  }
  role_->assign(value);
}
inline void Soap_Fault::set_role(const char* value, size_t size) {
  set_has_role();
  if (role_ == &::google::protobuf::internal::kEmptyString) {
    role_ = new ::std::string;
  }
  role_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Soap_Fault::mutable_role() {
  set_has_role();
  if (role_ == &::google::protobuf::internal::kEmptyString) {
    role_ = new ::std::string;
  }
  return role_;
}
inline ::std::string* Soap_Fault::release_role() {
  clear_has_role();
  if (role_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = role_;
    role_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes Detail = 5;
inline bool Soap_Fault::has_detail() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Soap_Fault::set_has_detail() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Soap_Fault::clear_has_detail() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Soap_Fault::clear_detail() {
  if (detail_ != &::google::protobuf::internal::kEmptyString) {
    detail_->clear();
  }
  clear_has_detail();
}
inline const ::std::string& Soap_Fault::detail() const {
  return *detail_;
}
inline void Soap_Fault::set_detail(const ::std::string& value) {
  set_has_detail();
  if (detail_ == &::google::protobuf::internal::kEmptyString) {
    detail_ = new ::std::string;
  }
  detail_->assign(value);
}
inline void Soap_Fault::set_detail(const char* value) {
  set_has_detail();
  if (detail_ == &::google::protobuf::internal::kEmptyString) {
    detail_ = new ::std::string;
  }
  detail_->assign(value);
}
inline void Soap_Fault::set_detail(const void* value, size_t size) {
  set_has_detail();
  if (detail_ == &::google::protobuf::internal::kEmptyString) {
    detail_ = new ::std::string;
  }
  detail_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Soap_Fault::mutable_detail() {
  set_has_detail();
  if (detail_ == &::google::protobuf::internal::kEmptyString) {
    detail_ = new ::std::string;
  }
  return detail_;
}
inline ::std::string* Soap_Fault::release_detail() {
  clear_has_detail();
  if (detail_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = detail_;
    detail_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// Soap_faultreason

// repeated string Text = 1;
inline int Soap_faultreason::text_size() const {
  return text_.size();
}
inline void Soap_faultreason::clear_text() {
  text_.Clear();
}
inline const ::std::string& Soap_faultreason::text(int index) const {
  return text_.Get(index);
}
inline ::std::string* Soap_faultreason::mutable_text(int index) {
  return text_.Mutable(index);
}
inline void Soap_faultreason::set_text(int index, const ::std::string& value) {
  text_.Mutable(index)->assign(value);
}
inline void Soap_faultreason::set_text(int index, const char* value) {
  text_.Mutable(index)->assign(value);
}
inline void Soap_faultreason::set_text(int index, const char* value, size_t size) {
  text_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Soap_faultreason::add_text() {
  return text_.Add();
}
inline void Soap_faultreason::add_text(const ::std::string& value) {
  text_.Add()->assign(value);
}
inline void Soap_faultreason::add_text(const char* value) {
  text_.Add()->assign(value);
}
inline void Soap_faultreason::add_text(const char* value, size_t size) {
  text_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Soap_faultreason::text() const {
  return text_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Soap_faultreason::mutable_text() {
  return &text_;
}

// -------------------------------------------------------------------

// Soap_faultcode

// optional .compact_soap.Soap.faultcodeEnum Value = 1;
inline bool Soap_faultcode::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Soap_faultcode::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Soap_faultcode::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Soap_faultcode::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline ::compact_soap::Soap_faultcodeEnum Soap_faultcode::value() const {
  return static_cast< ::compact_soap::Soap_faultcodeEnum >(value_);
}
inline void Soap_faultcode::set_value(::compact_soap::Soap_faultcodeEnum value) {
  GOOGLE_DCHECK(::compact_soap::Soap_faultcodeEnum_IsValid(value));
  set_has_value();
  value_ = value;
}

// optional .compact_soap.Soap.subcode Subcode = 2;
inline bool Soap_faultcode::has_subcode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Soap_faultcode::set_has_subcode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Soap_faultcode::clear_has_subcode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Soap_faultcode::clear_subcode() {
  if (subcode_ != NULL) subcode_->::compact_soap::Soap_subcode::Clear();
  clear_has_subcode();
}
inline const ::compact_soap::Soap_subcode& Soap_faultcode::subcode() const {
  return subcode_ != NULL ? *subcode_ : *default_instance_->subcode_;
}
inline ::compact_soap::Soap_subcode* Soap_faultcode::mutable_subcode() {
  set_has_subcode();
  if (subcode_ == NULL) subcode_ = new ::compact_soap::Soap_subcode;
  return subcode_;
}
inline ::compact_soap::Soap_subcode* Soap_faultcode::release_subcode() {
  clear_has_subcode();
  ::compact_soap::Soap_subcode* temp = subcode_;
  subcode_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// Soap_subcode

// optional string Value = 1;
inline bool Soap_subcode::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Soap_subcode::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Soap_subcode::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Soap_subcode::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& Soap_subcode::value() const {
  return *value_;
}
inline void Soap_subcode::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Soap_subcode::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Soap_subcode::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Soap_subcode::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* Soap_subcode::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .compact_soap.Soap.subcode Subcode = 2;
inline bool Soap_subcode::has_subcode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Soap_subcode::set_has_subcode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Soap_subcode::clear_has_subcode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Soap_subcode::clear_subcode() {
  if (subcode_ != NULL) subcode_->::compact_soap::Soap_subcode::Clear();
  clear_has_subcode();
}
inline const ::compact_soap::Soap_subcode& Soap_subcode::subcode() const {
  return subcode_ != NULL ? *subcode_ : *default_instance_->subcode_;
}
inline ::compact_soap::Soap_subcode* Soap_subcode::mutable_subcode() {
  set_has_subcode();
  if (subcode_ == NULL) subcode_ = new ::compact_soap::Soap_subcode;
  return subcode_;
}
inline ::compact_soap::Soap_subcode* Soap_subcode::release_subcode() {
  clear_has_subcode();
  ::compact_soap::Soap_subcode* temp = subcode_;
  subcode_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// Soap_Envelope

// optional .compact_soap.Soap.Header header = 1;
inline bool Soap_Envelope::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Soap_Envelope::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Soap_Envelope::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Soap_Envelope::clear_header() {
  if (header_ != NULL) header_->::compact_soap::Soap_Header::Clear();
  clear_has_header();
}
inline const ::compact_soap::Soap_Header& Soap_Envelope::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::compact_soap::Soap_Header* Soap_Envelope::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::compact_soap::Soap_Header;
  return header_;
}
inline ::compact_soap::Soap_Header* Soap_Envelope::release_header() {
  clear_has_header();
  ::compact_soap::Soap_Header* temp = header_;
  header_ = NULL;
  return temp;
}

// optional .compact_soap.Soap.Body body = 2;
inline bool Soap_Envelope::has_body() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Soap_Envelope::set_has_body() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Soap_Envelope::clear_has_body() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Soap_Envelope::clear_body() {
  if (body_ != NULL) body_->::compact_soap::Soap_Body::Clear();
  clear_has_body();
}
inline const ::compact_soap::Soap_Body& Soap_Envelope::body() const {
  return body_ != NULL ? *body_ : *default_instance_->body_;
}
inline ::compact_soap::Soap_Body* Soap_Envelope::mutable_body() {
  set_has_body();
  if (body_ == NULL) body_ = new ::compact_soap::Soap_Body;
  return body_;
}
inline ::compact_soap::Soap_Body* Soap_Envelope::release_body() {
  clear_has_body();
  ::compact_soap::Soap_Body* temp = body_;
  body_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// Soap

// optional .compact_soap.Soap.Envelope envelope = 1;
inline bool Soap::has_envelope() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Soap::set_has_envelope() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Soap::clear_has_envelope() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Soap::clear_envelope() {
  if (envelope_ != NULL) envelope_->::compact_soap::Soap_Envelope::Clear();
  clear_has_envelope();
}
inline const ::compact_soap::Soap_Envelope& Soap::envelope() const {
  return envelope_ != NULL ? *envelope_ : *default_instance_->envelope_;
}
inline ::compact_soap::Soap_Envelope* Soap::mutable_envelope() {
  set_has_envelope();
  if (envelope_ == NULL) envelope_ = new ::compact_soap::Soap_Envelope;
  return envelope_;
}
inline ::compact_soap::Soap_Envelope* Soap::release_envelope() {
  clear_has_envelope();
  ::compact_soap::Soap_Envelope* temp = envelope_;
  envelope_ = NULL;
  return temp;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace compact_soap

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::compact_soap::Soap_faultcodeEnum>() {
  return ::compact_soap::Soap_faultcodeEnum_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_compact_5fsoap_2eproto__INCLUDED
