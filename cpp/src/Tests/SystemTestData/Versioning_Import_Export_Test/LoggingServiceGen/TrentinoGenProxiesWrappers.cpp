// ****************************************************************************
// Generated by Trengen. Do not modify
// **************************************************************************** 

//header
#include "TrentinoGenProxiesWrappers.h"
#include "TrentinoGenContributionInfo.h"

//standard
#include <boost/scoped_ptr.hpp>
#include <string.h>

#include <Global/TrentinoGlobal.h>
#include <Runtime/Invocation/TrentinoInvocationInvocationData.h>
#include <Runtime/Invocation/TrentinoInvocationInvocationContext.h> //! \todo: currently not used
#include <Runtime/Invocation/TrentinoInvocationInvokerBase.h>
#include <Runtime/RuntimeModel/TrentinoRuntimeModelWireBase.h>
#include <Runtime/RuntimeModel/TrentinoRuntimeModelServiceBase.h>
#include <Runtime/ReflectionRuntime/TrentinoReflectionRegistration.h>
#include <Runtime/Invocation/TrentinoInvocationGen.h>

//specific
#pragma warning(push)
#pragma warning(disable:4290)
#include "services/TrentinoExampleLoggingLoggingServiceImpl.h"
#pragma warning(pop)

using namespace Trentino::Example::Logging;

namespace Trentino{
namespace Gen{


namespace
{
   //*************************************************************************************************
   //                                          WRAPPERS
   //*************************************************************************************************
     void Trentino_Example_Logging_LoggingServiceWrapper_invoke_logError(Trentino::Example::Logging::LoggingService* myInstance,const char* log){
      return myInstance->logError(log);
     }
     void Trentino_Example_Logging_LoggingServiceWrapper_invoke_logDebug(Trentino::Example::Logging::LoggingService* myInstance,const char* log){
      return myInstance->logDebug(log);
     }
     void Trentino_Example_Logging_LoggingServiceWrapper_invoke_logInfo(Trentino::Example::Logging::LoggingService* myInstance,const char* log){
      return myInstance->logInfo(log);
     }
    
	// invoke method for wrapper: Trentino_Example_Logging_LoggingService
	void Trentino_Example_Logging_LoggingServiceWrapper_invoke(
		const Trentino::Invocation::InvocationData& data 
		,const Trentino::Invocation::InvocationContext& /*ctx*/
		,Trentino::Example::Logging::LoggingService* myInstance, void* retVal)
	{
		assert(myInstance != nullptr);
		const std::string& op = data.operation();
		      if(op =="logError" )
      {
        void (*logError)(Trentino::Example::Logging::LoggingService*,const char*) = &Trentino_Example_Logging_LoggingServiceWrapper_invoke_logError;
        invoke(myInstance,retVal,data,logError);
      }
else      if(op =="logDebug" )
      {
        void (*logDebug)(Trentino::Example::Logging::LoggingService*,const char*) = &Trentino_Example_Logging_LoggingServiceWrapper_invoke_logDebug;
        invoke(myInstance,retVal,data,logDebug);
      }
else      if(op =="logInfo" )
      {
        void (*logInfo)(Trentino::Example::Logging::LoggingService*,const char*) = &Trentino_Example_Logging_LoggingServiceWrapper_invoke_logInfo;
        invoke(myInstance,retVal,data,logInfo);
      }

	}
 


} 



   //*************************************************************************************************
   //                                          PROXIES
   //*************************************************************************************************  




   //*************************************************************************************************
   //                                          REFLECTION CODE
   //*************************************************************************************************
  
 static const Trentino::Reflection::Data::Method::Param trentino_internal_invoke_cpp_componentParam[] ={{"void *"},
		    {"const Trentino::XML::Schema::Name&"},
		    {"const Trentino::Invocation::InvocationData&"},
		    {"const Trentino::Invocation::InvocationContext&"},
		    {"void *"}};
   
 	//*************************************************************************************************
	// class declaration
	// InitializerTrentino_Example_Logging_LoggingServiceImplRflx
	//*************************************************************************************************	    
   	class InitializerTrentino_Example_Logging_LoggingServiceImplRflx
  	 {
  	 
		//! This is the new callback to create component, retVal is a pointer of pointer which contains
		//! the address of object
		static void TRENTINO_STDCALL newObjectNoParam(void* /*thisPtr*/, void* retVal, void* /*params*/[])
		{
			*reinterpret_cast<Trentino::Example::Logging::LoggingServiceImpl**>(retVal) = 
			new Trentino::Example::Logging::LoggingServiceImpl();
		}
		
		//! you need only thisPtr and a simple static_cast to destroy object by default delete
		static void TRENTINO_STDCALL deleteObject(void* thisPtr, void* /*retVal*/, void* /*params*/[])
		{
			Trentino::Example::Logging::LoggingServiceImpl* p = 
			static_cast<Trentino::Example::Logging::LoggingServiceImpl*>(thisPtr);
			delete p;
		}
		
		static void TRENTINO_STDCALL impl_cpp_invoke(void* thisPtr,void* /*retVal*/, void* params[]){
         Trentino::XML::Schema::Name& serviceId = *static_cast<Trentino::XML::Schema::Name*>(params[0]);
         const char* serviceIdChar = serviceId.c_str();
         const Trentino::Invocation::InvocationData& data = *static_cast<const Trentino::Invocation::InvocationData*>(params[1]);
         const Trentino::Invocation::InvocationContext& ctx =*static_cast<const Trentino::Invocation::InvocationContext*>(params[2]);
		Trentino::Example::Logging::LoggingServiceImpl* p = static_cast<Trentino::Example::Logging::LoggingServiceImpl*>(thisPtr);
		void * retVal = params[3];	
		   if(strcmp(serviceIdChar, "Trentino::Example::Logging::LoggingService") == 0)
			{
			 Trentino_Example_Logging_LoggingServiceWrapper_invoke(data, ctx, dynamic_cast<Trentino::Example::Logging::LoggingService*>(p), retVal);
			 return;
			}

		
		}
		
		//a setter method is needed for each reference of the componentType
	 
	 	 	//a setter method is needed for each property of the componentType
		static void TRENTINO_STDCALL setloggerNameMethod(void* thisPtr, void* /*retVal*/, void* params[])
		{
			Trentino::Example::Logging::LoggingServiceImpl* p = static_cast<Trentino::Example::Logging::LoggingServiceImpl*>(thisPtr);
			p->setLoggerName(*reinterpret_cast<char**>(params[0]));
		}
		//For every class with more than one base class, a corresponding castCall() function must be generated 
		//and registered in the reflection class.   This also applies to the class if any of its predecessors 
		//have more than one base class or even there are more than one base classes in the whole inheritance 
		//hierarchy since this causes the same kind of problem as with direct inheritance.  As as a robust 
		//solution can be considered the generation of cast function for all classes disregarding the actual 
		//number of base classes.		
		static void* TRENTINO_STDCALL castCallMyComponent (void* thisPtr, const char* castInto )
		{
			
			if(strcmp(castInto, "Trentino::Example::Logging::LoggingService") == 0)
			{
				return static_cast<Trentino::Example::Logging::LoggingService*>
				(static_cast<Trentino::Example::Logging::LoggingServiceImpl*>(thisPtr));
			}
			
			return thisPtr;
		}
		
		//construction
		
		public:
		InitializerTrentino_Example_Logging_LoggingServiceImplRflx()
		{

			//struct is necessary to find correct parameterlist by runtime
			static const Trentino::Reflection::Data::Method::Param deleteParamMyComponent[] = {{"Trentino::Example::Logging::LoggingServiceImpl *"}};
			static const Trentino::Reflection::Data::Method::Param setloggerNameMethodParams[] = {{"std::string" }};
			//define all "public" functions seen by reflection runtime
			static Trentino::Reflection::Data::Method::MetaData mdmMyComponent[] = {
			{"setloggerName", nullptr, setloggerNameMethodParams, COUNT_OF(setloggerNameMethodParams), setloggerNameMethod},
            //word "new" is reserved and can be overloaded with parameter constructors, will be
			//called by ReflectObject::newInstance
			{ "new", "Trentino::Example::Logging::LoggingServiceImpl*", nullptr, 0, newObjectNoParam },
			//word "delete" is reserved for destroying object and will be called by 
			//ReflectObject::deleteInstance or ReflectObject::deleteRegisteredInstance
			{ "delete", nullptr, deleteParamMyComponent, COUNT_OF(deleteParamMyComponent), deleteObject },
			{"trentino_internal_impl_cpp_invoke_do_not_use_this_name",nullptr,trentino_internal_invoke_cpp_componentParam,COUNT_OF(trentino_internal_invoke_cpp_componentParam),impl_cpp_invoke},
         };

         //register whole object
         static Trentino::Reflection::Data::Object::MetaData mdo = { 
            "Trentino::Example::Logging::LoggingServiceImpl", 
            nullptr, //passing a pointer to the generated cast call function
            mdmMyComponent, //ok register here my methodlist, incl. new and delete functions
            COUNT_OF(mdmMyComponent), //number of functions
         };

         // store it in initializer class to unregister it by destructor
         mmdoHandle = &mdo;

         //register class in reflection runtime
         Trentino::Reflection::Registration::registerMetaData(GenContributionInfo::getDataRegistry(),*mmdoHandle);
      }

      ~InitializerTrentino_Example_Logging_LoggingServiceImplRflx()
      {
         //Important: donÂ´t forget to unregister, rflx dlls can be unloaded!
         Trentino::Reflection::Registration::unregisterMetaData(GenContributionInfo::getDataRegistry(),*mmdoHandle);
      }

      //data
   private:
      Trentino::Reflection::Data::Object::MetaData* mmdoHandle;

   };//class InitializerTrentino_Example_Logging_LoggingServiceImplRflx
   static InitializerTrentino_Example_Logging_LoggingServiceImplRflx mInitializerTrentino_Example_Logging_LoggingServiceImplRflx1;

  
  
}//namespace Gen
}//namespace Trentino

