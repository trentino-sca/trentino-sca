// Generated by Trentino TDIL CPP interface generator. do not modify

#include "TrentinoExampleBasicCalculatorRemoteBasicCalculator.h"

#ifndef NULL
#define NULL 0
#endif

using namespace ::Trentino::Example::BasicCalculatorIPC;


//********************************************************************************************
//!                             Class Address
//********************************************************************************************
BasicCalculator::Address::Address (){ 
	street_ = NULL;
	phone_ = NULL;
}

BasicCalculator::Address::~Address(){
	delete street_;
	delete phone_;
}
BasicCalculator::Address* BasicCalculator::Address::default_instance_ = NULL;

const BasicCalculator::Address& BasicCalculator::Address::default_instance() {
  if (default_instance_ == NULL) {
   default_instance_ = new BasicCalculator::Address();
  }
  return *default_instance_;
}



 const std::string& BasicCalculator::Address::street() const{
	return *street_;
}

 void BasicCalculator::Address::set_street(const std::string& value){
	if (street_ == 0 ){
    	street_ = new std::string;
  	}
  	street_->assign(value);
}

 void BasicCalculator::Address::set_street(const char* value){
	if (street_ == 0){
		street_ = new std::string;
  	}
  	street_->assign(value);
}

 void BasicCalculator::Address::set_street(const char* value, size_t size){
	if (street_ == 0){
    	street_ = new std::string;
  	}
  	street_->assign(reinterpret_cast<const char*>(value), size);
}


	


 bool BasicCalculator::Address::has_phone() const{
	if (phone_ == NULL ) {
    	return false;
  	}
  	return true;
}

 BasicCalculator::Phone* BasicCalculator::Address::mutable_phone(){
	if (phone_==NULL)
		phone_ = new BasicCalculator::Phone;
	return phone_;
}

 BasicCalculator::Phone& BasicCalculator::Address::phone() const{
 	if (phone_ != NULL)
		return *phone_;

	if ( default_instance_ == NULL)
		default_instance();
	return *default_instance_->phone_;
  //return phone_ != NULL ? *phone_: *default_instance_->phone_;
}
	
//********************************************************************************************
//!                             Class ComplexNumber
//********************************************************************************************
ComplexNumber::ComplexNumber (){ 
}

ComplexNumber::~ComplexNumber(){
}


 tint32_t ComplexNumber::a() const{
	return a_;
}

 void ComplexNumber::set_a(tint32_t value){
	a_ = value;
}

	

 tint32_t ComplexNumber::b() const{
	return b_;
}

 void ComplexNumber::set_b(tint32_t value){
	b_ = value;
}

	
//********************************************************************************************
//!                             Class Phone
//********************************************************************************************
BasicCalculator::Phone::Phone (){ 
	home_ = NULL;
	mobile_ = NULL;
}

BasicCalculator::Phone::~Phone(){
	delete home_;
	delete mobile_;
}

 const std::string& BasicCalculator::Phone::home() const{
	return *home_;
}

 void BasicCalculator::Phone::set_home(const std::string& value){
	if (home_ == 0 ){
    	home_ = new std::string;
  	}
  	home_->assign(value);
}

 void BasicCalculator::Phone::set_home(const char* value){
	if (home_ == 0){
		home_ = new std::string;
  	}
  	home_->assign(value);
}

 void BasicCalculator::Phone::set_home(const char* value, size_t size){
	if (home_ == 0){
    	home_ = new std::string;
  	}
  	home_->assign(reinterpret_cast<const char*>(value), size);
}


	
 const std::string& BasicCalculator::Phone::mobile() const{
	return *mobile_;
}

 void BasicCalculator::Phone::set_mobile(const std::string& value){
	if (mobile_ == 0 ){
    	mobile_ = new std::string;
  	}
  	mobile_->assign(value);
}

 void BasicCalculator::Phone::set_mobile(const char* value){
	if (mobile_ == 0){
		mobile_ = new std::string;
  	}
  	mobile_->assign(value);
}

 void BasicCalculator::Phone::set_mobile(const char* value, size_t size){
	if (mobile_ == 0){
    	mobile_ = new std::string;
  	}
  	mobile_->assign(reinterpret_cast<const char*>(value), size);
}


	
//********************************************************************************************
//!                             Class Person
//********************************************************************************************
BasicCalculator::Person::Person (){ 
	addres_ = NULL;
	name_ = NULL;
	surname_ = NULL;
	mother_ = NULL;
}

BasicCalculator::Person::~Person(){
	delete addres_;
	delete name_;
	delete surname_;
	delete mother_;
}
BasicCalculator::Person* BasicCalculator::Person::default_instance_ = NULL;

const BasicCalculator::Person& BasicCalculator::Person::default_instance() {
  if (default_instance_ == NULL) {
   default_instance_ = new BasicCalculator::Person();
  }
  return *default_instance_;
}





 bool BasicCalculator::Person::has_addres() const{
	if (addres_ == NULL ) {
    	return false;
  	}
  	return true;
}

 BasicCalculator::Address* BasicCalculator::Person::mutable_addres(){
	if (addres_==NULL)
		addres_ = new BasicCalculator::Address;
	return addres_;
}

 BasicCalculator::Address& BasicCalculator::Person::addres() const{
 	if (addres_ != NULL)
		return *addres_;

	if ( default_instance_ == NULL)
		default_instance();
	return *default_instance_->addres_;
  //return addres_ != NULL ? *addres_: *default_instance_->addres_;
}
	
 const std::string& BasicCalculator::Person::name() const{
	return *name_;
}

 void BasicCalculator::Person::set_name(const std::string& value){
	if (name_ == 0 ){
    	name_ = new std::string;
  	}
  	name_->assign(value);
}

 void BasicCalculator::Person::set_name(const char* value){
	if (name_ == 0){
		name_ = new std::string;
  	}
  	name_->assign(value);
}

 void BasicCalculator::Person::set_name(const char* value, size_t size){
	if (name_ == 0){
    	name_ = new std::string;
  	}
  	name_->assign(reinterpret_cast<const char*>(value), size);
}


	
 const std::string& BasicCalculator::Person::surname() const{
	return *surname_;
}

 void BasicCalculator::Person::set_surname(const std::string& value){
	if (surname_ == 0 ){
    	surname_ = new std::string;
  	}
  	surname_->assign(value);
}

 void BasicCalculator::Person::set_surname(const char* value){
	if (surname_ == 0){
		surname_ = new std::string;
  	}
  	surname_->assign(value);
}

 void BasicCalculator::Person::set_surname(const char* value, size_t size){
	if (surname_ == 0){
    	surname_ = new std::string;
  	}
  	surname_->assign(reinterpret_cast<const char*>(value), size);
}


	


 bool BasicCalculator::Person::has_mother() const{
	if (mother_ == NULL ) {
    	return false;
  	}
  	return true;
}

 BasicCalculator::Person* BasicCalculator::Person::mutable_mother(){
	if (mother_==NULL)
		mother_ = new BasicCalculator::Person;
	return mother_;
}

 BasicCalculator::Person& BasicCalculator::Person::mother() const{
 	if (mother_ != NULL)
		return *mother_;

	if ( default_instance_ == NULL)
		default_instance();
	return *default_instance_->mother_;
  //return mother_ != NULL ? *mother_: *default_instance_->mother_;
}
	
//********************************************************************************************
//!                             Class TupleComplexNumber
//********************************************************************************************
BasicCalculator::TupleComplexNumber::TupleComplexNumber (){ 
	a_ = NULL;
	b_ = NULL;
}

BasicCalculator::TupleComplexNumber::~TupleComplexNumber(){
	delete a_;
	delete b_;
}
BasicCalculator::TupleComplexNumber* BasicCalculator::TupleComplexNumber::default_instance_ = NULL;

const BasicCalculator::TupleComplexNumber& BasicCalculator::TupleComplexNumber::default_instance() {
  if (default_instance_ == NULL) {
   default_instance_ = new BasicCalculator::TupleComplexNumber();
  }
  return *default_instance_;
}





 bool BasicCalculator::TupleComplexNumber::has_a() const{
	if (a_ == NULL ) {
    	return false;
  	}
  	return true;
}

 ComplexNumber* BasicCalculator::TupleComplexNumber::mutable_a(){
	if (a_==NULL)
		a_ = new ComplexNumber;
	return a_;
}

 ComplexNumber& BasicCalculator::TupleComplexNumber::a() const{
 	if (a_ != NULL)
		return *a_;

	if ( default_instance_ == NULL)
		default_instance();
	return *default_instance_->a_;
  //return a_ != NULL ? *a_: *default_instance_->a_;
}
	


 bool BasicCalculator::TupleComplexNumber::has_b() const{
	if (b_ == NULL ) {
    	return false;
  	}
  	return true;
}

 ComplexNumber* BasicCalculator::TupleComplexNumber::mutable_b(){
	if (b_==NULL)
		b_ = new ComplexNumber;
	return b_;
}

 ComplexNumber& BasicCalculator::TupleComplexNumber::b() const{
 	if (b_ != NULL)
		return *b_;

	if ( default_instance_ == NULL)
		default_instance();
	return *default_instance_->b_;
  //return b_ != NULL ? *b_: *default_instance_->b_;
}
	
//********************************************************************************************
//!                             Class ValidationException
//********************************************************************************************
BasicCalculator::ValidationException::ValidationException (){ 
	details_ = NULL;
}

BasicCalculator::ValidationException::~ValidationException(){
	delete details_;
}

 const std::string& BasicCalculator::ValidationException::details() const{
	return *details_;
}

 void BasicCalculator::ValidationException::set_details(const std::string& value){
	if (details_ == 0 ){
    	details_ = new std::string;
  	}
  	details_->assign(value);
}

 void BasicCalculator::ValidationException::set_details(const char* value){
	if (details_ == 0){
		details_ = new std::string;
  	}
  	details_->assign(value);
}

 void BasicCalculator::ValidationException::set_details(const char* value, size_t size){
	if (details_ == 0){
    	details_ = new std::string;
  	}
  	details_->assign(reinterpret_cast<const char*>(value), size);
}


	
