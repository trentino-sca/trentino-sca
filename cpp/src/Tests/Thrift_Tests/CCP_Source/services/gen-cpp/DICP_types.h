/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef DICP_TYPES_H
#define DICP_TYPES_H

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>



namespace dicp {

struct IfAddrMode {
  enum type {
    DHCP = 0,
    STATIC = 1,
    IFAM_AnyOrDummyValue = 65535
  };
};

extern const std::map<int, const char*> _IfAddrMode_VALUES_TO_NAMES;

struct PasswordType {
  enum type {
    PW_MD5 = 0,
    PW_PLAIN = 1
  };
};

extern const std::map<int, const char*> _PasswordType_VALUES_TO_NAMES;

struct IdentificationReason {
  enum type {
    SEARCH_RESPONSE = 0,
    PIN_PRESSED = 1,
    CONFIG_CHANGE = 2,
    PASSWORD_SET = 3,
    PASSWORD_SET_FAILED = 4,
    AUTHENTICATION_FAILED = 5,
    CONFIGURING = 6,
    UNCONFIGURING = 7,
    RESTARTING = 8,
    TIME_SET = 9,
    WINK_RESPONSE = 10,
    IDRE_AnyOrDummyValue = 65535
  };
};

extern const std::map<int, const char*> _IdentificationReason_VALUES_TO_NAMES;

typedef int64_t timestamp;

typedef struct _DevIdent__isset {
  _DevIdent__isset() : serNr(false), modelNam(false) {}
  bool serNr;
  bool modelNam;
} _DevIdent__isset;

class DevIdent {
 public:

  static const char* ascii_fingerprint; // = "07A9615F837F7D0A952B595DD3020972";
  static const uint8_t binary_fingerprint[16]; // = {0x07,0xA9,0x61,0x5F,0x83,0x7F,0x7D,0x0A,0x95,0x2B,0x59,0x5D,0xD3,0x02,0x09,0x72};

  DevIdent() : serNr(), modelNam() {
  }

  virtual ~DevIdent() throw() {}

  std::string serNr;
  std::string modelNam;

  _DevIdent__isset __isset;

  void __set_serNr(const std::string& val) {
    serNr = val;
  }

  void __set_modelNam(const std::string& val) {
    modelNam = val;
  }

  bool operator == (const DevIdent & rhs) const
  {
    if (!(serNr == rhs.serNr))
      return false;
    if (!(modelNam == rhs.modelNam))
      return false;
    return true;
  }
  bool operator != (const DevIdent &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DevIdent & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(DevIdent &a, DevIdent &b);

typedef struct _BaDevData__isset {
  _BaDevData__isset() : deviceInst(false), deviceName(false), deviceStatus(false), deviceVersion(false), deviceAddr(false) {}
  bool deviceInst;
  bool deviceName;
  bool deviceStatus;
  bool deviceVersion;
  bool deviceAddr;
} _BaDevData__isset;

class BaDevData {
 public:

  static const char* ascii_fingerprint; // = "79868449BC2824A90EDE820408B8453E";
  static const uint8_t binary_fingerprint[16]; // = {0x79,0x86,0x84,0x49,0xBC,0x28,0x24,0xA9,0x0E,0xDE,0x82,0x04,0x08,0xB8,0x45,0x3E};

  BaDevData() : deviceInst(0), deviceName(), deviceStatus(0), deviceVersion(), deviceAddr() {
  }

  virtual ~BaDevData() throw() {}

  int32_t deviceInst;
  std::string deviceName;
  int32_t deviceStatus;
  std::string deviceVersion;
  std::string deviceAddr;

  _BaDevData__isset __isset;

  void __set_deviceInst(const int32_t val) {
    deviceInst = val;
  }

  void __set_deviceName(const std::string& val) {
    deviceName = val;
  }

  void __set_deviceStatus(const int32_t val) {
    deviceStatus = val;
  }

  void __set_deviceVersion(const std::string& val) {
    deviceVersion = val;
  }

  void __set_deviceAddr(const std::string& val) {
    deviceAddr = val;
  }

  bool operator == (const BaDevData & rhs) const
  {
    if (!(deviceInst == rhs.deviceInst))
      return false;
    if (!(deviceName == rhs.deviceName))
      return false;
    if (!(deviceStatus == rhs.deviceStatus))
      return false;
    if (!(deviceVersion == rhs.deviceVersion))
      return false;
    if (!(deviceAddr == rhs.deviceAddr))
      return false;
    return true;
  }
  bool operator != (const BaDevData &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BaDevData & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(BaDevData &a, BaDevData &b);

typedef struct _URIData__isset {
  _URIData__isset() : uriBase(false), uriPath(false) {}
  bool uriBase;
  bool uriPath;
} _URIData__isset;

class URIData {
 public:

  static const char* ascii_fingerprint; // = "5B708A954C550ECA9C1A49D3C5CAFAB9";
  static const uint8_t binary_fingerprint[16]; // = {0x5B,0x70,0x8A,0x95,0x4C,0x55,0x0E,0xCA,0x9C,0x1A,0x49,0xD3,0xC5,0xCA,0xFA,0xB9};

  URIData() : uriBase(), uriPath() {
  }

  virtual ~URIData() throw() {}

  std::string uriBase;
  std::string uriPath;

  _URIData__isset __isset;

  void __set_uriBase(const std::string& val) {
    uriBase = val;
  }

  void __set_uriPath(const std::string& val) {
    uriPath = val;
    __isset.uriPath = true;
  }

  bool operator == (const URIData & rhs) const
  {
    if (!(uriBase == rhs.uriBase))
      return false;
    if (__isset.uriPath != rhs.__isset.uriPath)
      return false;
    else if (__isset.uriPath && !(uriPath == rhs.uriPath))
      return false;
    return true;
  }
  bool operator != (const URIData &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const URIData & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(URIData &a, URIData &b);

typedef struct _DevInfo__isset {
  _DevInfo__isset() : deviceDescr(false), location(false) {}
  bool deviceDescr;
  bool location;
} _DevInfo__isset;

class DevInfo {
 public:

  static const char* ascii_fingerprint; // = "D0297FC5011701BD87898CC36146A565";
  static const uint8_t binary_fingerprint[16]; // = {0xD0,0x29,0x7F,0xC5,0x01,0x17,0x01,0xBD,0x87,0x89,0x8C,0xC3,0x61,0x46,0xA5,0x65};

  DevInfo() : deviceDescr(), location() {
  }

  virtual ~DevInfo() throw() {}

  std::string deviceDescr;
  std::string location;

  _DevInfo__isset __isset;

  void __set_deviceDescr(const std::string& val) {
    deviceDescr = val;
    __isset.deviceDescr = true;
  }

  void __set_location(const std::string& val) {
    location = val;
    __isset.location = true;
  }

  bool operator == (const DevInfo & rhs) const
  {
    if (__isset.deviceDescr != rhs.__isset.deviceDescr)
      return false;
    else if (__isset.deviceDescr && !(deviceDescr == rhs.deviceDescr))
      return false;
    if (__isset.location != rhs.__isset.location)
      return false;
    else if (__isset.location && !(location == rhs.location))
      return false;
    return true;
  }
  bool operator != (const DevInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DevInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(DevInfo &a, DevInfo &b);

typedef struct _BaDev__isset {
  _BaDev__isset() : pidref(false), deviceInst(false), deviceName(false) {}
  bool pidref;
  bool deviceInst;
  bool deviceName;
} _BaDev__isset;

class BaDev {
 public:

  static const char* ascii_fingerprint; // = "70563A0628F75DF9555F4D24690B1E26";
  static const uint8_t binary_fingerprint[16]; // = {0x70,0x56,0x3A,0x06,0x28,0xF7,0x5D,0xF9,0x55,0x5F,0x4D,0x24,0x69,0x0B,0x1E,0x26};

  BaDev() : pidref(), deviceInst(0), deviceName() {
  }

  virtual ~BaDev() throw() {}

  std::string pidref;
  int32_t deviceInst;
  std::string deviceName;

  _BaDev__isset __isset;

  void __set_pidref(const std::string& val) {
    pidref = val;
  }

  void __set_deviceInst(const int32_t val) {
    deviceInst = val;
  }

  void __set_deviceName(const std::string& val) {
    deviceName = val;
  }

  bool operator == (const BaDev & rhs) const
  {
    if (!(pidref == rhs.pidref))
      return false;
    if (!(deviceInst == rhs.deviceInst))
      return false;
    if (!(deviceName == rhs.deviceName))
      return false;
    return true;
  }
  bool operator != (const BaDev &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BaDev & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(BaDev &a, BaDev &b);

typedef struct _BaPar__isset {
  _BaPar__isset() : maxAPDU(false), aPDUTout(false), retries(false), segSupp(false), segTout(false), maxWind(false), maxSegAcc(false) {}
  bool maxAPDU;
  bool aPDUTout;
  bool retries;
  bool segSupp;
  bool segTout;
  bool maxWind;
  bool maxSegAcc;
} _BaPar__isset;

class BaPar {
 public:

  static const char* ascii_fingerprint; // = "346A7F6D77695CA92963E099D40206BB";
  static const uint8_t binary_fingerprint[16]; // = {0x34,0x6A,0x7F,0x6D,0x77,0x69,0x5C,0xA9,0x29,0x63,0xE0,0x99,0xD4,0x02,0x06,0xBB};

  BaPar() : maxAPDU(0), aPDUTout(0), retries(0), segSupp(0), segTout(0), maxWind(0), maxSegAcc(0) {
  }

  virtual ~BaPar() throw() {}

  int32_t maxAPDU;
  int32_t aPDUTout;
  int32_t retries;
  int32_t segSupp;
  int32_t segTout;
  int32_t maxWind;
  int32_t maxSegAcc;

  _BaPar__isset __isset;

  void __set_maxAPDU(const int32_t val) {
    maxAPDU = val;
  }

  void __set_aPDUTout(const int32_t val) {
    aPDUTout = val;
  }

  void __set_retries(const int32_t val) {
    retries = val;
  }

  void __set_segSupp(const int32_t val) {
    segSupp = val;
  }

  void __set_segTout(const int32_t val) {
    segTout = val;
    __isset.segTout = true;
  }

  void __set_maxWind(const int32_t val) {
    maxWind = val;
    __isset.maxWind = true;
  }

  void __set_maxSegAcc(const int32_t val) {
    maxSegAcc = val;
    __isset.maxSegAcc = true;
  }

  bool operator == (const BaPar & rhs) const
  {
    if (!(maxAPDU == rhs.maxAPDU))
      return false;
    if (!(aPDUTout == rhs.aPDUTout))
      return false;
    if (!(retries == rhs.retries))
      return false;
    if (!(segSupp == rhs.segSupp))
      return false;
    if (__isset.segTout != rhs.__isset.segTout)
      return false;
    else if (__isset.segTout && !(segTout == rhs.segTout))
      return false;
    if (__isset.maxWind != rhs.__isset.maxWind)
      return false;
    else if (__isset.maxWind && !(maxWind == rhs.maxWind))
      return false;
    if (__isset.maxSegAcc != rhs.__isset.maxSegAcc)
      return false;
    else if (__isset.maxSegAcc && !(maxSegAcc == rhs.maxSegAcc))
      return false;
    return true;
  }
  bool operator != (const BaPar &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BaPar & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(BaPar &a, BaPar &b);

typedef struct _BaNw__isset {
  _BaNw__isset() : nwKind(false), maxPorts(false) {}
  bool nwKind;
  bool maxPorts;
} _BaNw__isset;

class BaNw {
 public:

  static const char* ascii_fingerprint; // = "4C26CA8CF7DEAA144AEF359471B9AEA6";
  static const uint8_t binary_fingerprint[16]; // = {0x4C,0x26,0xCA,0x8C,0xF7,0xDE,0xAA,0x14,0x4A,0xEF,0x35,0x94,0x71,0xB9,0xAE,0xA6};

  BaNw() : nwKind(0), maxPorts(0) {
  }

  virtual ~BaNw() throw() {}

  int32_t nwKind;
  int32_t maxPorts;

  _BaNw__isset __isset;

  void __set_nwKind(const int32_t val) {
    nwKind = val;
    __isset.nwKind = true;
  }

  void __set_maxPorts(const int32_t val) {
    maxPorts = val;
  }

  bool operator == (const BaNw & rhs) const
  {
    if (__isset.nwKind != rhs.__isset.nwKind)
      return false;
    else if (__isset.nwKind && !(nwKind == rhs.nwKind))
      return false;
    if (!(maxPorts == rhs.maxPorts))
      return false;
    return true;
  }
  bool operator != (const BaNw &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BaNw & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(BaNw &a, BaNw &b);

typedef struct _BDTEntry__isset {
  _BDTEntry__isset() : ipAddr(false), udpPort(false), bdmask(false) {}
  bool ipAddr;
  bool udpPort;
  bool bdmask;
} _BDTEntry__isset;

class BDTEntry {
 public:

  static const char* ascii_fingerprint; // = "614DB859ACF17855F9BC7D08DDD7B32A";
  static const uint8_t binary_fingerprint[16]; // = {0x61,0x4D,0xB8,0x59,0xAC,0xF1,0x78,0x55,0xF9,0xBC,0x7D,0x08,0xDD,0xD7,0xB3,0x2A};

  BDTEntry() : ipAddr(), udpPort(0), bdmask() {
  }

  virtual ~BDTEntry() throw() {}

  std::string ipAddr;
  int32_t udpPort;
  std::string bdmask;

  _BDTEntry__isset __isset;

  void __set_ipAddr(const std::string& val) {
    ipAddr = val;
  }

  void __set_udpPort(const int32_t val) {
    udpPort = val;
  }

  void __set_bdmask(const std::string& val) {
    bdmask = val;
    __isset.bdmask = true;
  }

  bool operator == (const BDTEntry & rhs) const
  {
    if (!(ipAddr == rhs.ipAddr))
      return false;
    if (!(udpPort == rhs.udpPort))
      return false;
    if (__isset.bdmask != rhs.__isset.bdmask)
      return false;
    else if (__isset.bdmask && !(bdmask == rhs.bdmask))
      return false;
    return true;
  }
  bool operator != (const BDTEntry &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BDTEntry & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(BDTEntry &a, BDTEntry &b);

typedef struct _FDTEntry__isset {
  _FDTEntry__isset() : ipAddr(false), udpPort(false), ttl(false) {}
  bool ipAddr;
  bool udpPort;
  bool ttl;
} _FDTEntry__isset;

class FDTEntry {
 public:

  static const char* ascii_fingerprint; // = "28C2ECC89260BADB9C70330FBF47BFA8";
  static const uint8_t binary_fingerprint[16]; // = {0x28,0xC2,0xEC,0xC8,0x92,0x60,0xBA,0xDB,0x9C,0x70,0x33,0x0F,0xBF,0x47,0xBF,0xA8};

  FDTEntry() : ipAddr(), udpPort(0), ttl(0) {
  }

  virtual ~FDTEntry() throw() {}

  std::string ipAddr;
  int32_t udpPort;
  int32_t ttl;

  _FDTEntry__isset __isset;

  void __set_ipAddr(const std::string& val) {
    ipAddr = val;
  }

  void __set_udpPort(const int32_t val) {
    udpPort = val;
  }

  void __set_ttl(const int32_t val) {
    ttl = val;
  }

  bool operator == (const FDTEntry & rhs) const
  {
    if (!(ipAddr == rhs.ipAddr))
      return false;
    if (!(udpPort == rhs.udpPort))
      return false;
    if (!(ttl == rhs.ttl))
      return false;
    return true;
  }
  bool operator != (const FDTEntry &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const FDTEntry & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(FDTEntry &a, FDTEntry &b);

typedef struct _BDT__isset {
  _BDT__isset() : maxEntries(false), entry(false), natPubIP(false) {}
  bool maxEntries;
  bool entry;
  bool natPubIP;
} _BDT__isset;

class BDT {
 public:

  static const char* ascii_fingerprint; // = "9F2B54432A3C837E9DEB0E7C4F2255AD";
  static const uint8_t binary_fingerprint[16]; // = {0x9F,0x2B,0x54,0x43,0x2A,0x3C,0x83,0x7E,0x9D,0xEB,0x0E,0x7C,0x4F,0x22,0x55,0xAD};

  BDT() : maxEntries(0), natPubIP() {
  }

  virtual ~BDT() throw() {}

  int32_t maxEntries;
  std::vector<BDTEntry>  entry;
  std::string natPubIP;

  _BDT__isset __isset;

  void __set_maxEntries(const int32_t val) {
    maxEntries = val;
  }

  void __set_entry(const std::vector<BDTEntry> & val) {
    entry = val;
    __isset.entry = true;
  }

  void __set_natPubIP(const std::string& val) {
    natPubIP = val;
    __isset.natPubIP = true;
  }

  bool operator == (const BDT & rhs) const
  {
    if (!(maxEntries == rhs.maxEntries))
      return false;
    if (__isset.entry != rhs.__isset.entry)
      return false;
    else if (__isset.entry && !(entry == rhs.entry))
      return false;
    if (__isset.natPubIP != rhs.__isset.natPubIP)
      return false;
    else if (__isset.natPubIP && !(natPubIP == rhs.natPubIP))
      return false;
    return true;
  }
  bool operator != (const BDT &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BDT & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(BDT &a, BDT &b);

typedef struct _FDT__isset {
  _FDT__isset() : maxEntries(false), entry(false) {}
  bool maxEntries;
  bool entry;
} _FDT__isset;

class FDT {
 public:

  static const char* ascii_fingerprint; // = "06A5B0433A1EB98667E34D4E311717F9";
  static const uint8_t binary_fingerprint[16]; // = {0x06,0xA5,0xB0,0x43,0x3A,0x1E,0xB9,0x86,0x67,0xE3,0x4D,0x4E,0x31,0x17,0x17,0xF9};

  FDT() : maxEntries(0) {
  }

  virtual ~FDT() throw() {}

  int32_t maxEntries;
  std::vector<FDTEntry>  entry;

  _FDT__isset __isset;

  void __set_maxEntries(const int32_t val) {
    maxEntries = val;
  }

  void __set_entry(const std::vector<FDTEntry> & val) {
    entry = val;
    __isset.entry = true;
  }

  bool operator == (const FDT & rhs) const
  {
    if (!(maxEntries == rhs.maxEntries))
      return false;
    if (__isset.entry != rhs.__isset.entry)
      return false;
    else if (__isset.entry && !(entry == rhs.entry))
      return false;
    return true;
  }
  bool operator != (const FDT &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const FDT & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(FDT &a, FDT &b);

typedef struct _IPport__isset {
  _IPport__isset() : pid(false), nwRef(false), nwNb(false), udpPort(false), bdt(false), fdt(false), fd(false) {}
  bool pid;
  bool nwRef;
  bool nwNb;
  bool udpPort;
  bool bdt;
  bool fdt;
  bool fd;
} _IPport__isset;

class IPport {
 public:

  static const char* ascii_fingerprint; // = "98760954BB314A5352394FAC6C2E7711";
  static const uint8_t binary_fingerprint[16]; // = {0x98,0x76,0x09,0x54,0xBB,0x31,0x4A,0x53,0x52,0x39,0x4F,0xAC,0x6C,0x2E,0x77,0x11};

  IPport() : pid(), nwRef(), nwNb(0), udpPort(0) {
  }

  virtual ~IPport() throw() {}

  std::string pid;
  std::string nwRef;
  int32_t nwNb;
  int32_t udpPort;
  BDT bdt;
  FDT fdt;
  FDTEntry fd;

  _IPport__isset __isset;

  void __set_pid(const std::string& val) {
    pid = val;
  }

  void __set_nwRef(const std::string& val) {
    nwRef = val;
  }

  void __set_nwNb(const int32_t val) {
    nwNb = val;
  }

  void __set_udpPort(const int32_t val) {
    udpPort = val;
  }

  void __set_bdt(const BDT& val) {
    bdt = val;
    __isset.bdt = true;
  }

  void __set_fdt(const FDT& val) {
    fdt = val;
    __isset.fdt = true;
  }

  void __set_fd(const FDTEntry& val) {
    fd = val;
    __isset.fd = true;
  }

  bool operator == (const IPport & rhs) const
  {
    if (!(pid == rhs.pid))
      return false;
    if (!(nwRef == rhs.nwRef))
      return false;
    if (!(nwNb == rhs.nwNb))
      return false;
    if (!(udpPort == rhs.udpPort))
      return false;
    if (__isset.bdt != rhs.__isset.bdt)
      return false;
    else if (__isset.bdt && !(bdt == rhs.bdt))
      return false;
    if (__isset.fdt != rhs.__isset.fdt)
      return false;
    else if (__isset.fdt && !(fdt == rhs.fdt))
      return false;
    if (__isset.fd != rhs.__isset.fd)
      return false;
    else if (__isset.fd && !(fd == rhs.fd))
      return false;
    return true;
  }
  bool operator != (const IPport &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const IPport & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(IPport &a, IPport &b);

typedef struct _MSTPport__isset {
  _MSTPport__isset() : pid(false), nwRef(false), nwNb(false), addr(false), maxInfo(false), maxMaster(false), slvP(false) {}
  bool pid;
  bool nwRef;
  bool nwNb;
  bool addr;
  bool maxInfo;
  bool maxMaster;
  bool slvP;
} _MSTPport__isset;

class MSTPport {
 public:

  static const char* ascii_fingerprint; // = "4ED39C857B9DD695D18E48009F4AF499";
  static const uint8_t binary_fingerprint[16]; // = {0x4E,0xD3,0x9C,0x85,0x7B,0x9D,0xD6,0x95,0xD1,0x8E,0x48,0x00,0x9F,0x4A,0xF4,0x99};

  MSTPport() : pid(), nwRef(), nwNb(0), addr(0), maxInfo(0), maxMaster(0), slvP(0) {
  }

  virtual ~MSTPport() throw() {}

  std::string pid;
  std::string nwRef;
  int32_t nwNb;
  int32_t addr;
  int32_t maxInfo;
  int32_t maxMaster;
  int32_t slvP;

  _MSTPport__isset __isset;

  void __set_pid(const std::string& val) {
    pid = val;
  }

  void __set_nwRef(const std::string& val) {
    nwRef = val;
  }

  void __set_nwNb(const int32_t val) {
    nwNb = val;
  }

  void __set_addr(const int32_t val) {
    addr = val;
  }

  void __set_maxInfo(const int32_t val) {
    maxInfo = val;
    __isset.maxInfo = true;
  }

  void __set_maxMaster(const int32_t val) {
    maxMaster = val;
    __isset.maxMaster = true;
  }

  void __set_slvP(const int32_t val) {
    slvP = val;
    __isset.slvP = true;
  }

  bool operator == (const MSTPport & rhs) const
  {
    if (!(pid == rhs.pid))
      return false;
    if (!(nwRef == rhs.nwRef))
      return false;
    if (!(nwNb == rhs.nwNb))
      return false;
    if (!(addr == rhs.addr))
      return false;
    if (__isset.maxInfo != rhs.__isset.maxInfo)
      return false;
    else if (__isset.maxInfo && !(maxInfo == rhs.maxInfo))
      return false;
    if (__isset.maxMaster != rhs.__isset.maxMaster)
      return false;
    else if (__isset.maxMaster && !(maxMaster == rhs.maxMaster))
      return false;
    if (__isset.slvP != rhs.__isset.slvP)
      return false;
    else if (__isset.slvP && !(slvP == rhs.slvP))
      return false;
    return true;
  }
  bool operator != (const MSTPport &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MSTPport & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(MSTPport &a, MSTPport &b);

typedef struct _LONport__isset {
  _LONport__isset() : pid(false), nwRef(false), nwNb(false), domain(false), channel(false), subnet(false), node(false) {}
  bool pid;
  bool nwRef;
  bool nwNb;
  bool domain;
  bool channel;
  bool subnet;
  bool node;
} _LONport__isset;

class LONport {
 public:

  static const char* ascii_fingerprint; // = "E6FC066BE76647B97F15E30B9E15D953";
  static const uint8_t binary_fingerprint[16]; // = {0xE6,0xFC,0x06,0x6B,0xE7,0x66,0x47,0xB9,0x7F,0x15,0xE3,0x0B,0x9E,0x15,0xD9,0x53};

  LONport() : pid(), nwRef(), nwNb(0), domain(0), channel(0), subnet(0), node(0) {
  }

  virtual ~LONport() throw() {}

  std::string pid;
  std::string nwRef;
  int32_t nwNb;
  int32_t domain;
  int32_t channel;
  int32_t subnet;
  int32_t node;

  _LONport__isset __isset;

  void __set_pid(const std::string& val) {
    pid = val;
  }

  void __set_nwRef(const std::string& val) {
    nwRef = val;
  }

  void __set_nwNb(const int32_t val) {
    nwNb = val;
  }

  void __set_domain(const int32_t val) {
    domain = val;
  }

  void __set_channel(const int32_t val) {
    channel = val;
  }

  void __set_subnet(const int32_t val) {
    subnet = val;
  }

  void __set_node(const int32_t val) {
    node = val;
  }

  bool operator == (const LONport & rhs) const
  {
    if (!(pid == rhs.pid))
      return false;
    if (!(nwRef == rhs.nwRef))
      return false;
    if (!(nwNb == rhs.nwNb))
      return false;
    if (!(domain == rhs.domain))
      return false;
    if (!(channel == rhs.channel))
      return false;
    if (!(subnet == rhs.subnet))
      return false;
    if (!(node == rhs.node))
      return false;
    return true;
  }
  bool operator != (const LONport &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LONport & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(LONport &a, LONport &b);

typedef struct _BaPort__isset {
  _BaPort__isset() : ip(false), mstp(false), lon(false) {}
  bool ip;
  bool mstp;
  bool lon;
} _BaPort__isset;

class BaPort {
 public:

  static const char* ascii_fingerprint; // = "446FDDEB2E2BE72282BCBD264F199244";
  static const uint8_t binary_fingerprint[16]; // = {0x44,0x6F,0xDD,0xEB,0x2E,0x2B,0xE7,0x22,0x82,0xBC,0xBD,0x26,0x4F,0x19,0x92,0x44};

  BaPort() {
  }

  virtual ~BaPort() throw() {}

  IPport ip;
  MSTPport mstp;
  LONport lon;

  _BaPort__isset __isset;

  void __set_ip(const IPport& val) {
    ip = val;
    __isset.ip = true;
  }

  void __set_mstp(const MSTPport& val) {
    mstp = val;
    __isset.mstp = true;
  }

  void __set_lon(const LONport& val) {
    lon = val;
    __isset.lon = true;
  }

  bool operator == (const BaPort & rhs) const
  {
    if (__isset.ip != rhs.__isset.ip)
      return false;
    else if (__isset.ip && !(ip == rhs.ip))
      return false;
    if (__isset.mstp != rhs.__isset.mstp)
      return false;
    else if (__isset.mstp && !(mstp == rhs.mstp))
      return false;
    if (__isset.lon != rhs.__isset.lon)
      return false;
    else if (__isset.lon && !(lon == rhs.lon))
      return false;
    return true;
  }
  bool operator != (const BaPort &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BaPort & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(BaPort &a, BaPort &b);

typedef struct _Lan__isset {
  _Lan__isset() : nwID(false), ifMode(false), ipAddr(false), netmask(false), gtWay(false), type(false), macAddr(false) {}
  bool nwID;
  bool ifMode;
  bool ipAddr;
  bool netmask;
  bool gtWay;
  bool type;
  bool macAddr;
} _Lan__isset;

class Lan {
 public:

  static const char* ascii_fingerprint; // = "60FCBF422C85117D3131505EDC1C08B8";
  static const uint8_t binary_fingerprint[16]; // = {0x60,0xFC,0xBF,0x42,0x2C,0x85,0x11,0x7D,0x31,0x31,0x50,0x5E,0xDC,0x1C,0x08,0xB8};

  Lan() : nwID(), ifMode(0), ipAddr(), netmask(), gtWay(), type(), macAddr() {
  }

  virtual ~Lan() throw() {}

  std::string nwID;
  int32_t ifMode;
  std::string ipAddr;
  std::string netmask;
  std::string gtWay;
  std::string type;
  std::string macAddr;

  _Lan__isset __isset;

  void __set_nwID(const std::string& val) {
    nwID = val;
  }

  void __set_ifMode(const int32_t val) {
    ifMode = val;
  }

  void __set_ipAddr(const std::string& val) {
    ipAddr = val;
  }

  void __set_netmask(const std::string& val) {
    netmask = val;
    __isset.netmask = true;
  }

  void __set_gtWay(const std::string& val) {
    gtWay = val;
    __isset.gtWay = true;
  }

  void __set_type(const std::string& val) {
    type = val;
    __isset.type = true;
  }

  void __set_macAddr(const std::string& val) {
    macAddr = val;
    __isset.macAddr = true;
  }

  bool operator == (const Lan & rhs) const
  {
    if (!(nwID == rhs.nwID))
      return false;
    if (!(ifMode == rhs.ifMode))
      return false;
    if (!(ipAddr == rhs.ipAddr))
      return false;
    if (__isset.netmask != rhs.__isset.netmask)
      return false;
    else if (__isset.netmask && !(netmask == rhs.netmask))
      return false;
    if (__isset.gtWay != rhs.__isset.gtWay)
      return false;
    else if (__isset.gtWay && !(gtWay == rhs.gtWay))
      return false;
    if (__isset.type != rhs.__isset.type)
      return false;
    else if (__isset.type && !(type == rhs.type))
      return false;
    if (__isset.macAddr != rhs.__isset.macAddr)
      return false;
    else if (__isset.macAddr && !(macAddr == rhs.macAddr))
      return false;
    return true;
  }
  bool operator != (const Lan &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Lan & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Lan &a, Lan &b);

typedef struct _Rs485__isset {
  _Rs485__isset() : nwID(false), baudRate(false), type(false) {}
  bool nwID;
  bool baudRate;
  bool type;
} _Rs485__isset;

class Rs485 {
 public:

  static const char* ascii_fingerprint; // = "614DB859ACF17855F9BC7D08DDD7B32A";
  static const uint8_t binary_fingerprint[16]; // = {0x61,0x4D,0xB8,0x59,0xAC,0xF1,0x78,0x55,0xF9,0xBC,0x7D,0x08,0xDD,0xD7,0xB3,0x2A};

  Rs485() : nwID(), baudRate(0), type() {
  }

  virtual ~Rs485() throw() {}

  std::string nwID;
  int32_t baudRate;
  std::string type;

  _Rs485__isset __isset;

  void __set_nwID(const std::string& val) {
    nwID = val;
  }

  void __set_baudRate(const int32_t val) {
    baudRate = val;
  }

  void __set_type(const std::string& val) {
    type = val;
    __isset.type = true;
  }

  bool operator == (const Rs485 & rhs) const
  {
    if (!(nwID == rhs.nwID))
      return false;
    if (!(baudRate == rhs.baudRate))
      return false;
    if (__isset.type != rhs.__isset.type)
      return false;
    else if (__isset.type && !(type == rhs.type))
      return false;
    return true;
  }
  bool operator != (const Rs485 &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Rs485 & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Rs485 &a, Rs485 &b);

typedef struct _Eia709__isset {
  _Eia709__isset() : nwID(false), type(false), neuronId(false) {}
  bool nwID;
  bool type;
  bool neuronId;
} _Eia709__isset;

class Eia709 {
 public:

  static const char* ascii_fingerprint; // = "4BF81DD46A7371532E49811022D58D36";
  static const uint8_t binary_fingerprint[16]; // = {0x4B,0xF8,0x1D,0xD4,0x6A,0x73,0x71,0x53,0x2E,0x49,0x81,0x10,0x22,0xD5,0x8D,0x36};

  Eia709() : nwID(), type(), neuronId() {
  }

  virtual ~Eia709() throw() {}

  std::string nwID;
  std::string type;
  std::string neuronId;

  _Eia709__isset __isset;

  void __set_nwID(const std::string& val) {
    nwID = val;
  }

  void __set_type(const std::string& val) {
    type = val;
    __isset.type = true;
  }

  void __set_neuronId(const std::string& val) {
    neuronId = val;
    __isset.neuronId = true;
  }

  bool operator == (const Eia709 & rhs) const
  {
    if (!(nwID == rhs.nwID))
      return false;
    if (__isset.type != rhs.__isset.type)
      return false;
    else if (__isset.type && !(type == rhs.type))
      return false;
    if (__isset.neuronId != rhs.__isset.neuronId)
      return false;
    else if (__isset.neuronId && !(neuronId == rhs.neuronId))
      return false;
    return true;
  }
  bool operator != (const Eia709 &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Eia709 & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Eia709 &a, Eia709 &b);

typedef struct _NwItf__isset {
  _NwItf__isset() : lanItf(false), rs485Itf(false), eiaItf(false) {}
  bool lanItf;
  bool rs485Itf;
  bool eiaItf;
} _NwItf__isset;

class NwItf {
 public:

  static const char* ascii_fingerprint; // = "880310AF397DF8B6FA3032F13AE3571E";
  static const uint8_t binary_fingerprint[16]; // = {0x88,0x03,0x10,0xAF,0x39,0x7D,0xF8,0xB6,0xFA,0x30,0x32,0xF1,0x3A,0xE3,0x57,0x1E};

  NwItf() {
  }

  virtual ~NwItf() throw() {}

  Lan lanItf;
  Rs485 rs485Itf;
  Eia709 eiaItf;

  _NwItf__isset __isset;

  void __set_lanItf(const Lan& val) {
    lanItf = val;
    __isset.lanItf = true;
  }

  void __set_rs485Itf(const Rs485& val) {
    rs485Itf = val;
    __isset.rs485Itf = true;
  }

  void __set_eiaItf(const Eia709& val) {
    eiaItf = val;
    __isset.eiaItf = true;
  }

  bool operator == (const NwItf & rhs) const
  {
    if (__isset.lanItf != rhs.__isset.lanItf)
      return false;
    else if (__isset.lanItf && !(lanItf == rhs.lanItf))
      return false;
    if (__isset.rs485Itf != rhs.__isset.rs485Itf)
      return false;
    else if (__isset.rs485Itf && !(rs485Itf == rhs.rs485Itf))
      return false;
    if (__isset.eiaItf != rhs.__isset.eiaItf)
      return false;
    else if (__isset.eiaItf && !(eiaItf == rhs.eiaItf))
      return false;
    return true;
  }
  bool operator != (const NwItf &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NwItf & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(NwItf &a, NwItf &b);

typedef struct _TimeSet__isset {
  _TimeSet__isset() : tz(false), uTCOffs(false) {}
  bool tz;
  bool uTCOffs;
} _TimeSet__isset;

class TimeSet {
 public:

  static const char* ascii_fingerprint; // = "18B162B1D15D8D46509D3911A9F1C2AA";
  static const uint8_t binary_fingerprint[16]; // = {0x18,0xB1,0x62,0xB1,0xD1,0x5D,0x8D,0x46,0x50,0x9D,0x39,0x11,0xA9,0xF1,0xC2,0xAA};

  TimeSet() : tz(), uTCOffs(0) {
  }

  virtual ~TimeSet() throw() {}

  std::string tz;
  int32_t uTCOffs;

  _TimeSet__isset __isset;

  void __set_tz(const std::string& val) {
    tz = val;
  }

  void __set_uTCOffs(const int32_t val) {
    uTCOffs = val;
    __isset.uTCOffs = true;
  }

  bool operator == (const TimeSet & rhs) const
  {
    if (!(tz == rhs.tz))
      return false;
    if (__isset.uTCOffs != rhs.__isset.uTCOffs)
      return false;
    else if (__isset.uTCOffs && !(uTCOffs == rhs.uTCOffs))
      return false;
    return true;
  }
  bool operator != (const TimeSet &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TimeSet & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TimeSet &a, TimeSet &b);

typedef struct _DiscoverServiceData__isset {
  _DiscoverServiceData__isset() : authToken(false), origin(false), scopeFilter(false) {}
  bool authToken;
  bool origin;
  bool scopeFilter;
} _DiscoverServiceData__isset;

class DiscoverServiceData {
 public:

  static const char* ascii_fingerprint; // = "AB879940BD15B6B25691265F7384B271";
  static const uint8_t binary_fingerprint[16]; // = {0xAB,0x87,0x99,0x40,0xBD,0x15,0xB6,0xB2,0x56,0x91,0x26,0x5F,0x73,0x84,0xB2,0x71};

  DiscoverServiceData() : authToken(), origin(), scopeFilter() {
  }

  virtual ~DiscoverServiceData() throw() {}

  std::string authToken;
  std::string origin;
  std::string scopeFilter;

  _DiscoverServiceData__isset __isset;

  void __set_authToken(const std::string& val) {
    authToken = val;
  }

  void __set_origin(const std::string& val) {
    origin = val;
  }

  void __set_scopeFilter(const std::string& val) {
    scopeFilter = val;
  }

  bool operator == (const DiscoverServiceData & rhs) const
  {
    if (!(authToken == rhs.authToken))
      return false;
    if (!(origin == rhs.origin))
      return false;
    if (!(scopeFilter == rhs.scopeFilter))
      return false;
    return true;
  }
  bool operator != (const DiscoverServiceData &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DiscoverServiceData & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(DiscoverServiceData &a, DiscoverServiceData &b);

typedef struct _WinkServiceData__isset {
  _WinkServiceData__isset() : authToken(false), origin(false), scopeFilter(false) {}
  bool authToken;
  bool origin;
  bool scopeFilter;
} _WinkServiceData__isset;

class WinkServiceData {
 public:

  static const char* ascii_fingerprint; // = "AB879940BD15B6B25691265F7384B271";
  static const uint8_t binary_fingerprint[16]; // = {0xAB,0x87,0x99,0x40,0xBD,0x15,0xB6,0xB2,0x56,0x91,0x26,0x5F,0x73,0x84,0xB2,0x71};

  WinkServiceData() : authToken(), origin(), scopeFilter() {
  }

  virtual ~WinkServiceData() throw() {}

  std::string authToken;
  std::string origin;
  std::string scopeFilter;

  _WinkServiceData__isset __isset;

  void __set_authToken(const std::string& val) {
    authToken = val;
  }

  void __set_origin(const std::string& val) {
    origin = val;
  }

  void __set_scopeFilter(const std::string& val) {
    scopeFilter = val;
  }

  bool operator == (const WinkServiceData & rhs) const
  {
    if (!(authToken == rhs.authToken))
      return false;
    if (!(origin == rhs.origin))
      return false;
    if (!(scopeFilter == rhs.scopeFilter))
      return false;
    return true;
  }
  bool operator != (const WinkServiceData &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WinkServiceData & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(WinkServiceData &a, WinkServiceData &b);

typedef struct _IdentificationServiceData__isset {
  _IdentificationServiceData__isset() : authToken(false), origin(false), reason(false), devIdent(false), baDev(false), devInfo(false), lanItf(false), rs485Itf(false), uridata(false), utctime(false) {}
  bool authToken;
  bool origin;
  bool reason;
  bool devIdent;
  bool baDev;
  bool devInfo;
  bool lanItf;
  bool rs485Itf;
  bool uridata;
  bool utctime;
} _IdentificationServiceData__isset;

class IdentificationServiceData {
 public:

  static const char* ascii_fingerprint; // = "1E4772ECE87829D5259083813D940D71";
  static const uint8_t binary_fingerprint[16]; // = {0x1E,0x47,0x72,0xEC,0xE8,0x78,0x29,0xD5,0x25,0x90,0x83,0x81,0x3D,0x94,0x0D,0x71};

  IdentificationServiceData() : authToken(), origin(), reason(0), utctime(0) {
  }

  virtual ~IdentificationServiceData() throw() {}

  std::string authToken;
  std::string origin;
  int32_t reason;
  DevIdent devIdent;
  BaDevData baDev;
  DevInfo devInfo;
  Lan lanItf;
  Rs485 rs485Itf;
  URIData uridata;
  timestamp utctime;

  _IdentificationServiceData__isset __isset;

  void __set_authToken(const std::string& val) {
    authToken = val;
  }

  void __set_origin(const std::string& val) {
    origin = val;
  }

  void __set_reason(const int32_t val) {
    reason = val;
  }

  void __set_devIdent(const DevIdent& val) {
    devIdent = val;
  }

  void __set_baDev(const BaDevData& val) {
    baDev = val;
  }

  void __set_devInfo(const DevInfo& val) {
    devInfo = val;
    __isset.devInfo = true;
  }

  void __set_lanItf(const Lan& val) {
    lanItf = val;
    __isset.lanItf = true;
  }

  void __set_rs485Itf(const Rs485& val) {
    rs485Itf = val;
    __isset.rs485Itf = true;
  }

  void __set_uridata(const URIData& val) {
    uridata = val;
    __isset.uridata = true;
  }

  void __set_utctime(const timestamp val) {
    utctime = val;
    __isset.utctime = true;
  }

  bool operator == (const IdentificationServiceData & rhs) const
  {
    if (!(authToken == rhs.authToken))
      return false;
    if (!(origin == rhs.origin))
      return false;
    if (!(reason == rhs.reason))
      return false;
    if (!(devIdent == rhs.devIdent))
      return false;
    if (!(baDev == rhs.baDev))
      return false;
    if (__isset.devInfo != rhs.__isset.devInfo)
      return false;
    else if (__isset.devInfo && !(devInfo == rhs.devInfo))
      return false;
    if (__isset.lanItf != rhs.__isset.lanItf)
      return false;
    else if (__isset.lanItf && !(lanItf == rhs.lanItf))
      return false;
    if (__isset.rs485Itf != rhs.__isset.rs485Itf)
      return false;
    else if (__isset.rs485Itf && !(rs485Itf == rhs.rs485Itf))
      return false;
    if (__isset.uridata != rhs.__isset.uridata)
      return false;
    else if (__isset.uridata && !(uridata == rhs.uridata))
      return false;
    if (__isset.utctime != rhs.__isset.utctime)
      return false;
    else if (__isset.utctime && !(utctime == rhs.utctime))
      return false;
    return true;
  }
  bool operator != (const IdentificationServiceData &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const IdentificationServiceData & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(IdentificationServiceData &a, IdentificationServiceData &b);

typedef struct _ConfigureServiceData__isset {
  _ConfigureServiceData__isset() : authToken(false), origin(false), devIdent(false), baDev(false), baPar(false), baNw(false), baPort(false), nwItf(false), timeSet(false) {}
  bool authToken;
  bool origin;
  bool devIdent;
  bool baDev;
  bool baPar;
  bool baNw;
  bool baPort;
  bool nwItf;
  bool timeSet;
} _ConfigureServiceData__isset;

class ConfigureServiceData {
 public:

  static const char* ascii_fingerprint; // = "17C51ECC42A6421A315F94E001FC8E0A";
  static const uint8_t binary_fingerprint[16]; // = {0x17,0xC5,0x1E,0xCC,0x42,0xA6,0x42,0x1A,0x31,0x5F,0x94,0xE0,0x01,0xFC,0x8E,0x0A};

  ConfigureServiceData() : authToken(), origin() {
  }

  virtual ~ConfigureServiceData() throw() {}

  std::string authToken;
  std::string origin;
  DevIdent devIdent;
  BaDev baDev;
  BaPar baPar;
  BaNw baNw;
  BaPort baPort;
  NwItf nwItf;
  TimeSet timeSet;

  _ConfigureServiceData__isset __isset;

  void __set_authToken(const std::string& val) {
    authToken = val;
  }

  void __set_origin(const std::string& val) {
    origin = val;
  }

  void __set_devIdent(const DevIdent& val) {
    devIdent = val;
  }

  void __set_baDev(const BaDev& val) {
    baDev = val;
  }

  void __set_baPar(const BaPar& val) {
    baPar = val;
  }

  void __set_baNw(const BaNw& val) {
    baNw = val;
  }

  void __set_baPort(const BaPort& val) {
    baPort = val;
  }

  void __set_nwItf(const NwItf& val) {
    nwItf = val;
  }

  void __set_timeSet(const TimeSet& val) {
    timeSet = val;
  }

  bool operator == (const ConfigureServiceData & rhs) const
  {
    if (!(authToken == rhs.authToken))
      return false;
    if (!(origin == rhs.origin))
      return false;
    if (!(devIdent == rhs.devIdent))
      return false;
    if (!(baDev == rhs.baDev))
      return false;
    if (!(baPar == rhs.baPar))
      return false;
    if (!(baNw == rhs.baNw))
      return false;
    if (!(baPort == rhs.baPort))
      return false;
    if (!(nwItf == rhs.nwItf))
      return false;
    if (!(timeSet == rhs.timeSet))
      return false;
    return true;
  }
  bool operator != (const ConfigureServiceData &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ConfigureServiceData & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(ConfigureServiceData &a, ConfigureServiceData &b);

typedef struct _UnconfigureServiceData__isset {
  _UnconfigureServiceData__isset() : authToken(false), origin(false), devIdent(false), unconfigureLevel(false) {}
  bool authToken;
  bool origin;
  bool devIdent;
  bool unconfigureLevel;
} _UnconfigureServiceData__isset;

class UnconfigureServiceData {
 public:

  static const char* ascii_fingerprint; // = "41717AA5DE93CA2904301806B5D069EF";
  static const uint8_t binary_fingerprint[16]; // = {0x41,0x71,0x7A,0xA5,0xDE,0x93,0xCA,0x29,0x04,0x30,0x18,0x06,0xB5,0xD0,0x69,0xEF};

  UnconfigureServiceData() : authToken(), origin(), unconfigureLevel() {
  }

  virtual ~UnconfigureServiceData() throw() {}

  std::string authToken;
  std::string origin;
  DevIdent devIdent;
  std::string unconfigureLevel;

  _UnconfigureServiceData__isset __isset;

  void __set_authToken(const std::string& val) {
    authToken = val;
  }

  void __set_origin(const std::string& val) {
    origin = val;
  }

  void __set_devIdent(const DevIdent& val) {
    devIdent = val;
  }

  void __set_unconfigureLevel(const std::string& val) {
    unconfigureLevel = val;
  }

  bool operator == (const UnconfigureServiceData & rhs) const
  {
    if (!(authToken == rhs.authToken))
      return false;
    if (!(origin == rhs.origin))
      return false;
    if (!(devIdent == rhs.devIdent))
      return false;
    if (!(unconfigureLevel == rhs.unconfigureLevel))
      return false;
    return true;
  }
  bool operator != (const UnconfigureServiceData &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UnconfigureServiceData & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(UnconfigureServiceData &a, UnconfigureServiceData &b);

typedef struct _SetTimeServiceData__isset {
  _SetTimeServiceData__isset() : authToken(false), origin(false), scopeFilter(false), utctime(false) {}
  bool authToken;
  bool origin;
  bool scopeFilter;
  bool utctime;
} _SetTimeServiceData__isset;

class SetTimeServiceData {
 public:

  static const char* ascii_fingerprint; // = "5F9965D46A4F3845985AC0F9B81C3C69";
  static const uint8_t binary_fingerprint[16]; // = {0x5F,0x99,0x65,0xD4,0x6A,0x4F,0x38,0x45,0x98,0x5A,0xC0,0xF9,0xB8,0x1C,0x3C,0x69};

  SetTimeServiceData() : authToken(), origin(), scopeFilter(), utctime(0) {
  }

  virtual ~SetTimeServiceData() throw() {}

  std::string authToken;
  std::string origin;
  std::string scopeFilter;
  timestamp utctime;

  _SetTimeServiceData__isset __isset;

  void __set_authToken(const std::string& val) {
    authToken = val;
  }

  void __set_origin(const std::string& val) {
    origin = val;
  }

  void __set_scopeFilter(const std::string& val) {
    scopeFilter = val;
  }

  void __set_utctime(const timestamp val) {
    utctime = val;
  }

  bool operator == (const SetTimeServiceData & rhs) const
  {
    if (!(authToken == rhs.authToken))
      return false;
    if (!(origin == rhs.origin))
      return false;
    if (!(scopeFilter == rhs.scopeFilter))
      return false;
    if (!(utctime == rhs.utctime))
      return false;
    return true;
  }
  bool operator != (const SetTimeServiceData &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SetTimeServiceData & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(SetTimeServiceData &a, SetTimeServiceData &b);

typedef struct _SetPasswordServiceData__isset {
  _SetPasswordServiceData__isset() : authToken(false), origin(false), scopeFilter(false), type(false), newpassword(false) {}
  bool authToken;
  bool origin;
  bool scopeFilter;
  bool type;
  bool newpassword;
} _SetPasswordServiceData__isset;

class SetPasswordServiceData {
 public:

  static const char* ascii_fingerprint; // = "C18AD26BF3FFAD5198DC3D25D5D7A521";
  static const uint8_t binary_fingerprint[16]; // = {0xC1,0x8A,0xD2,0x6B,0xF3,0xFF,0xAD,0x51,0x98,0xDC,0x3D,0x25,0xD5,0xD7,0xA5,0x21};

  SetPasswordServiceData() : authToken(), origin(), scopeFilter(), type(0), newpassword() {
  }

  virtual ~SetPasswordServiceData() throw() {}

  std::string authToken;
  std::string origin;
  std::string scopeFilter;
  int32_t type;
  std::string newpassword;

  _SetPasswordServiceData__isset __isset;

  void __set_authToken(const std::string& val) {
    authToken = val;
  }

  void __set_origin(const std::string& val) {
    origin = val;
  }

  void __set_scopeFilter(const std::string& val) {
    scopeFilter = val;
  }

  void __set_type(const int32_t val) {
    type = val;
  }

  void __set_newpassword(const std::string& val) {
    newpassword = val;
  }

  bool operator == (const SetPasswordServiceData & rhs) const
  {
    if (!(authToken == rhs.authToken))
      return false;
    if (!(origin == rhs.origin))
      return false;
    if (!(scopeFilter == rhs.scopeFilter))
      return false;
    if (!(type == rhs.type))
      return false;
    if (!(newpassword == rhs.newpassword))
      return false;
    return true;
  }
  bool operator != (const SetPasswordServiceData &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SetPasswordServiceData & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(SetPasswordServiceData &a, SetPasswordServiceData &b);

} // namespace

#endif
