/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef Types_TYPES_H
#define Types_TYPES_H

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include "Scheduler_types.h"
#include "Trend_types.h"


namespace siemens { namespace bt { namespace type {

struct BA_DATA_TYPE {
  enum type {
    BA_NULL = 0,
    BA_BOOL = 1,
    BA_UINT = 2,
    BA_INT = 3,
    BA_REAL = 4,
    BA_DOUBLE = 5,
    BA_OCTET_STRING = 6,
    BA_CHAR_STRING = 7,
    BA_BIT_STRING = 8,
    BA_ENUMERATED = 9,
    BA_DATE = 10,
    BA_TIME = 11,
    BA_OBJ_ID = 12
  };
};

extern const std::map<int, const char*> _BA_DATA_TYPE_VALUES_TO_NAMES;

struct Property_Type {
  enum type {
    BA_PROP_ACKED_TRANSITIONS = 0,
    BA_PROP_ACK_REQUIRED = 1,
    BA_PROP_ACTION = 2,
    BA_PROP_ACTION_TEXT = 3,
    BA_PROP_ACTIVE_TEXT = 4,
    BA_PROP_ACTIVE_VT_SESSION = 5,
    BA_PROP_ALARM_VALUE = 6,
    BA_PROP_ALARM_VALUES = 7,
    BA_PROP_ALL = 8,
    BA_PROP_ALL_WRITES_SUCCESSFUL = 9,
    BA_PROP_APDU_SEGMENT_TIMEOUT = 10,
    BA_PROP_APDU_TIMEOUT = 11,
    BA_PROP_APPLICATION_SOFTWARE_VERSION = 12,
    BA_PROP_ARCHIVE = 13,
    BA_PROP_BIAS = 14,
    BA_PROP_CHANGE_OF_STATE_COUNT = 15,
    BA_PROP_CHANGE_OF_STATE_TIME = 16,
    BA_PROP_NOTIFICATION_CLASS = 17,
    BA_PROP_CONTROLLED_VARIABLE_REFERENCE = 19,
    BA_PROP_CONTROLLED_VARIABLE_UNITS = 20,
    BA_PROP_CONTROLLED_VARIABLE_VALUE = 21,
    BA_PROP_COV_INCREMENT = 22,
    BA_PROP_DATELIST = 23,
    BA_PROP_DAYLIGHT_SAVINGS_STATUS = 24,
    BA_PROP_DEADBAND = 25,
    BA_PROP_DERIVATIVE_CONSTANT = 26,
    BA_PROP_DERIVATIVE_CONSTANT_UNITS = 27,
    BA_PROP_DESCRIPTION = 28,
    BA_PROP_DESCRIPTION_OF_HALT = 29,
    BA_PROP_DEVICE_ADDRESS_BINDING = 30,
    BA_PROP_DEVICE_TYPE = 31,
    BA_PROP_EFFECTIVE_PERIOD = 32,
    BA_PROP_ELAPSED_ACTIVE_TIME = 33,
    BA_PROP_ERROR_LIMIT = 34,
    BA_PROP_EVENT_ENABLE = 35,
    BA_PROP_EVENT_STATE = 36,
    BA_PROP_EVENT_TYPE = 37,
    BA_PROP_EXCEPTION_SCHEDULE = 38,
    BA_PROP_FAULT_VALUES = 39,
    BA_PROP_FEEDBACK_VALUE = 40,
    BA_PROP_FILE_ACCESS_METHOD = 41,
    BA_PROP_FILE_SIZE = 42,
    BA_PROP_FILE_TYPE = 43,
    BA_PROP_FIRMWARE_REVISION = 44,
    BA_PROP_HIGH_LIMIT = 45,
    BA_PROP_INACTIVE_TEXT = 46,
    BA_PROP_IN_PROCESS = 47,
    BA_PROP_INSTANCE_OF = 48,
    BA_PROP_INTEGRAL_CONSTANT = 49,
    BA_PROP_INTEGRAL_CONSTANT_UNITS = 50,
    BA_PROP_ISSUE_CONFIRMED_NOTIFICATIONS = 51,
    BA_PROP_LIMIT_ENABLE = 52,
    BA_PROP_LIST_OF_GROUP_MEMBERS = 53,
    BA_PROP_LIST_OF_OBJECT_PROPERTY_REFERENCES = 54,
    BA_PROP_LIST_OF_SESSION_KEYS = 55,
    BA_PROP_LOCAL_DATE = 56,
    BA_PROP_LOCAL_TIME = 57,
    BA_PROP_LOCATION = 58,
    BA_PROP_LOW_LIMIT = 59,
    BA_PROP_MANIPULATED_VARIABLE_REFERENCE = 60,
    BA_PROP_MAXIMUM_OUTPUT = 61,
    BA_PROP_MAX_APDU_LENGTH_ACCEPTED = 62,
    BA_PROP_MAX_INFO_FRAMES = 63,
    BA_PROP_MAX_MASTER = 64,
    BA_PROP_MAX_PRES_VALUE = 65,
    BA_PROP_MINIMUM_OFF_TIME = 66,
    BA_PROP_MINIMUM_ON_TIME = 67,
    BA_PROP_MINIMUM_OUTPUT = 68,
    BA_PROP_MIN_PRES_VALUE = 69,
    BA_PROP_MODEL_NAME = 70,
    BA_PROP_MODIFICATION_DATE = 71,
    BA_PROP_NOTIFY_TYPE = 72,
    BA_PROP_NUMBER_OF_APDU_RETRIES = 73,
    BA_PROP_NUMBER_OF_STATES = 74,
    BA_PROP_OBJECT_IDENTIFIER = 75,
    BA_PROP_OBJECT_LIST = 76,
    BA_PROP_OBJECT_NAME = 77,
    BA_PROP_OBJECT_PROPERTY_REFERENCE = 78,
    BA_PROP_OBJECT_TYPE = 79,
    BA_PROP_OPTIONAL = 80,
    BA_PROP_OUT_OF_SERVICE = 81,
    BA_PROP_OUTPUT_UNITS = 82,
    BA_PROP_EVENT_PARAMETERS = 83,
    BA_PROP_POLARITY = 84,
    BA_PROP_PRESENT_VALUE = 85,
    BA_PROP_PRIORITY = 86,
    BA_PROP_PRIORITY_ARRAY = 87,
    BA_PROP_PRIORITY_FOR_WRITING = 88,
    BA_PROP_PROCESS_IDENTIFIER = 89,
    BA_PROP_PROGRAM_CHANGE = 90,
    BA_PROP_PROGRAM_LOCATION = 91,
    BA_PROP_PROGRAM_STATE = 92,
    BA_PROP_PROPORTIONAL_CONSTANT = 93,
    BA_PROP_PROPORTIONAL_CONSTANT_UNITS = 94,
    BA_PROP_PROTOCOL_CONFORMANCE_CLASS = 95,
    BA_PROP_PROTOCOL_OBJECT_TYPES_SUPPORTED = 96,
    BA_PROP_PROTOCOL_SERVICES_SUPPORTED = 97,
    BA_PROP_PROTOCOL_VERSION = 98,
    BA_PROP_READ_ONLY = 99,
    BA_PROP_REASON_FOR_HALT = 100,
    BA_PROP_RECIPIENT = 101,
    BA_PROP_RECIPIENT_LIST = 102,
    BA_PROP_RELIABILITY = 103,
    BA_PROP_RELINQUISH_DEFAULT = 104,
    BA_PROP_REQUIRED = 105,
    BA_PROP_RESOLUTION = 106,
    BA_PROP_SEGMENTATION_SUPPORTED = 107,
    BA_PROP_SETPOINT = 108,
    BA_PROP_SETPOINT_REFERENCE = 109,
    BA_PROP_STATE_TEXT = 110,
    BA_PROP_STATUS_FLAGS = 111,
    BA_PROP_SYSTEM_STATUS = 112,
    BA_PROP_TIME_DELAY = 113,
    BA_PROP_TIME_OF_ACTIVE_TIME_RESET = 114,
    BA_PROP_TIME_OF_STATE_COUNT_RESET = 115,
    BA_PROP_TIME_SYNCHRONIZATION_RECIPIENTS = 116,
    BA_PROP_UNITS = 117,
    BA_PROP_UPDATE_INTERVAL = 118,
    BA_PROP_UTC_OFFSET = 119,
    BA_PROP_VENDOR_IDENTIFIER = 120,
    BA_PROP_VENDOR_NAME = 121,
    BA_PROP_VT_CLASSES_SUPPORTED = 122,
    BA_PROP_WEEKLY_SCHEDULE = 123,
    BA_PROP_ATTEMPTED_SAMPLES = 124,
    BA_PROP_AVERAGE_VALUE = 125,
    BA_PROP_BUFFER_SIZE = 126,
    BA_PROP_CLIENT_COV_INCREMENT = 127,
    BA_PROP_COV_RESUBSCRIPTION_INTERVAL = 128,
    BA_PROP_CURRENT_NOTIFY_TIME = 129,
    BA_PROP_EVENT_TIME_STAMPS = 130,
    BA_PROP_LOG_BUFFER = 131,
    BA_PROP_LOG_DEVICE_OBJECT_PROPERTY = 132,
    BA_PROP_ENABLE = 133,
    BA_PROP_LOG_INTERVAL = 134,
    BA_PROP_MAXIMUM_VALUE = 135,
    BA_PROP_MINIMUM_VALUE = 136,
    BA_PROP_NOTIFICATION_THRESHOLD = 137,
    BA_PROP_PREVIOUS_NOTIFY_TIME = 138,
    BA_PROP_PROTOCOL_REVISION = 139,
    BA_PROP_RECORDS_SINCE_NOTIFICATION = 140,
    BA_PROP_RECORD_COUNT = 141,
    BA_PROP_START_TIME = 142,
    BA_PROP_STOP_TIME = 143,
    BA_PROP_STOP_WHEN_FULL = 144,
    BA_PROP_TOTAL_RECORD_COUNT = 145,
    BA_PROP_VALID_SAMPLES = 146,
    BA_PROP_WINDOW_INTERVAL = 147,
    BA_PROP_WINDOW_SAMPLES = 148,
    BA_PROP_MAXIMUM_VALUE_TIMESTAMP = 149,
    BA_PROP_MINIMUM_VALUE_TIMESTAMP = 150,
    BA_PROP_VARIANCE_VALUE = 151,
    BA_PROP_ACTIVE_COV_SUBSCRIPTIONS = 152,
    BA_PROP_BACKUP_FAILURE_TIMEOUT = 153,
    BA_PROP_CONFIGURATION_FILES = 154,
    BA_PROP_DATABASE_REVISION = 155,
    BA_PROP_DIRECT_READING = 156,
    BA_PROP_LAST_RESTORE_TIME = 157,
    BA_PROP_MAINTENANCE_REQUIRED = 158,
    BA_PROP_MEMBER_OF = 159,
    BA_PROP_MODE = 160,
    BA_PROP_OPERATION_REQUIRED = 161,
    BA_PROP_SETTING = 162,
    BA_PROP_SILENCED = 163,
    BA_PROP_TRACKING_VALUE = 164,
    BA_PROP_ZONE_MEMBERS = 165,
    BA_PROP_LIFE_SAFETY_ALARM_VALUES = 166,
    BA_PROP_MAX_SEGMENTS_ACCEPTED = 167,
    BA_PROP_PROFILE_NAME = 168,
    BA_PROP_AUTO_SLAVE_DISCOVERY = 169,
    BA_PROP_MANUAL_SLAVE_ADDRESS_BINDING = 170,
    BA_PROP_SLAVE_ADDRESS_BINDING = 171,
    BA_PROP_SLAVE_PROXY_ENABLE = 172,
    BA_PROP_LAST_NOTIFY_RECORD = 173,
    BA_PROP_SCHEDULE_DEFAULT = 174,
    BA_PROP_ACCEPTED_MODES = 175,
    BA_PROP_ADJUST_VALUE = 176,
    BA_PROP_COUNT = 177,
    BA_PROP_COUNT_BEFORE_CHANGE = 178,
    BA_PROP_COUNT_CHANGE_TIME = 179,
    BA_PROP_COV_PERIOD = 180,
    BA_PROP_INPUT_REFERENCE = 181,
    BA_PROP_LIMIT_MONITORING_INTERVAL = 182,
    BA_PROP_LOGGING_OBJECT = 183,
    BA_PROP_LOGGING_RECORD = 184,
    BA_PROP_PRESCALE = 185,
    BA_PROP_PULSE_RATE = 186,
    BA_PROP_SCALE = 187,
    BA_PROP_SCALE_FACTOR = 188,
    BA_PROP_UPDATE_TIME = 189,
    BA_PROP_VALUE_BEFORE_CHANGE = 190,
    BA_PROP_VALUE_SET = 191,
    BA_PROP_VALUE_CHANGE_TIME = 192,
    BA_PROP_ALIGN_INTERVALS = 193,
    BA_PROP_INTERVAL_OFFSET = 195,
    BA_PROP_LAST_RESTART_REASON = 196,
    BA_PROP_LOGGING_TYPE = 197,
    BA_PROP_RESTART_NOTIFICATION_RECIPIENTS = 202,
    BA_PROP_TIME_OF_DEVICE_RESTART = 203,
    BA_PROP_TIME_SYNCHRONIZATION_INTERVAL = 204,
    BA_PROP_TRIGGER = 205,
    BA_PROP_UTC_TIME_SYNCHRONIZATION_RECIPIENTS = 206,
    BA_PROP_NODE_SUBTYPE = 207,
    BA_PROP_NODE_TYPE = 208,
    BA_PROP_STRUCTURED_OBJECT_LIST = 209,
    BA_PROP_SUBORDINATE_ANNOTATIONS = 210,
    BA_PROP_SUBORDINATE_LIST = 211,
    BA_PROP_ACTUAL_SHED_LEVEL = 212,
    BA_PROP_DUTY_WINDOW = 213,
    BA_PROP_EXPECTED_SHED_LEVEL = 214,
    BA_PROP_FULL_DUTY_BASELINE = 215,
    BA_PROP_REQUESTED_SHED_LEVEL = 218,
    BA_PROP_SHED_DURATION = 219,
    BA_PROP_SHED_LEVEL_DESCRIPTIONS = 220,
    BA_PROP_SHED_LEVELS = 221,
    BA_PROP_DOOR_ALARM_STATE = 226,
    BA_PROP_DOOR_EXTENDED_PULSE_TIME = 227,
    BA_PROP_DOOR_MEMBERS = 228,
    BA_PROP_DOOR_OPEN_TOO_LONG_TIME = 229,
    BA_PROP_DOOR_PULSE_TIME = 230,
    BA_PROP_DOOR_STATUS = 231,
    BA_PROP_DOOR_UNLOCK_DELAY_TIME = 232,
    BA_PROP_LOCK_STATUS = 233,
    BA_PROP_MASKED_ALARM_VALUES = 234,
    BA_PROP_SECURED_STATUS = 235,
    BA_PROP_BACKUP_AND_RESTORE_STATE = 338,
    BA_PROP_BACKUP_PREPARATION_TIME = 339,
    BA_PROP_RESTORE_COMPLETION_TIME = 340,
    BA_PROP_RESTORE_PREPARATION_TIME = 341,
    BA_PROP_USER_DESIGNATION = 3000,
    BA_PROP_SURROUND = 3001,
    BA_PROP_INTERFACE_LIST = 3002,
    BA_PROP_LOCAL_LIST = 3003,
    BA_PROP_HIERARCHY_LIST = 3004,
    BA_PROP_ELEMENT_TYPE = 3005,
    BA_PROP_OBJECT_TAG = 3006,
    BA_PROP_FUNCTION_NAME = 3007,
    BA_PROP_LOW_VALUE = 3008,
    BA_PROP_HIGH_VALUE = 3009,
    BA_PROP_PARAMETER_KIND = 3010,
    BA_PROP_ALARM_ENABLE = 3011,
    BA_PROP_LOCKED = 3013,
    BA_PROP_TIME_OF_ACKED = 3014,
    BA_PROP_ACK_INITIALS = 3015,
    BA_PROP_MESSAGE_TEXT = 3016,
    BA_PROP_SLOPE = 3017,
    BA_PROP_INTERCEPT = 3018,
    BA_PROP_ADDRESS = 3019,
    BA_PROP_COMMISSIONING_STATE = 3021,
    BA_PROP_NAME_REFERENCE = 3022,
    BA_PROP_FEEDBACK_ADDR = 3023,
    BA_PROP_DESTINATION_LIST = 3025,
    BA_PROP_SITE_NAME = 3026,
    BA_PROP_PRIMARY_DEVICE = 3028,
    BA_PROP_GLOBAL_OBJECTS_MODIFICATION_TIME = 3029,
    BA_PROP_GLOBAL_OBJECTS_UPDATE_TIME = 3030,
    BA_PROP_SYNCH_REQUEST_PERIOD = 3033,
    BA_PROP_PROGRAM_MODIFICATION_TIME = 3034,
    BA_PROP_MIN_CYCLE_TIME = 3035,
    BA_PROP_MAX_CYCLE_TIME = 3036,
    BA_PROP_CYCLE_TIME_STATISTICS = 3037,
    BA_PROP_MEMORY_STATISTICS = 3038,
    BA_PROP_COMMUNICATION_STATISTICS = 3039,
    BA_PROP_SERIAL_LINE_STATISTICS = 3040,
    BA_PROP_DIAGNOSTICS = 3041,
    BA_PROP_MAIN_PARAMETER = 3042,
    BA_PROP_ACCESS_RIGHT = 3043,
    BA_PROP_MAX_SIZE = 3044,
    BA_PROP_MIN_SIZE = 3045,
    BA_PROP_ENABLE_ACTIVE_TIME = 3046,
    BA_PROP_ELAPSED_TIME_LIMIT = 3047,
    BA_PROP_TOTAL_ACTIVE_TIME = 3048,
    BA_PROP_SHADOW_DEV_OBJ_ID = 3049,
    BA_PROP_SHADOW_DEV_OBJ_NAME = 3050,
    BA_PROP_EXPIRED_DATE = 3052,
    BA_PROP_FEEDBACK_POLARITY = 3053,
    BA_PROP_FEEDBACK_SLOPE = 3054,
    BA_PROP_FEEDBACK_INTERCEPT = 3055,
    BA_PROP_EXCEPTIONS = 3056,
    BA_PROP_NEXT_VALUE = 3057,
    BA_PROP_NEXT_TIME = 3058,
    BA_PROP_PARAMETER_LIST = 3059,
    BA_PROP_LIST_OF_NAME_REFERENCE = 3060,
    BA_PROP_DAYLIGHT_SAVING_BEGIN_DATE = 3061,
    BA_PROP_DAYLIGHT_SAVING_BEGIN_TIME = 3062,
    BA_PROP_DAYLIGHT_SAVING_END_DATE = 3063,
    BA_PROP_DAYLIGHT_SAVING_END_TIME = 3064,
    BA_PROP_OPERATING_HOURS_MESSAGE = 3066,
    BA_PROP_EXPIRED = 3067,
    BA_PROP_ELAPSED_TIME = 3068,
    BA_PROP_MAX_INSTR_COUNT = 3069,
    BA_PROP_RECLAIM_TIME = 3070,
    BA_PROP_YESTERDAY = 3072,
    BA_PROP_NEXT_DATE = 3073,
    BA_PROP_VISIBILITY = 3074,
    BA_PROP_SERVER_TYPE = 3075,
    BA_PROP_NAME_RESOLUTION_INTERVAL = 3076,
    BA_PROP_SHADOW_APDU_SEGMENT_TIMEOUT = 3077,
    BA_PROP_SHADOW_APDU_TIMEOUT = 3078,
    BA_PROP_SHADOW_MAX_APDU_LENGTH_ACCEPTED = 3079,
    BA_PROP_SHADOW_NUMBER_OF_APDU_RETRIES = 3080,
    BA_PROP_GLOBAL = 3081,
    BA_PROP_STARTUP_STATISTIC = 3082,
    BA_PROP_DATETIME_SUBTYPE = 3083,
    BA_PROP_USERS = 3084,
    BA_PROP_USERGROUPS = 3085,
    BA_PROP_SCOPES = 3086,
    BA_PROP_LAST_MODIFICATION = 3087,
    BA_PROP_GROUP = 3088,
    BA_PROP_MAXNR_CALL_REPETITIONS = 3089,
    BA_PROP_TERMINATION_TIME_VALUE = 3090,
    BA_PROP_ACCESS_PASSWORD = 3091,
    BA_PROP_COM_INTERFACE_LIST = 3092,
    BA_PROP_CONNECTION_LIST = 3093,
    BA_PROP_MODEM_STATISTICS = 3094,
    BA_PROP_MODEM_SETTINGS = 3095,
    BA_PROP_MODEM_STATUS = 3096,
    BA_PROP_CONNECT = 3097,
    BA_PROP_NETWORK_NUMBER = 3098,
    BA_PROP_ALARM_PRIO_LIMIT = 3099,
    BA_PROP_TOMORROW = 3100,
    BA_PROP_DAY_AFTER_TOMORROW = 3101,
    BA_PROP_INTERVAL = 3102,
    BA_PROP_LAST_MESSAGE = 3103,
    BA_PROP_GROUP_MEMBERS = 3104,
    BA_PROP_ROOM_MEMBERS = 3105,
    BA_PROP_MENU_LINES = 3106,
    BA_PROP_TIME_DELAY1 = 3107,
    BA_PROP_TIME_DELAY2 = 3108,
    BA_PROP_IO_STATISTICS = 3109,
    BA_PROP_DELAY_ON = 3110,
    BA_PROP_DELAY_OFF = 3111,
    BA_PROP_ALARM_COLLECTION_REF = 3113,
    BA_PROP_ALARM_CLASS = 3114,
    BA_PROP_SWITCH_UP = 3115,
    BA_PROP_SWITCH_DOWN = 3116,
    BA_PROP_PRESENT_POWER = 3117,
    BA_PROP_CONTROLLED_POWER = 3118,
    BA_PROP_IP_PARAMETERS = 3119,
    BA_PROP_DPX_SUBSTITUTION_VALUE = 3120,
    BA_PROP_DPX_DESCRIPTION_LIST = 3121,
    BA_PROP_DPX_ALARM_FUNCTION = 3122,
    BA_PROP_DPX_HEARTBEAT = 3123,
    BA_PROP_DPX_JITTER_SUPPRESS = 3124,
    BA_PROP_DPX_RELIABILITY_ERROR_LIST = 3125,
    BA_PROP_DPX_POLLING_CYCLE = 3126,
    BA_PROP_DPX_EVENT_COUNT = 3127,
    BA_PROP_DPX_EXTENDED_NOTIFY = 3132,
    BA_PROP_DPX_LOG_STATUS = 3133,
    BA_PROP_DPX_SET_VALUE = 3134,
    BA_PROP_DPX_INTEGRAL_TIME = 3135,
    BA_PROP_DPX_NEUTRAL_ZONE = 3136,
    BA_PROP_DPX_DERIVATIVE_TIME = 3137,
    BA_PROP_DPX_TI0TO100 = 3138,
    BA_PROP_DPX_TI100TO0 = 3139,
    BA_PROP_DPX_LOOP_STATE = 3140,
    BA_PROP_DPX_SETPOINT_RESOLUTION = 3141,
    BA_PROP_DPX_SETPOINT_HIGH_VALUE = 3142,
    BA_PROP_DPX_SETPOINT_LOW_VALUE = 3143,
    BA_PROP_DPX_ENABLE_LOG = 3144,
    BA_PROP_DPX_ALARM_CLASS_TEXT = 3145,
    BA_PROP_DPX_EXTENDED_COMMAND = 3146,
    BA_PROP_DPX_FILE_OPERATION = 3148,
    BA_PROP_DPX_PULSECOUNT = 3149,
    BA_PROP_DPX_DATA_TIME_STAMP = 3150,
    BA_PROP_DPX_DATA_SOURCE = 3151,
    BA_PROP_DPX_SERIALIZATION_IN_PROGRESS = 3152,
    BA_PROP_DPX_AVAILABLE_FILE_STORAGE = 3153,
    BA_PROP_DPX_DEVICE_INFO_REFERENCE = 3154,
    BA_PROP_DPX_SCALE_FACTOR = 3200,
    BA_PROP_DPX_COUNT = 3201,
    BA_PROP_DPX_COUNT_BEFORE_RESET = 3202,
    BA_PROP_DPX_COV_PERIOD = 3203,
    BA_PROP_DPX_RESET_TIME = 3204,
    BA_PROP_DPX_RESET_VALUE = 3205,
    BA_PROP_DPX_TOTAL_COUNT = 3206,
    BA_PROP_DPX_UPDATE_TIME = 3207,
    BA_PROP_DPX_S_IN_PROCESS = 3210,
    BA_PROP_DPX_S_FEEDBACK_VALUE = 3211,
    BA_PROP_DPX_RESOLUTION = 3212,
    BA_PROP_DPX_S_UNIT = 3213,
    BA_PROP_DPX_S_INACTIVE_TEXT = 3214,
    BA_PROP_DPX_S_ACTIVE_TEXT = 3215,
    BA_PROP_DPX_S_NUMBER_OF_STATES = 3216,
    BA_PROP_DPX_S_STATE_TEXT = 3217,
    BA_PROP_DPX_S_RECIPIENT_LIST = 3218,
    BA_PROP_DPX_S_BUFFER_SIZE = 3219,
    BA_PROP_DPX_S_RECORD_COUNT = 3220,
    BA_PROP_DPX_S_NOTIFICATION_THRESHOLD = 3221,
    BA_PROP_DPX_S_BCKUP_SRVR_LIST = 3222,
    BA_PROP_DPX_S_OUT_OF_SERVICE = 3224,
    BA_PROP_DPX_S_ELAPSED_ACTIVE_TIME = 3225,
    BA_PROP_DPX_S_TIME_OF_ACTIVE_TIME_RESET = 3226,
    BA_PROP_DPX_S_MINIMUM_ON_TIME = 3227,
    BA_PROP_DPX_S_MINIMUM_OFF_TIME = 3228,
    BA_PROP_DPX_S_COV_RESUBSCRIPTION_INTERVAL = 3229,
    BA_PROP_DPX_ACTUAL_VALUE = 3230,
    BA_PROP_DPX_S_RELIABILITY = 3231,
    BA_PROP_DPX_S_STATUS_FLAGS = 3232,
    BA_PROP_DPX_ENABLE_CHANGE_OF_STATE_COUNT = 3233,
    BA_PROP_DPX_TECHNICAL_DESIGNATION = 3234,
    BA_PROP_DS7_INPUT_PTP = 3300,
    BA_PROP_DS1_ENABLE_MEMORIZE_FUNCTION = 4901,
    BA_PROP_DS1_RESOLUTION = 5035,
    BA_PROP_DS1_MIN_PRESENT_VALUE = 5036,
    BA_PROP_DS1_MAX_PRESENT_VALUE = 5037,
    BA_PROP_DS1_PRESENT_COMMAND = 5052,
    BA_PROP_DS1_RELIABILITY = 5053,
    BA_PROP_DS1_SIEMENS_URL = 5054,
    BA_PROP_DS1_LIST_OF_ITEM_ATTRIBUTES = 5055,
    BA_PROP_DS1_LIST_OF_ANNOTATIONS = 5056,
    BA_PROP_DS1_LIST_OF_OBJECT_PROPERTY_REF = 5057,
    BA_PROP_DS1_GROUP_MASTER = 5058,
    BA_PROP_DS1_GROUP_MEMBERS = 5059,
    BA_PROP_DS1_COLLECTED_DATA = 5060,
    BA_PROP_DS1_GROUP_COMMAND = 5061,
    BA_PROP_DS1_GROUP_NUMBER = 5062,
    BA_PROP_DS1_GROUP_CATEGORY_TEXT = 5063,
    BA_PROP_DS1_GROUP_CATEGORY = 5064,
    BA_PROP_DS1_SOURCE_PROPERTY_ID = 5065,
    BA_PROP_DS1_SOURCE_OBJECT_TAG = 5066,
    BA_PROP_DS1_MEMORIZE_VALUE = 5067,
    BA_PROP_DS1_RAMP_RATE = 5068,
    BA_PROP_DS1_BINARY_THRESHOLD = 5069,
    BA_PROP_DS1_BINARY_PRESENT_VALUE = 5070,
    BA_PROP_DS1_BURN_IN_TIME = 5071,
    BA_PROP_DS1_FADE_TIME = 5072,
    BA_PROP_DS1_IN_PROCESS = 5073,
    BA_PROP_DS1_LIFECYCLE_STATE = 5074,
    BA_PROP_DS1_LIFE_TIME = 5075,
    BA_PROP_DS1_MIN_ACTUAL_VALUE = 5076,
    BA_PROP_DS1_MAX_ACTUAL_VALUE = 5077,
    BA_PROP_DS1_COMPRESSION = 5078,
    BA_PROP_DS1_CHECKSUM = 5079,
    BA_PROP_DS1_FILE_FEATURES = 5080,
    BA_PROP_DS1_RT_SEQUENCE_COUNT = 5081,
    BA_PROP_DS1_ENGINEERING_COUNT = 5082,
    BA_PROP_DS1_PROGRESS_VALUE = 5083,
    BA_PROP_DS1_CONTROL_COMMAND = 5084,
    BA_PROP_DS1_RELINQUISH_DEFAULT_CONTROL = 5085,
    BA_PROP_DS1_SUBORDINATE_ATTRIBUTES = 5086,
    BA_PROP_DS1_PERIPHERAL_DEVICE_TYPE = 5087,
    BA_PROP_DS1_ABORT_COMMAND = 5088,
    BA_PROP_DS1_LASTMOVING_DIRECTION = 5089,
    BA_PROP_DS1_LIGHTING_VALUE = 5090,
    BA_PROP_DS1_LIGHTING_STATE = 5091,
    BA_PROP_DS1_IOADDRESS = 5092,
    BA_PROP_DS1_PRESENT_PRIORITY = 5093,
    BA_PROP_DS1_UPDATE_COUNT = 5094,
    BA_PROP_DS1_DEVICE_COMMAND = 5095,
    BA_PROP_DS1_ORPHAN_LIST = 5096,
    BA_PROP_DS1_FIELD_BUS_INFO = 5097,
    BA_PROP_DS1_DEVICE_COMMAND_RESULT = 5098,
    BA_PROP_DS1_FIELD_BUS_COMMAND = 5099,
    BA_PROP_DS1_SERIAL_NUMBER = 5100,
    BA_PROP_DS1_PERIPHERAL_DEVICE_INFO = 5101,
    BA_PROP_DS1_BA_PROTOTYPE = 5102,
    BA_PROP_DS1_COMMISSIONING_INFO = 5103,
    BA_PROP_DS1_COMMISSIONING_STATE = 5104,
    BA_PROP_DS1_CORRECTION_FACTOR = 5105,
    BA_PROP_DS1_CORRECTION_OFFSET = 5106,
    BA_PROP_DS1_TRACKING_VALUE = 5107,
    BA_PROP_DS1_S1_DEVICE_FEATURES = 5108,
    BA_PROP_DS1_ITEM_LIST = 5109,
    BA_PROP_DS1_DATA_TIMESTAMP = 5110,
    BA_PROP_DS1_OBJECT_ATTRIBUTES = 5111,
    BA_PROP_DS1_INTERNAL_OVERRIDE = 5112,
    BA_PROP_DS1_AVAILABLE_FLASH = 5113,
    BA_PROP_DS1_AVAILABLE_MEMORY = 5114,
    BA_PROP_ISA_EVENT_MESSAGE_TEXTS = 5117,
    BA_PROP_ISA_FUNCTION_SETS = 5118,
    BA_PROP_ISA_VERSION = 5119,
    BA_PROP_PPCL_STATEMENT = 5120,
    BA_PROP_DS1_SOURCE_DATA_TAG = 6000,
    BA_PROP_DS1_SOURCE_PROPERTY_TAG = 6001,
    BA_PROP_DS1_ITEM_VALUE_DATA_TAG = 6002,
    BA_PROP_DS1_ITEM_VALUE_OPERATION = 6003,
    BA_PROP_DS1_ITEM_VALUE_PRIORITY = 6004,
    BA_PROP_DS1_ITEM_VALUE = 6005,
    BA_PROP_DS1_ITEM_RELIABILITY = 6006,
    BA_PROP_DS1_COLLECTED_DATA_SEQ_NUMBER = 6007,
    BA_PROP_ANYORDUMMY_VALUE = 65535
  };
};

extern const std::map<int, const char*> _Property_Type_VALUES_TO_NAMES;

struct Object_Type {
  enum type {
    BA_OBJ_ANALOG_INPUT = 0,
    BA_OBJ_ANALOG_OUTPUT = 1,
    BA_OBJ_ANALOG_VALUE = 2,
    BA_OBJ_BINARY_INPUT = 3,
    BA_OBJ_BINARY_OUTPUT = 4,
    BA_OBJ_BINARY_VALUE = 5,
    BA_OBJ_CALENDAR = 6,
    BA_OBJ_COMMAND = 7,
    BA_OBJ_DEVICE = 8,
    BA_OBJ_EVENT_ENROLLMENT = 9,
    BA_OBJ_FILE = 10,
    BA_OBJ_GROUP = 11,
    BA_OBJ_LOOP = 12,
    BA_OBJ_MULTISTATE_INPUT = 13,
    BA_OBJ_MULTISTATE_OUTPUT = 14,
    BA_OBJ_NOTIFICATION_CLASS = 15,
    BA_OBJ_PROGRAM = 16,
    BA_OBJ_SCHEDULE = 17,
    BA_OBJ_AVERAGING = 18,
    BA_OBJ_MULTISTATE_VALUE = 19,
    BA_OBJ_TREND_LOG = 20,
    BA_OBJ_LIFE_SAFETY_POINT = 21,
    BA_OBJ_LIFE_SAFETY_ZONE = 22,
    BA_OBJ_ACCUMULATOR = 23,
    BA_OBJ_PULSE_CONVERTER = 24,
    BA_OBJ_EVENT_LOG = 25,
    BA_OBJ_GLOBAL_GROUP = 26,
    BA_OBJ_TREND_LOG_MULTIPLE = 27,
    BA_OBJ_LOAD_CONTROL = 28,
    BA_OBJ_STRUCTURED_VIEW = 29,
    BA_OBJ_ACCESS_DOOR = 30,
    BA_OBJ_ACCESS_CREDENTIAL = 32,
    BA_OBJ_ACCESS_POINT = 33,
    BA_OBJ_ACCESS_RIGHTS = 34,
    BA_OBJ_ACCESS_USER = 35,
    BA_OBJ_ACCESS_ZONE = 36,
    BA_OBJ_CREDENTIAL_DATA_INPUT = 37,
    BA_OBJ_BITSTRING_VALUE = 39,
    BA_OBJ_CHARACTERSTRING_VALUE = 40,
    BA_OBJ_DATE_PATTERN_VALUE = 41,
    BA_OBJ_DATE_VALUE = 42,
    BA_OBJ_DATETIME_PATTERN_VALUE = 43,
    BA_OBJ_DATETIME_VALUE = 44,
    BA_OBJ_INTEGER_VALUE = 45,
    BA_OBJ_LARGE_ANALOG_VALUE = 46,
    BA_OBJ_OCTETSTRING_VALUE = 47,
    BA_OBJ_POSITIVE_INTEGER_VALUE = 48,
    BA_OBJ_TIME_PATTERN_VALUE = 49,
    BA_OBJ_TIME_VALUE = 50,
    BA_OBJ_HIERARCHY = 200,
    BA_OBJ_BLOCK = 201,
    BA_OBJ_CMN_ALM = 214,
    BA_OBJ_DEVINFO = 217,
    BA_OBJ_DS1_GROUP_MEMBER = 256,
    BA_OBJ_DS1_GROUP_MASTER = 257,
    BA_OBJ_DS1_BLINDS_OUTPUT = 258,
    BA_OBJ_DS1_BLINDS_INPUT = 259,
    BA_OBJ_DS1_LIGHT_OUTPUT_ANALOG = 260,
    BA_OBJ_DS1_LIGHT_OUTPUT_BINARY = 261,
    BA_OBJ_DS1_LIGHT_INPUT = 262,
    BA_OBJ_ANYORDUMMY_VALUE = 65535
  };
};

extern const std::map<int, const char*> _Object_Type_VALUES_TO_NAMES;

struct Object_Prototype {
  enum type {
    BA_PROT_ANALOGINPUT = 1,
    BA_PROT_ANALOGPROCESSVALUE = 2,
    BA_PROT_ANALOGOUTPUT = 3,
    BA_PROT_BINARYINPUT = 4,
    BA_PROT_BINARYPROCESSVALUE = 5,
    BA_PROT_BINARYOUTPUT = 6,
    BA_PROT_MULTISTATEINPUT = 7,
    BA_PROT_MULTISTATEPROCESSVALUE = 8,
    BA_PROT_MULTISTATEOUTPUT = 9,
    BA_PROT_DEVICEOBJECT = 10,
    BA_PROT_ANALOGCONFIGVALUE = 11,
    BA_PROT_ANALOGCALCULATEDVALUE = 12,
    BA_PROT_BINARYCONFIGVALUE = 13,
    BA_PROT_BINARYCALCULATEDVALUE = 14,
    BA_PROT_MULTISTATECONFIGVALUE = 15,
    BA_PROT_MULTISTATECALCULATEDVALUE = 16,
    BA_PROT_UNSIGNEDCONFIGVALUE = 17,
    BA_PROT_LIGHTINPUT = 18,
    BA_PROT_LIGHTOUTPUTANALOG = 19,
    BA_PROT_LIGHTOUTPUTBINARY = 20,
    BA_PROT_BLINDSINPUT = 22,
    BA_PROT_BLINDSOUTPUT = 23,
    BA_PROT_PERIPHERALDEVICE = 24,
    BA_PROT_FIELDBUSMANAGEMENT = 25,
    BA_PROT_FILEOBJECT = 31,
    BA_PROT_COMMAND = 32,
    BA_PROT_GROUPMASTER = 33,
    BA_PROT_GROUPMEMBER = 34,
    BA_PROT_EVENTLOG = 35,
    BA_PROT_TRENDLOG_SIMPLE = 36,
    BA_PROT_NOTIFICATIONCLASS = 37,
    BA_PROT_VNOBJECTFUNCTIONAL = 40,
    BA_PROT_VNOBJECTCOLLECTION = 41,
    BA_PROT_VNOBJECTDEVICE = 42,
    BA_PROT_VNOBJECTNETWORK = 43,
    BA_PROT_VNOBJECTAREA = 44,
    BA_PROT_ANYORDUMMY_VALUE = 65535
  };
};

extern const std::map<int, const char*> _Object_Prototype_VALUES_TO_NAMES;

struct Write_Priority {
  enum type {
    BA_PRIO_MANUAL_LIFE_SAFETY = 1,
    BA_PRIO_MANUAL_AUTOMATIC_LIFE_SAFETY = 2,
    BA_PRIO_AVAILABLE3 = 3,
    BA_PRIO_AVAILABLE4 = 4,
    BA_PRIO_CRITICAL_EQUIPT_CTRL = 5,
    BA_PRIO_MIN_ON_OFF = 6,
    BA_PRIO_AVAILABLE7 = 7,
    BA_PRIO_MANUAL_OPERATOR = 8,
    BA_PRIO_AVAILABLE9 = 9,
    BA_PRIO_AVAILABLE10 = 10,
    BA_PRIO_AVAILABLE11 = 11,
    BA_PRIO_AVAILABLE12 = 12,
    BA_PRIO_AVAILABLE13 = 13,
    BA_PRIO_AVAILABLE14 = 14,
    BA_PRIO_AVAILABLE15 = 15,
    BA_PRIO_AVAILABLE16 = 16
  };
};

extern const std::map<int, const char*> _Write_Priority_VALUES_TO_NAMES;

struct BAPA_READACCESS_TYPE {
  enum type {
    BA_RA_NOACCESS = 0,
    BA_RA_INTERNAL = 1,
    BA_RA_EXTENDED_SERVICE = 2,
    BA_RA_BASIC_SERVICE = 3,
    BA_RA_ADMINISTRATOR = 4,
    BA_RA_EXTENDED_OPERATION = 5,
    BA_RA_STANDARD_OPEARATION = 6,
    BA_RA_BASIC_OPERATION = 7
  };
};

extern const std::map<int, const char*> _BAPA_READACCESS_TYPE_VALUES_TO_NAMES;

struct BAPA_WRITEACCESS_TYPE {
  enum type {
    BA_WR_NOACCESS = 0,
    BA_WR_INTERNAL = 1,
    BA_WR_EXTENDED_SERVICE = 2,
    BA_WR_BASIC_SERVICE = 3,
    BA_WR_ADMINISTRATOR = 4,
    BA_WR_EXTENDED_OPERATION = 5,
    BA_WR_STANDARD_OPEARATION = 6,
    BA_WR_BASIC_OPERATION = 7
  };
};

extern const std::map<int, const char*> _BAPA_WRITEACCESS_TYPE_VALUES_TO_NAMES;

struct PasswordType {
  enum type {
    PW_PLAIN = 0,
    PW_MD5 = 1
  };
};

extern const std::map<int, const char*> _PasswordType_VALUES_TO_NAMES;

struct ControlProgramState {
  enum type {
    S7_STOP_UPDATE = 1,
    S7_STOP_RESET = 2,
    S7_STOP_INIT = 3,
    S7_STOP_INTERNAL = 4,
    S7_START_OB102 = 5,
    S7_START_OB100 = 6,
    S7_START_OB101 = 7,
    S7_RUN = 8,
    S7_HALT = 10,
    S7_DEFECTIVE = 13,
    S7_POWER_OFF = 15,
    NO_S7 = 255
  };
};

extern const std::map<int, const char*> _ControlProgramState_VALUES_TO_NAMES;

struct DeviceState {
  enum type {
    DEV_RUN = 1,
    DEV_HALT = 2,
    DEV_RESTART = 3,
    DEV_RESET = 4
  };
};

extern const std::map<int, const char*> _DeviceState_VALUES_TO_NAMES;

struct Result_Code {
  enum type {
    RESULT_SUCCESS = 1,
    RESULT_LOCATION_AUTHENTICATION_REQUIRED = 2,
    RESULT_INVALID_ENTRY_ID = 3,
    RESULT_USER_AUTHENTICATION_REQUIRED = 4,
    RESULT_INVALID_CRENDENTIALS = 5,
    RESULT_IMAGE_ERROR = 6,
    RESULT_COMMAND_VALUE_ERROR = 7,
    RESULT_COMMAND_SCHEDULE_ERROR = 8,
    RESULT_COMMAND_TREND_ERROR = 9,
    RESULT_XML_WRITING_FAILED = 10,
    RESULT_OBJECT_NOT_FOUND = 11,
    RESULT_OBJECT_DATA_NOT_READY = 12,
    RESULT_PHASE_LIMIT_EXCEEDED = 13,
    RESULT_SPECIAL_EVENT_LIMIT_EXCEEDED = 14,
    RESULT_PROCESS_ERROR = 15,
    RESULT_INVALID_ELEMENT_NUMBER = 16,
    RESULT_COMMAND_MEMORIZE_FAILED = 17
  };
};

extern const std::map<int, const char*> _Result_Code_VALUES_TO_NAMES;

struct Command_Type {
  enum type {
    CMD_GET_MODEL_UPDATES = 1,
    CMD_AUTHENTICATION_LOCATION = 2,
    CMD_USER_LOGIN = 3,
    CMD_USER_LOGOUT = 4,
    CMD_SELECT_VIEW = 5,
    CMD_SELECT_FUNCTION = 6,
    CMD_COMMAND_VALUE = 7,
    CMD_MODIFY_SERVER_SETTINGS = 8,
    CMD_SCHEDULE = 9,
    CMD_TREND = 10,
    CMD_ALARM_ACKNOWLEDGE = 11
  };
};

extern const std::map<int, const char*> _Command_Type_VALUES_TO_NAMES;

struct CoreFunction {
  enum type {
    CORE_PLANT_VIEW = 0,
    CORE_FAVOURITES = 1,
    CORE_ALARMS = 2,
    CORE_SCHEDULE = 3,
    CORE_TREND = 4,
    CORE_SETTINGS = 5,
    CORE_DEFAULT = 6
  };
};

extern const std::map<int, const char*> _CoreFunction_VALUES_TO_NAMES;

struct AutoLogoutTime {
  enum type {
    ALT_5MIN = 5,
    ALT_10MIN = 10,
    ALT_15MIN = 15,
    ALT_30MIN = 30,
    ALT_45MIN = 45,
    ALT_60MIN = 60
  };
};

extern const std::map<int, const char*> _AutoLogoutTime_VALUES_TO_NAMES;

struct ScreenSaverTiOut {
  enum type {
    SST_5MIN = 5,
    SST_10MIN = 10,
    SST_15MIN = 15,
    SST_30MIN = 30,
    SST_45MIN = 45,
    SST_60MIN = 60,
    SST_DEFAULT = 15
  };
};

extern const std::map<int, const char*> _ScreenSaverTiOut_VALUES_TO_NAMES;

struct NavigBarTiOut {
  enum type {
    NBT_0FF = 0,
    NBT_5MIN = 5,
    NBT_10MIN = 10,
    NBT_15MIN = 15,
    NBT_30MIN = 30,
    NBT_45MIN = 45,
    NBT_60MIN = 60,
    NBT_DEFAULT = 30
  };
};

extern const std::map<int, const char*> _NavigBarTiOut_VALUES_TO_NAMES;

struct KeyBoardLayout {
  enum type {
    KBL_STANDARD = 0,
    KBL_RUSSIAN = 1
  };
};

extern const std::map<int, const char*> _KeyBoardLayout_VALUES_TO_NAMES;

struct DateFormat {
  enum type {
    DF_DDMMYYYY_DOT = 0,
    DF_DDMMYYYY_FSLASH = 1,
    DF_DDMMYYYY_DASH = 2,
    DF_YYYYMMDD_DOT = 3,
    DF_YYYYMMDD_FSLASH = 4,
    DF_YYYYMMDD_DASH = 5,
    DF_MMDDYYYY_DASH = 6,
    DF_MMDDYYYY_FSLASH = 7
  };
};

extern const std::map<int, const char*> _DateFormat_VALUES_TO_NAMES;

struct TimeFormat {
  enum type {
    TF_24H = 0,
    TF_12H = 1
  };
};

extern const std::map<int, const char*> _TimeFormat_VALUES_TO_NAMES;

struct Style {
  enum type {
    STYLE_DEFAULT = 0,
    STYLE_INVISIBLE = 1,
    STYLE_RED = 2,
    STYLE_GREEN = 3,
    STYLE_YELLOW = 4,
    STYLE_RED_BOLD = 5,
    STYLE_GREEN_BOLD = 6,
    STYLE_YELLOW_BOLD = 7,
    STYLE_BLUE = 8,
    STYLE_BLUE_BOLD = 9
  };
};

extern const std::map<int, const char*> _Style_VALUES_TO_NAMES;

struct Indicator {
  enum type {
    ALARM_ACKNOWLEDGE_NEEDED = 1,
    ALARM_RESET_NEEDED = 2,
    ALARM_NOTHING_NEEDED = 3,
    NO_ALARM_ACKNOWLEDGE_NEEDED = 4,
    NO_ALARM_RESET_NEEDED = 5,
    OVERRIDDEN = 6,
    OUT_OF_SERVICE = 7,
    LIFE_SAFETY = 8,
    CRITICAL_OPERATION = 9,
    ON_OFF_DELAY = 10,
    MANUAL_SWITCH = 11,
    SYSTEM_OPERATOR = 12,
    TRANSIENT = 13
  };
};

extern const std::map<int, const char*> _Indicator_VALUES_TO_NAMES;

struct AlarmFunction {
  enum type {
    NONE = 0,
    ACKNOWLEDGE = 1,
    RESET = 2,
    ACKNOWLEDGE_RESET = 3
  };
};

extern const std::map<int, const char*> _AlarmFunction_VALUES_TO_NAMES;

struct Anchor {
  enum type {
    ANCHOR_TOP_LEFT = 0,
    ANCHOR_BOTTOM_LEFT = 1,
    ANCHOR_TOP_RIGHT = 2,
    ANCHOR_BOTTOM_RIGHT = 3,
    ANCHOR_TOP_CENTER = 4,
    ANCHOR_BOTTOM_CENTER = 5,
    ANCHOR_CENTER = 6
  };
};

extern const std::map<int, const char*> _Anchor_VALUES_TO_NAMES;

struct RelativePosition {
  enum type {
    INVISIBLE = 0,
    POSITION_LEFT = 1,
    POSITION_ABOVE = 2,
    POSITION_BELOW = 3
  };
};

extern const std::map<int, const char*> _RelativePosition_VALUES_TO_NAMES;

struct ManipulatorType {
  enum type {
    SETVALUE = 0,
    SETSIZE = 1,
    NAVIGATE_TO = 2,
    NAVIGATE_TO_COLLECTION_MEMBER = 3,
    NAVIGATE_BACK = 4
  };
};

extern const std::map<int, const char*> _ManipulatorType_VALUES_TO_NAMES;

struct Mode {
  enum type {
    MANUAL = 0,
    AUTOMATIC = 1
  };
};

extern const std::map<int, const char*> _Mode_VALUES_TO_NAMES;

struct GraphicPageElementType {
  enum type {
    PANE = 0,
    LINK = 1,
    PROCESSVALUE = 2,
    SETTINGS = 3
  };
};

extern const std::map<int, const char*> _GraphicPageElementType_VALUES_TO_NAMES;

struct BehaviorType {
  enum type {
    NORMAL = 0,
    TRIGGER_FEEDBACK = 1,
    TRIGGER_TOGGLE = 2,
    SCENE = 3,
    LGT_RELATIVE = 4,
    LGT_ABSOLUTE = 5,
    BLIND = 6
  };
};

extern const std::map<int, const char*> _BehaviorType_VALUES_TO_NAMES;

struct CommandValueType {
  enum type {
    CMD_VALUE = 1,
    CMD_MEMORIZE = 2,
    CMD_LIGHT_CONTROL = 3,
    CMD_BLIND_CONTROL = 4
  };
};

extern const std::map<int, const char*> _CommandValueType_VALUES_TO_NAMES;

struct LightOperation {
  enum type {
    LIGHT_OP_STOP = 0,
    LIGHT_OP_START_DIM_UP = 1,
    LIGHT_OP_START_DIM_DOWN = 2,
    LIGHT_OP_STEP_UP = 3,
    LIGHT_OP_STEP_DOWN = 4,
    LIGHT_OP_SWITCH_ON = 5,
    LIGHT_OP_SWITCH_OFF = 6,
    LIGHT_OP_GOTO_LEVEL = 7
  };
};

extern const std::map<int, const char*> _LightOperation_VALUES_TO_NAMES;

struct BlindOperation {
  enum type {
    BLIND_OP_STOP = 0,
    BLIND_OP_MOVE_UP = 1,
    BLIND_OP_MOVE_DOWN = 2,
    BLIND_OP_STOP_OR_STEP_UP = 3,
    BLIND_OP_STOP_OR_STEP_DOWN = 4,
    BLIND_OP_GOTO_HEIGHT = 5,
    BLIND_OP_GOTO_ANGLE = 6,
    BLIND_OP_GOTO_POSITION = 7,
    BLIND_OP_GOTO_PREDEFINED_POSITION = 8,
    BLIND_OP_NO_OPERATION = 9
  };
};

extern const std::map<int, const char*> _BlindOperation_VALUES_TO_NAMES;

struct PaneKind {
  enum type {
    PANE_APPLICATION = 0,
    PANE_PAGES = 1,
    PANE_STATUS = 2,
    PANE_CONTENT = 3,
    PANE_NAVIGATION = 4
  };
};

extern const std::map<int, const char*> _PaneKind_VALUES_TO_NAMES;

struct ElementType {
  enum type {
    ELEM_TYPE_MODIFY_TP = 0,
    ELEM_TYPE_MODIFY_RUT1 = 1,
    ELEM_TYPE_MODIFY_RUT2 = 2,
    ELEM_TYPE_TRIGGER = 3,
    ELEM_TYPE_READ_ONLY = 4
  };
};

extern const std::map<int, const char*> _ElementType_VALUES_TO_NAMES;

struct ElementSize {
  enum type {
    ELEM_SIZE_NORMAL = 0,
    ELEM_SIZE_STATUSBAR = 1
  };
};

extern const std::map<int, const char*> _ElementSize_VALUES_TO_NAMES;

typedef struct _AccessInfo__isset {
  _AccessInfo__isset() : readAccess(false), writeAccess(false) {}
  bool readAccess;
  bool writeAccess;
} _AccessInfo__isset;

class AccessInfo {
 public:

  static const char* ascii_fingerprint; // = "69EF77542FBF7A8DD68310C9FF3B44BD";
  static const uint8_t binary_fingerprint[16]; // = {0x69,0xEF,0x77,0x54,0x2F,0xBF,0x7A,0x8D,0xD6,0x83,0x10,0xC9,0xFF,0x3B,0x44,0xBD};

  AccessInfo() : readAccess((BAPA_READACCESS_TYPE::type)0), writeAccess((BAPA_WRITEACCESS_TYPE::type)0) {
  }

  virtual ~AccessInfo() throw() {}

  BAPA_READACCESS_TYPE::type readAccess;
  BAPA_WRITEACCESS_TYPE::type writeAccess;

  _AccessInfo__isset __isset;

  void __set_readAccess(const BAPA_READACCESS_TYPE::type val) {
    readAccess = val;
  }

  void __set_writeAccess(const BAPA_WRITEACCESS_TYPE::type val) {
    writeAccess = val;
  }

  bool operator == (const AccessInfo & rhs) const
  {
    if (!(readAccess == rhs.readAccess))
      return false;
    if (!(writeAccess == rhs.writeAccess))
      return false;
    return true;
  }
  bool operator != (const AccessInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccessInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(AccessInfo &a, AccessInfo &b);

typedef struct _TypeInfo__isset {
  _TypeInfo__isset() : defValue(false), minValue(false), maxValue(false), resolution(false), minLength(false), maxLength(false), arrayIndex(false), stringIndex(false), unit(false), textGroup(false) {}
  bool defValue;
  bool minValue;
  bool maxValue;
  bool resolution;
  bool minLength;
  bool maxLength;
  bool arrayIndex;
  bool stringIndex;
  bool unit;
  bool textGroup;
} _TypeInfo__isset;

class TypeInfo {
 public:

  static const char* ascii_fingerprint; // = "AF0818C7C201361BB560A69DC4A4C4FF";
  static const uint8_t binary_fingerprint[16]; // = {0xAF,0x08,0x18,0xC7,0xC2,0x01,0x36,0x1B,0xB5,0x60,0xA6,0x9D,0xC4,0xA4,0xC4,0xFF};

  TypeInfo() : defValue(), minValue(), maxValue(), resolution(), minLength(0), maxLength(0), arrayIndex(0), stringIndex(0), unit(), textGroup(0) {
  }

  virtual ~TypeInfo() throw() {}

  std::string defValue;
  std::string minValue;
  std::string maxValue;
  std::string resolution;
  int32_t minLength;
  int32_t maxLength;
  int32_t arrayIndex;
  int32_t stringIndex;
  std::string unit;
  int32_t textGroup;

  _TypeInfo__isset __isset;

  void __set_defValue(const std::string& val) {
    defValue = val;
  }

  void __set_minValue(const std::string& val) {
    minValue = val;
  }

  void __set_maxValue(const std::string& val) {
    maxValue = val;
  }

  void __set_resolution(const std::string& val) {
    resolution = val;
  }

  void __set_minLength(const int32_t val) {
    minLength = val;
  }

  void __set_maxLength(const int32_t val) {
    maxLength = val;
  }

  void __set_arrayIndex(const int32_t val) {
    arrayIndex = val;
  }

  void __set_stringIndex(const int32_t val) {
    stringIndex = val;
  }

  void __set_unit(const std::string& val) {
    unit = val;
  }

  void __set_textGroup(const int32_t val) {
    textGroup = val;
  }

  bool operator == (const TypeInfo & rhs) const
  {
    if (!(defValue == rhs.defValue))
      return false;
    if (!(minValue == rhs.minValue))
      return false;
    if (!(maxValue == rhs.maxValue))
      return false;
    if (!(resolution == rhs.resolution))
      return false;
    if (!(minLength == rhs.minLength))
      return false;
    if (!(maxLength == rhs.maxLength))
      return false;
    if (!(arrayIndex == rhs.arrayIndex))
      return false;
    if (!(stringIndex == rhs.stringIndex))
      return false;
    if (!(unit == rhs.unit))
      return false;
    if (!(textGroup == rhs.textGroup))
      return false;
    return true;
  }
  bool operator != (const TypeInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TypeInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TypeInfo &a, TypeInfo &b);

typedef struct _Property_Info__isset {
  _Property_Info__isset() : data_type(false), accessInfo(false), typeInfo(false) {}
  bool data_type;
  bool accessInfo;
  bool typeInfo;
} _Property_Info__isset;

class Property_Info {
 public:

  static const char* ascii_fingerprint; // = "15E523F8C5AB8B390E1F2FB28A16D286";
  static const uint8_t binary_fingerprint[16]; // = {0x15,0xE5,0x23,0xF8,0xC5,0xAB,0x8B,0x39,0x0E,0x1F,0x2F,0xB2,0x8A,0x16,0xD2,0x86};

  Property_Info() : data_type((BA_DATA_TYPE::type)0) {
  }

  virtual ~Property_Info() throw() {}

  BA_DATA_TYPE::type data_type;
  AccessInfo accessInfo;
  TypeInfo typeInfo;

  _Property_Info__isset __isset;

  void __set_data_type(const BA_DATA_TYPE::type val) {
    data_type = val;
  }

  void __set_accessInfo(const AccessInfo& val) {
    accessInfo = val;
  }

  void __set_typeInfo(const TypeInfo& val) {
    typeInfo = val;
  }

  bool operator == (const Property_Info & rhs) const
  {
    if (!(data_type == rhs.data_type))
      return false;
    if (!(accessInfo == rhs.accessInfo))
      return false;
    if (!(typeInfo == rhs.typeInfo))
      return false;
    return true;
  }
  bool operator != (const Property_Info &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Property_Info & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Property_Info &a, Property_Info &b);

typedef struct _PropertyDesc_Info__isset {
  _PropertyDesc_Info__isset() : propertyType(false), propertyInfo(false) {}
  bool propertyType;
  bool propertyInfo;
} _PropertyDesc_Info__isset;

class PropertyDesc_Info {
 public:

  static const char* ascii_fingerprint; // = "56D24419FDA5C3858E5DB4F31B1006B6";
  static const uint8_t binary_fingerprint[16]; // = {0x56,0xD2,0x44,0x19,0xFD,0xA5,0xC3,0x85,0x8E,0x5D,0xB4,0xF3,0x1B,0x10,0x06,0xB6};

  PropertyDesc_Info() : propertyType((Property_Type::type)0) {
  }

  virtual ~PropertyDesc_Info() throw() {}

  Property_Type::type propertyType;
  Property_Info propertyInfo;

  _PropertyDesc_Info__isset __isset;

  void __set_propertyType(const Property_Type::type val) {
    propertyType = val;
  }

  void __set_propertyInfo(const Property_Info& val) {
    propertyInfo = val;
  }

  bool operator == (const PropertyDesc_Info & rhs) const
  {
    if (!(propertyType == rhs.propertyType))
      return false;
    if (!(propertyInfo == rhs.propertyInfo))
      return false;
    return true;
  }
  bool operator != (const PropertyDesc_Info &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PropertyDesc_Info & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(PropertyDesc_Info &a, PropertyDesc_Info &b);

typedef struct _Object_Id__isset {
  _Object_Id__isset() : device_instance(false), object_type(false), object_instance(false) {}
  bool device_instance;
  bool object_type;
  bool object_instance;
} _Object_Id__isset;

class Object_Id {
 public:

  static const char* ascii_fingerprint; // = "DE035C7565A0274CBA4FB0CDABB89798";
  static const uint8_t binary_fingerprint[16]; // = {0xDE,0x03,0x5C,0x75,0x65,0xA0,0x27,0x4C,0xBA,0x4F,0xB0,0xCD,0xAB,0xB8,0x97,0x98};

  Object_Id() : device_instance(0), object_type((Object_Type::type)0), object_instance(0) {
  }

  virtual ~Object_Id() throw() {}

  int32_t device_instance;
  Object_Type::type object_type;
  int32_t object_instance;

  _Object_Id__isset __isset;

  void __set_device_instance(const int32_t val) {
    device_instance = val;
  }

  void __set_object_type(const Object_Type::type val) {
    object_type = val;
  }

  void __set_object_instance(const int32_t val) {
    object_instance = val;
  }

  bool operator == (const Object_Id & rhs) const
  {
    if (!(device_instance == rhs.device_instance))
      return false;
    if (!(object_type == rhs.object_type))
      return false;
    if (!(object_instance == rhs.object_instance))
      return false;
    return true;
  }
  bool operator != (const Object_Id &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Object_Id & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Object_Id &a, Object_Id &b);

typedef struct _User__isset {
  _User__isset() : id(true), username(false), password(false), autologin(true), firstname(false), lastname(false), language(true), country(true), web_theme(true), email(false), comment(false) {}
  bool id;
  bool username;
  bool password;
  bool autologin;
  bool firstname;
  bool lastname;
  bool language;
  bool country;
  bool web_theme;
  bool email;
  bool comment;
} _User__isset;

class User {
 public:

  static const char* ascii_fingerprint; // = "3D5565560ECA89BA0D971A984FCB6ADB";
  static const uint8_t binary_fingerprint[16]; // = {0x3D,0x55,0x65,0x56,0x0E,0xCA,0x89,0xBA,0x0D,0x97,0x1A,0x98,0x4F,0xCB,0x6A,0xDB};

  User() : id(0), username(), password(), autologin(0), firstname(), lastname(), language("en"), country("US"), web_theme("siemens-2004"), email(), comment() {
  }

  virtual ~User() throw() {}

  int32_t id;
  std::string username;
  std::string password;
  int16_t autologin;
  std::string firstname;
  std::string lastname;
  std::string language;
  std::string country;
  std::string web_theme;
  std::string email;
  std::string comment;

  _User__isset __isset;

  void __set_id(const int32_t val) {
    id = val;
  }

  void __set_username(const std::string& val) {
    username = val;
  }

  void __set_password(const std::string& val) {
    password = val;
  }

  void __set_autologin(const int16_t val) {
    autologin = val;
  }

  void __set_firstname(const std::string& val) {
    firstname = val;
  }

  void __set_lastname(const std::string& val) {
    lastname = val;
  }

  void __set_language(const std::string& val) {
    language = val;
  }

  void __set_country(const std::string& val) {
    country = val;
  }

  void __set_web_theme(const std::string& val) {
    web_theme = val;
  }

  void __set_email(const std::string& val) {
    email = val;
  }

  void __set_comment(const std::string& val) {
    comment = val;
  }

  bool operator == (const User & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(username == rhs.username))
      return false;
    if (!(password == rhs.password))
      return false;
    if (!(autologin == rhs.autologin))
      return false;
    if (!(firstname == rhs.firstname))
      return false;
    if (!(lastname == rhs.lastname))
      return false;
    if (!(language == rhs.language))
      return false;
    if (!(country == rhs.country))
      return false;
    if (!(web_theme == rhs.web_theme))
      return false;
    if (!(email == rhs.email))
      return false;
    if (!(comment == rhs.comment))
      return false;
    return true;
  }
  bool operator != (const User &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const User & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(User &a, User &b);

typedef struct _FileTransferLocation__isset {
  _FileTransferLocation__isset() : name(false), path(false), localpath(false), description(false), comment(false) {}
  bool name;
  bool path;
  bool localpath;
  bool description;
  bool comment;
} _FileTransferLocation__isset;

class FileTransferLocation {
 public:

  static const char* ascii_fingerprint; // = "BFF0E21728CB005F9AA5774A41542B8D";
  static const uint8_t binary_fingerprint[16]; // = {0xBF,0xF0,0xE2,0x17,0x28,0xCB,0x00,0x5F,0x9A,0xA5,0x77,0x4A,0x41,0x54,0x2B,0x8D};

  FileTransferLocation() : name(), path(), localpath(), description(), comment() {
  }

  virtual ~FileTransferLocation() throw() {}

  std::string name;
  std::string path;
  std::string localpath;
  std::string description;
  std::string comment;

  _FileTransferLocation__isset __isset;

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_path(const std::string& val) {
    path = val;
  }

  void __set_localpath(const std::string& val) {
    localpath = val;
  }

  void __set_description(const std::string& val) {
    description = val;
  }

  void __set_comment(const std::string& val) {
    comment = val;
  }

  bool operator == (const FileTransferLocation & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(path == rhs.path))
      return false;
    if (!(localpath == rhs.localpath))
      return false;
    if (!(description == rhs.description))
      return false;
    if (!(comment == rhs.comment))
      return false;
    return true;
  }
  bool operator != (const FileTransferLocation &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const FileTransferLocation & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(FileTransferLocation &a, FileTransferLocation &b);

typedef struct _Password__isset {
  _Password__isset() : password(false), type(false) {}
  bool password;
  bool type;
} _Password__isset;

class Password {
 public:

  static const char* ascii_fingerprint; // = "D6FD826D949221396F4FFC3ECCD3D192";
  static const uint8_t binary_fingerprint[16]; // = {0xD6,0xFD,0x82,0x6D,0x94,0x92,0x21,0x39,0x6F,0x4F,0xFC,0x3E,0xCC,0xD3,0xD1,0x92};

  Password() : password(), type((PasswordType::type)0) {
  }

  virtual ~Password() throw() {}

  std::string password;
  PasswordType::type type;

  _Password__isset __isset;

  void __set_password(const std::string& val) {
    password = val;
  }

  void __set_type(const PasswordType::type val) {
    type = val;
  }

  bool operator == (const Password & rhs) const
  {
    if (!(password == rhs.password))
      return false;
    if (!(type == rhs.type))
      return false;
    return true;
  }
  bool operator != (const Password &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Password & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Password &a, Password &b);

typedef struct _Location__isset {
  _Location__isset() : name(false), description(false), password(false), home(false), systemNavigationEntries(false) {}
  bool name;
  bool description;
  bool password;
  bool home;
  bool systemNavigationEntries;
} _Location__isset;

class Location {
 public:

  static const char* ascii_fingerprint; // = "841D887883305BADAC7BA25B7B7428AE";
  static const uint8_t binary_fingerprint[16]; // = {0x84,0x1D,0x88,0x78,0x83,0x30,0x5B,0xAD,0xAC,0x7B,0xA2,0x5B,0x7B,0x74,0x28,0xAE};

  Location() : name(), description(), password() {
  }

  virtual ~Location() throw() {}

  std::string name;
  std::string description;
  std::string password;
  Object_Id home;
  std::vector<Object_Id>  systemNavigationEntries;

  _Location__isset __isset;

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_description(const std::string& val) {
    description = val;
  }

  void __set_password(const std::string& val) {
    password = val;
  }

  void __set_home(const Object_Id& val) {
    home = val;
  }

  void __set_systemNavigationEntries(const std::vector<Object_Id> & val) {
    systemNavigationEntries = val;
  }

  bool operator == (const Location & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(description == rhs.description))
      return false;
    if (!(password == rhs.password))
      return false;
    if (!(home == rhs.home))
      return false;
    if (!(systemNavigationEntries == rhs.systemNavigationEntries))
      return false;
    return true;
  }
  bool operator != (const Location &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Location & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Location &a, Location &b);

typedef struct _AuthenticationResult__isset {
  _AuthenticationResult__isset() : user(false), location(false) {}
  bool user;
  bool location;
} _AuthenticationResult__isset;

class AuthenticationResult {
 public:

  static const char* ascii_fingerprint; // = "5A1DBEF86C04C9F02A196C53D3CE8444";
  static const uint8_t binary_fingerprint[16]; // = {0x5A,0x1D,0xBE,0xF8,0x6C,0x04,0xC9,0xF0,0x2A,0x19,0x6C,0x53,0xD3,0xCE,0x84,0x44};

  AuthenticationResult() : authenticationToken() {
  }

  virtual ~AuthenticationResult() throw() {}

  std::string authenticationToken;
  User user;
  Location location;

  _AuthenticationResult__isset __isset;

  void __set_authenticationToken(const std::string& val) {
    authenticationToken = val;
  }

  void __set_user(const User& val) {
    user = val;
    __isset.user = true;
  }

  void __set_location(const Location& val) {
    location = val;
    __isset.location = true;
  }

  bool operator == (const AuthenticationResult & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    if (__isset.user != rhs.__isset.user)
      return false;
    else if (__isset.user && !(user == rhs.user))
      return false;
    if (__isset.location != rhs.__isset.location)
      return false;
    else if (__isset.location && !(location == rhs.location))
      return false;
    return true;
  }
  bool operator != (const AuthenticationResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AuthenticationResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(AuthenticationResult &a, AuthenticationResult &b);

typedef struct _Model__isset {
  _Model__isset() : locationDescription(false) {}
  bool locationDescription;
} _Model__isset;

class Model {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  Model() : locationDescription() {
  }

  virtual ~Model() throw() {}

  std::string locationDescription;

  _Model__isset __isset;

  void __set_locationDescription(const std::string& val) {
    locationDescription = val;
  }

  bool operator == (const Model & rhs) const
  {
    if (!(locationDescription == rhs.locationDescription))
      return false;
    return true;
  }
  bool operator != (const Model &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Model & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Model &a, Model &b);

typedef struct _AuthenticationLocationParameters__isset {
  _AuthenticationLocationParameters__isset() : locationName(false), password(false) {}
  bool locationName;
  bool password;
} _AuthenticationLocationParameters__isset;

class AuthenticationLocationParameters {
 public:

  static const char* ascii_fingerprint; // = "07A9615F837F7D0A952B595DD3020972";
  static const uint8_t binary_fingerprint[16]; // = {0x07,0xA9,0x61,0x5F,0x83,0x7F,0x7D,0x0A,0x95,0x2B,0x59,0x5D,0xD3,0x02,0x09,0x72};

  AuthenticationLocationParameters() : locationName(), password() {
  }

  virtual ~AuthenticationLocationParameters() throw() {}

  std::string locationName;
  std::string password;

  _AuthenticationLocationParameters__isset __isset;

  void __set_locationName(const std::string& val) {
    locationName = val;
  }

  void __set_password(const std::string& val) {
    password = val;
  }

  bool operator == (const AuthenticationLocationParameters & rhs) const
  {
    if (!(locationName == rhs.locationName))
      return false;
    if (!(password == rhs.password))
      return false;
    return true;
  }
  bool operator != (const AuthenticationLocationParameters &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AuthenticationLocationParameters & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(AuthenticationLocationParameters &a, AuthenticationLocationParameters &b);

typedef struct _UserLoginParameters__isset {
  _UserLoginParameters__isset() : UserName(false), password(false) {}
  bool UserName;
  bool password;
} _UserLoginParameters__isset;

class UserLoginParameters {
 public:

  static const char* ascii_fingerprint; // = "07A9615F837F7D0A952B595DD3020972";
  static const uint8_t binary_fingerprint[16]; // = {0x07,0xA9,0x61,0x5F,0x83,0x7F,0x7D,0x0A,0x95,0x2B,0x59,0x5D,0xD3,0x02,0x09,0x72};

  UserLoginParameters() : UserName(), password() {
  }

  virtual ~UserLoginParameters() throw() {}

  std::string UserName;
  std::string password;

  _UserLoginParameters__isset __isset;

  void __set_UserName(const std::string& val) {
    UserName = val;
  }

  void __set_password(const std::string& val) {
    password = val;
  }

  bool operator == (const UserLoginParameters & rhs) const
  {
    if (!(UserName == rhs.UserName))
      return false;
    if (!(password == rhs.password))
      return false;
    return true;
  }
  bool operator != (const UserLoginParameters &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UserLoginParameters & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(UserLoginParameters &a, UserLoginParameters &b);

typedef struct _GetModelUpdateParameters__isset {
  _GetModelUpdateParameters__isset() : keepAlive(false) {}
  bool keepAlive;
} _GetModelUpdateParameters__isset;

class GetModelUpdateParameters {
 public:

  static const char* ascii_fingerprint; // = "5892306F7B861249AE8E27C8ED619593";
  static const uint8_t binary_fingerprint[16]; // = {0x58,0x92,0x30,0x6F,0x7B,0x86,0x12,0x49,0xAE,0x8E,0x27,0xC8,0xED,0x61,0x95,0x93};

  GetModelUpdateParameters() : keepAlive(0) {
  }

  virtual ~GetModelUpdateParameters() throw() {}

  bool keepAlive;

  _GetModelUpdateParameters__isset __isset;

  void __set_keepAlive(const bool val) {
    keepAlive = val;
  }

  bool operator == (const GetModelUpdateParameters & rhs) const
  {
    if (!(keepAlive == rhs.keepAlive))
      return false;
    return true;
  }
  bool operator != (const GetModelUpdateParameters &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetModelUpdateParameters & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(GetModelUpdateParameters &a, GetModelUpdateParameters &b);

typedef struct _SelectFunctionParameters__isset {
  _SelectFunctionParameters__isset() : currentFunction(false) {}
  bool currentFunction;
} _SelectFunctionParameters__isset;

class SelectFunctionParameters {
 public:

  static const char* ascii_fingerprint; // = "8BBB3D0C3B370CB38F2D1340BB79F0AA";
  static const uint8_t binary_fingerprint[16]; // = {0x8B,0xBB,0x3D,0x0C,0x3B,0x37,0x0C,0xB3,0x8F,0x2D,0x13,0x40,0xBB,0x79,0xF0,0xAA};

  SelectFunctionParameters() : currentFunction((CoreFunction::type)0) {
  }

  virtual ~SelectFunctionParameters() throw() {}

  CoreFunction::type currentFunction;

  _SelectFunctionParameters__isset __isset;

  void __set_currentFunction(const CoreFunction::type val) {
    currentFunction = val;
  }

  bool operator == (const SelectFunctionParameters & rhs) const
  {
    if (!(currentFunction == rhs.currentFunction))
      return false;
    return true;
  }
  bool operator != (const SelectFunctionParameters &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SelectFunctionParameters & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(SelectFunctionParameters &a, SelectFunctionParameters &b);

typedef struct _SelectViewParamaters__isset {
  _SelectViewParamaters__isset() : viewId(false) {}
  bool viewId;
} _SelectViewParamaters__isset;

class SelectViewParamaters {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  SelectViewParamaters() : viewId() {
  }

  virtual ~SelectViewParamaters() throw() {}

  std::string viewId;

  _SelectViewParamaters__isset __isset;

  void __set_viewId(const std::string& val) {
    viewId = val;
  }

  bool operator == (const SelectViewParamaters & rhs) const
  {
    if (!(viewId == rhs.viewId))
      return false;
    return true;
  }
  bool operator != (const SelectViewParamaters &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SelectViewParamaters & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(SelectViewParamaters &a, SelectViewParamaters &b);

typedef struct _Commandvalue__isset {
  _Commandvalue__isset() : Discretevalue(false), Analogvalue(false) {}
  bool Discretevalue;
  bool Analogvalue;
} _Commandvalue__isset;

class Commandvalue {
 public:

  static const char* ascii_fingerprint; // = "1CD307461D05254E6B6D22C598F85F09";
  static const uint8_t binary_fingerprint[16]; // = {0x1C,0xD3,0x07,0x46,0x1D,0x05,0x25,0x4E,0x6B,0x6D,0x22,0xC5,0x98,0xF8,0x5F,0x09};

  Commandvalue() : Discretevalue(0), Analogvalue(0) {
  }

  virtual ~Commandvalue() throw() {}

  int32_t Discretevalue;
  double Analogvalue;

  _Commandvalue__isset __isset;

  void __set_Discretevalue(const int32_t val) {
    Discretevalue = val;
    __isset.Discretevalue = true;
  }

  void __set_Analogvalue(const double val) {
    Analogvalue = val;
    __isset.Analogvalue = true;
  }

  bool operator == (const Commandvalue & rhs) const
  {
    if (__isset.Discretevalue != rhs.__isset.Discretevalue)
      return false;
    else if (__isset.Discretevalue && !(Discretevalue == rhs.Discretevalue))
      return false;
    if (__isset.Analogvalue != rhs.__isset.Analogvalue)
      return false;
    else if (__isset.Analogvalue && !(Analogvalue == rhs.Analogvalue))
      return false;
    return true;
  }
  bool operator != (const Commandvalue &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Commandvalue & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Commandvalue &a, Commandvalue &b);

typedef struct _LightControlParameters__isset {
  _LightControlParameters__isset() : operation(false), value(false) {}
  bool operation;
  bool value;
} _LightControlParameters__isset;

class LightControlParameters {
 public:

  static const char* ascii_fingerprint; // = "00B53363534FC7B58834DAAFE9A17C1D";
  static const uint8_t binary_fingerprint[16]; // = {0x00,0xB5,0x33,0x63,0x53,0x4F,0xC7,0xB5,0x88,0x34,0xDA,0xAF,0xE9,0xA1,0x7C,0x1D};

  LightControlParameters() : operation((LightOperation::type)0), value(0) {
  }

  virtual ~LightControlParameters() throw() {}

  LightOperation::type operation;
  double value;

  _LightControlParameters__isset __isset;

  void __set_operation(const LightOperation::type val) {
    operation = val;
  }

  void __set_value(const double val) {
    value = val;
    __isset.value = true;
  }

  bool operator == (const LightControlParameters & rhs) const
  {
    if (!(operation == rhs.operation))
      return false;
    if (__isset.value != rhs.__isset.value)
      return false;
    else if (__isset.value && !(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const LightControlParameters &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LightControlParameters & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(LightControlParameters &a, LightControlParameters &b);

typedef struct _BlindControlParameters__isset {
  _BlindControlParameters__isset() : operation(false), height(false), angle(false), predefinedPos(false) {}
  bool operation;
  bool height;
  bool angle;
  bool predefinedPos;
} _BlindControlParameters__isset;

class BlindControlParameters {
 public:

  static const char* ascii_fingerprint; // = "505E64E7CF65D7D247CABC9C35A55E4D";
  static const uint8_t binary_fingerprint[16]; // = {0x50,0x5E,0x64,0xE7,0xCF,0x65,0xD7,0xD2,0x47,0xCA,0xBC,0x9C,0x35,0xA5,0x5E,0x4D};

  BlindControlParameters() : operation((BlindOperation::type)0), height(0), angle(0), predefinedPos(0) {
  }

  virtual ~BlindControlParameters() throw() {}

  BlindOperation::type operation;
  double height;
  double angle;
  int32_t predefinedPos;

  _BlindControlParameters__isset __isset;

  void __set_operation(const BlindOperation::type val) {
    operation = val;
  }

  void __set_height(const double val) {
    height = val;
    __isset.height = true;
  }

  void __set_angle(const double val) {
    angle = val;
    __isset.angle = true;
  }

  void __set_predefinedPos(const int32_t val) {
    predefinedPos = val;
    __isset.predefinedPos = true;
  }

  bool operator == (const BlindControlParameters & rhs) const
  {
    if (!(operation == rhs.operation))
      return false;
    if (__isset.height != rhs.__isset.height)
      return false;
    else if (__isset.height && !(height == rhs.height))
      return false;
    if (__isset.angle != rhs.__isset.angle)
      return false;
    else if (__isset.angle && !(angle == rhs.angle))
      return false;
    if (__isset.predefinedPos != rhs.__isset.predefinedPos)
      return false;
    else if (__isset.predefinedPos && !(predefinedPos == rhs.predefinedPos))
      return false;
    return true;
  }
  bool operator != (const BlindControlParameters &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BlindControlParameters & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(BlindControlParameters &a, BlindControlParameters &b);

typedef struct _CommandValueParameters__isset {
  _CommandValueParameters__isset() : elementId(false), commandvalue(false), commandValueType(false), placeableElementId(false), lightControlParameters(false), blindControlParameters(false) {}
  bool elementId;
  bool commandvalue;
  bool commandValueType;
  bool placeableElementId;
  bool lightControlParameters;
  bool blindControlParameters;
} _CommandValueParameters__isset;

class CommandValueParameters {
 public:

  static const char* ascii_fingerprint; // = "9B1D159CC19E847651795C1AD8293C7C";
  static const uint8_t binary_fingerprint[16]; // = {0x9B,0x1D,0x15,0x9C,0xC1,0x9E,0x84,0x76,0x51,0x79,0x5C,0x1A,0xD8,0x29,0x3C,0x7C};

  CommandValueParameters() : elementId(0), commandValueType((CommandValueType::type)0), placeableElementId() {
  }

  virtual ~CommandValueParameters() throw() {}

  int32_t elementId;
  Commandvalue commandvalue;
  CommandValueType::type commandValueType;
  std::string placeableElementId;
  LightControlParameters lightControlParameters;
  BlindControlParameters blindControlParameters;

  _CommandValueParameters__isset __isset;

  void __set_elementId(const int32_t val) {
    elementId = val;
    __isset.elementId = true;
  }

  void __set_commandvalue(const Commandvalue& val) {
    commandvalue = val;
    __isset.commandvalue = true;
  }

  void __set_commandValueType(const CommandValueType::type val) {
    commandValueType = val;
    __isset.commandValueType = true;
  }

  void __set_placeableElementId(const std::string& val) {
    placeableElementId = val;
    __isset.placeableElementId = true;
  }

  void __set_lightControlParameters(const LightControlParameters& val) {
    lightControlParameters = val;
    __isset.lightControlParameters = true;
  }

  void __set_blindControlParameters(const BlindControlParameters& val) {
    blindControlParameters = val;
    __isset.blindControlParameters = true;
  }

  bool operator == (const CommandValueParameters & rhs) const
  {
    if (__isset.elementId != rhs.__isset.elementId)
      return false;
    else if (__isset.elementId && !(elementId == rhs.elementId))
      return false;
    if (__isset.commandvalue != rhs.__isset.commandvalue)
      return false;
    else if (__isset.commandvalue && !(commandvalue == rhs.commandvalue))
      return false;
    if (__isset.commandValueType != rhs.__isset.commandValueType)
      return false;
    else if (__isset.commandValueType && !(commandValueType == rhs.commandValueType))
      return false;
    if (__isset.placeableElementId != rhs.__isset.placeableElementId)
      return false;
    else if (__isset.placeableElementId && !(placeableElementId == rhs.placeableElementId))
      return false;
    if (__isset.lightControlParameters != rhs.__isset.lightControlParameters)
      return false;
    else if (__isset.lightControlParameters && !(lightControlParameters == rhs.lightControlParameters))
      return false;
    if (__isset.blindControlParameters != rhs.__isset.blindControlParameters)
      return false;
    else if (__isset.blindControlParameters && !(blindControlParameters == rhs.blindControlParameters))
      return false;
    return true;
  }
  bool operator != (const CommandValueParameters &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CommandValueParameters & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(CommandValueParameters &a, CommandValueParameters &b);

typedef struct _ServerSettingParameters__isset {
  _ServerSettingParameters__isset() : languageSymbol(false), timeFormat(false), dateFormat(false), keyboardLayout(false), autoLogoutTime(false), navigBarTiOut(false), screenSaverTiOut(false) {}
  bool languageSymbol;
  bool timeFormat;
  bool dateFormat;
  bool keyboardLayout;
  bool autoLogoutTime;
  bool navigBarTiOut;
  bool screenSaverTiOut;
} _ServerSettingParameters__isset;

class ServerSettingParameters {
 public:

  static const char* ascii_fingerprint; // = "780899D8BF621CD4E9439B0D56879B06";
  static const uint8_t binary_fingerprint[16]; // = {0x78,0x08,0x99,0xD8,0xBF,0x62,0x1C,0xD4,0xE9,0x43,0x9B,0x0D,0x56,0x87,0x9B,0x06};

  ServerSettingParameters() : languageSymbol(), timeFormat((TimeFormat::type)0), dateFormat((DateFormat::type)0), keyboardLayout((KeyBoardLayout::type)0), autoLogoutTime((AutoLogoutTime::type)0), navigBarTiOut((NavigBarTiOut::type)0), screenSaverTiOut((ScreenSaverTiOut::type)0) {
  }

  virtual ~ServerSettingParameters() throw() {}

  std::string languageSymbol;
  TimeFormat::type timeFormat;
  DateFormat::type dateFormat;
  KeyBoardLayout::type keyboardLayout;
  AutoLogoutTime::type autoLogoutTime;
  NavigBarTiOut::type navigBarTiOut;
  ScreenSaverTiOut::type screenSaverTiOut;

  _ServerSettingParameters__isset __isset;

  void __set_languageSymbol(const std::string& val) {
    languageSymbol = val;
    __isset.languageSymbol = true;
  }

  void __set_timeFormat(const TimeFormat::type val) {
    timeFormat = val;
    __isset.timeFormat = true;
  }

  void __set_dateFormat(const DateFormat::type val) {
    dateFormat = val;
    __isset.dateFormat = true;
  }

  void __set_keyboardLayout(const KeyBoardLayout::type val) {
    keyboardLayout = val;
    __isset.keyboardLayout = true;
  }

  void __set_autoLogoutTime(const AutoLogoutTime::type val) {
    autoLogoutTime = val;
    __isset.autoLogoutTime = true;
  }

  void __set_navigBarTiOut(const NavigBarTiOut::type val) {
    navigBarTiOut = val;
    __isset.navigBarTiOut = true;
  }

  void __set_screenSaverTiOut(const ScreenSaverTiOut::type val) {
    screenSaverTiOut = val;
    __isset.screenSaverTiOut = true;
  }

  bool operator == (const ServerSettingParameters & rhs) const
  {
    if (__isset.languageSymbol != rhs.__isset.languageSymbol)
      return false;
    else if (__isset.languageSymbol && !(languageSymbol == rhs.languageSymbol))
      return false;
    if (__isset.timeFormat != rhs.__isset.timeFormat)
      return false;
    else if (__isset.timeFormat && !(timeFormat == rhs.timeFormat))
      return false;
    if (__isset.dateFormat != rhs.__isset.dateFormat)
      return false;
    else if (__isset.dateFormat && !(dateFormat == rhs.dateFormat))
      return false;
    if (__isset.keyboardLayout != rhs.__isset.keyboardLayout)
      return false;
    else if (__isset.keyboardLayout && !(keyboardLayout == rhs.keyboardLayout))
      return false;
    if (__isset.autoLogoutTime != rhs.__isset.autoLogoutTime)
      return false;
    else if (__isset.autoLogoutTime && !(autoLogoutTime == rhs.autoLogoutTime))
      return false;
    if (__isset.navigBarTiOut != rhs.__isset.navigBarTiOut)
      return false;
    else if (__isset.navigBarTiOut && !(navigBarTiOut == rhs.navigBarTiOut))
      return false;
    if (__isset.screenSaverTiOut != rhs.__isset.screenSaverTiOut)
      return false;
    else if (__isset.screenSaverTiOut && !(screenSaverTiOut == rhs.screenSaverTiOut))
      return false;
    return true;
  }
  bool operator != (const ServerSettingParameters &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ServerSettingParameters & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(ServerSettingParameters &a, ServerSettingParameters &b);

typedef struct _TDate__isset {
  _TDate__isset() : year(false), month(false), day(false) {}
  bool year;
  bool month;
  bool day;
} _TDate__isset;

class TDate {
 public:

  static const char* ascii_fingerprint; // = "874362235FCCF77E284413CBBBA335FE";
  static const uint8_t binary_fingerprint[16]; // = {0x87,0x43,0x62,0x23,0x5F,0xCC,0xF7,0x7E,0x28,0x44,0x13,0xCB,0xBB,0xA3,0x35,0xFE};

  TDate() : year(0), month(0), day(0) {
  }

  virtual ~TDate() throw() {}

  int16_t year;
  int8_t month;
  int8_t day;

  _TDate__isset __isset;

  void __set_year(const int16_t val) {
    year = val;
  }

  void __set_month(const int8_t val) {
    month = val;
  }

  void __set_day(const int8_t val) {
    day = val;
  }

  bool operator == (const TDate & rhs) const
  {
    if (!(year == rhs.year))
      return false;
    if (!(month == rhs.month))
      return false;
    if (!(day == rhs.day))
      return false;
    return true;
  }
  bool operator != (const TDate &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TDate & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TDate &a, TDate &b);

typedef struct _ServiceCommand__isset {
  _ServiceCommand__isset() : commandType(false), authenticateLocationParameters(false), userLoginParameters(false), getModelUpdateParameters(false), selectFunctionParameters(false), selectViewParameters(false), commandValueParameters(false), schedulerParameters(false), serverSettingParameters(false), trendParameters(false) {}
  bool commandType;
  bool authenticateLocationParameters;
  bool userLoginParameters;
  bool getModelUpdateParameters;
  bool selectFunctionParameters;
  bool selectViewParameters;
  bool commandValueParameters;
  bool schedulerParameters;
  bool serverSettingParameters;
  bool trendParameters;
} _ServiceCommand__isset;

class ServiceCommand {
 public:

  static const char* ascii_fingerprint; // = "A4A3C67348E627A83D8D710546C88307";
  static const uint8_t binary_fingerprint[16]; // = {0xA4,0xA3,0xC6,0x73,0x48,0xE6,0x27,0xA8,0x3D,0x8D,0x71,0x05,0x46,0xC8,0x83,0x07};

  ServiceCommand() : commandType((Command_Type::type)0) {
  }

  virtual ~ServiceCommand() throw() {}

  Command_Type::type commandType;
  AuthenticationLocationParameters authenticateLocationParameters;
  UserLoginParameters userLoginParameters;
  GetModelUpdateParameters getModelUpdateParameters;
  SelectFunctionParameters selectFunctionParameters;
  SelectViewParamaters selectViewParameters;
  CommandValueParameters commandValueParameters;
   ::siemens::bt::scheduler::SchedulerParameters schedulerParameters;
  ServerSettingParameters serverSettingParameters;
   ::siemens::bt::trend::TrendParameters trendParameters;

  _ServiceCommand__isset __isset;

  void __set_commandType(const Command_Type::type val) {
    commandType = val;
  }

  void __set_authenticateLocationParameters(const AuthenticationLocationParameters& val) {
    authenticateLocationParameters = val;
    __isset.authenticateLocationParameters = true;
  }

  void __set_userLoginParameters(const UserLoginParameters& val) {
    userLoginParameters = val;
    __isset.userLoginParameters = true;
  }

  void __set_getModelUpdateParameters(const GetModelUpdateParameters& val) {
    getModelUpdateParameters = val;
    __isset.getModelUpdateParameters = true;
  }

  void __set_selectFunctionParameters(const SelectFunctionParameters& val) {
    selectFunctionParameters = val;
    __isset.selectFunctionParameters = true;
  }

  void __set_selectViewParameters(const SelectViewParamaters& val) {
    selectViewParameters = val;
    __isset.selectViewParameters = true;
  }

  void __set_commandValueParameters(const CommandValueParameters& val) {
    commandValueParameters = val;
    __isset.commandValueParameters = true;
  }

  void __set_schedulerParameters(const  ::siemens::bt::scheduler::SchedulerParameters& val) {
    schedulerParameters = val;
    __isset.schedulerParameters = true;
  }

  void __set_serverSettingParameters(const ServerSettingParameters& val) {
    serverSettingParameters = val;
    __isset.serverSettingParameters = true;
  }

  void __set_trendParameters(const  ::siemens::bt::trend::TrendParameters& val) {
    trendParameters = val;
    __isset.trendParameters = true;
  }

  bool operator == (const ServiceCommand & rhs) const
  {
    if (!(commandType == rhs.commandType))
      return false;
    if (__isset.authenticateLocationParameters != rhs.__isset.authenticateLocationParameters)
      return false;
    else if (__isset.authenticateLocationParameters && !(authenticateLocationParameters == rhs.authenticateLocationParameters))
      return false;
    if (__isset.userLoginParameters != rhs.__isset.userLoginParameters)
      return false;
    else if (__isset.userLoginParameters && !(userLoginParameters == rhs.userLoginParameters))
      return false;
    if (__isset.getModelUpdateParameters != rhs.__isset.getModelUpdateParameters)
      return false;
    else if (__isset.getModelUpdateParameters && !(getModelUpdateParameters == rhs.getModelUpdateParameters))
      return false;
    if (__isset.selectFunctionParameters != rhs.__isset.selectFunctionParameters)
      return false;
    else if (__isset.selectFunctionParameters && !(selectFunctionParameters == rhs.selectFunctionParameters))
      return false;
    if (__isset.selectViewParameters != rhs.__isset.selectViewParameters)
      return false;
    else if (__isset.selectViewParameters && !(selectViewParameters == rhs.selectViewParameters))
      return false;
    if (__isset.commandValueParameters != rhs.__isset.commandValueParameters)
      return false;
    else if (__isset.commandValueParameters && !(commandValueParameters == rhs.commandValueParameters))
      return false;
    if (__isset.schedulerParameters != rhs.__isset.schedulerParameters)
      return false;
    else if (__isset.schedulerParameters && !(schedulerParameters == rhs.schedulerParameters))
      return false;
    if (__isset.serverSettingParameters != rhs.__isset.serverSettingParameters)
      return false;
    else if (__isset.serverSettingParameters && !(serverSettingParameters == rhs.serverSettingParameters))
      return false;
    if (__isset.trendParameters != rhs.__isset.trendParameters)
      return false;
    else if (__isset.trendParameters && !(trendParameters == rhs.trendParameters))
      return false;
    return true;
  }
  bool operator != (const ServiceCommand &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ServiceCommand & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(ServiceCommand &a, ServiceCommand &b);

typedef struct _Value__isset {
  _Value__isset() : boolValue(false), intValue(false), doubleValue(false), stringValue(false) {}
  bool boolValue;
  bool intValue;
  bool doubleValue;
  bool stringValue;
} _Value__isset;

class Value {
 public:

  static const char* ascii_fingerprint; // = "6BBB8001263E90C2A4941342220FEF78";
  static const uint8_t binary_fingerprint[16]; // = {0x6B,0xBB,0x80,0x01,0x26,0x3E,0x90,0xC2,0xA4,0x94,0x13,0x42,0x22,0x0F,0xEF,0x78};

  Value() : boolValue(0), intValue(0), doubleValue(0), stringValue() {
  }

  virtual ~Value() throw() {}

  bool boolValue;
  int32_t intValue;
  double doubleValue;
  std::string stringValue;

  _Value__isset __isset;

  void __set_boolValue(const bool val) {
    boolValue = val;
    __isset.boolValue = true;
  }

  void __set_intValue(const int32_t val) {
    intValue = val;
    __isset.intValue = true;
  }

  void __set_doubleValue(const double val) {
    doubleValue = val;
    __isset.doubleValue = true;
  }

  void __set_stringValue(const std::string& val) {
    stringValue = val;
    __isset.stringValue = true;
  }

  bool operator == (const Value & rhs) const
  {
    if (__isset.boolValue != rhs.__isset.boolValue)
      return false;
    else if (__isset.boolValue && !(boolValue == rhs.boolValue))
      return false;
    if (__isset.intValue != rhs.__isset.intValue)
      return false;
    else if (__isset.intValue && !(intValue == rhs.intValue))
      return false;
    if (__isset.doubleValue != rhs.__isset.doubleValue)
      return false;
    else if (__isset.doubleValue && !(doubleValue == rhs.doubleValue))
      return false;
    if (__isset.stringValue != rhs.__isset.stringValue)
      return false;
    else if (__isset.stringValue && !(stringValue == rhs.stringValue))
      return false;
    return true;
  }
  bool operator != (const Value &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Value & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Value &a, Value &b);

typedef struct _ManipulatorCommand__isset {
  _ManipulatorCommand__isset() : manipulatortype(false), attribute(false), value(false), size_index(false) {}
  bool manipulatortype;
  bool attribute;
  bool value;
  bool size_index;
} _ManipulatorCommand__isset;

class ManipulatorCommand {
 public:

  static const char* ascii_fingerprint; // = "D81B1CDEE01C42D6163926D4A502355D";
  static const uint8_t binary_fingerprint[16]; // = {0xD8,0x1B,0x1C,0xDE,0xE0,0x1C,0x42,0xD6,0x16,0x39,0x26,0xD4,0xA5,0x02,0x35,0x5D};

  ManipulatorCommand() : manipulatortype((ManipulatorType::type)0), attribute(), size_index(0) {
  }

  virtual ~ManipulatorCommand() throw() {}

  ManipulatorType::type manipulatortype;
  std::string attribute;
  Value value;
  int32_t size_index;

  _ManipulatorCommand__isset __isset;

  void __set_manipulatortype(const ManipulatorType::type val) {
    manipulatortype = val;
  }

  void __set_attribute(const std::string& val) {
    attribute = val;
    __isset.attribute = true;
  }

  void __set_value(const Value& val) {
    value = val;
    __isset.value = true;
  }

  void __set_size_index(const int32_t val) {
    size_index = val;
    __isset.size_index = true;
  }

  bool operator == (const ManipulatorCommand & rhs) const
  {
    if (!(manipulatortype == rhs.manipulatortype))
      return false;
    if (__isset.attribute != rhs.__isset.attribute)
      return false;
    else if (__isset.attribute && !(attribute == rhs.attribute))
      return false;
    if (__isset.value != rhs.__isset.value)
      return false;
    else if (__isset.value && !(value == rhs.value))
      return false;
    if (__isset.size_index != rhs.__isset.size_index)
      return false;
    else if (__isset.size_index && !(size_index == rhs.size_index))
      return false;
    return true;
  }
  bool operator != (const ManipulatorCommand &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ManipulatorCommand & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(ManipulatorCommand &a, ManipulatorCommand &b);

typedef struct _ModelUpdate__isset {
  _ModelUpdate__isset() : viewstate(false), updateinstruction(false) {}
  bool viewstate;
  bool updateinstruction;
} _ModelUpdate__isset;

class ModelUpdate {
 public:

  static const char* ascii_fingerprint; // = "552FD285AC4A1FC6A540FF03A0348B00";
  static const uint8_t binary_fingerprint[16]; // = {0x55,0x2F,0xD2,0x85,0xAC,0x4A,0x1F,0xC6,0xA5,0x40,0xFF,0x03,0xA0,0x34,0x8B,0x00};

  ModelUpdate() : viewstate() {
  }

  virtual ~ModelUpdate() throw() {}

  std::string viewstate;
  std::vector<ManipulatorCommand>  updateinstruction;

  _ModelUpdate__isset __isset;

  void __set_viewstate(const std::string& val) {
    viewstate = val;
  }

  void __set_updateinstruction(const std::vector<ManipulatorCommand> & val) {
    updateinstruction = val;
  }

  bool operator == (const ModelUpdate & rhs) const
  {
    if (!(viewstate == rhs.viewstate))
      return false;
    if (!(updateinstruction == rhs.updateinstruction))
      return false;
    return true;
  }
  bool operator != (const ModelUpdate &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ModelUpdate & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(ModelUpdate &a, ModelUpdate &b);

typedef struct _LogRecord__isset {
  _LogRecord__isset() : timeStamp(false), value(false) {}
  bool timeStamp;
  bool value;
} _LogRecord__isset;

class LogRecord {
 public:

  static const char* ascii_fingerprint; // = "0B663F1913C9C6F43150B524A8B76386";
  static const uint8_t binary_fingerprint[16]; // = {0x0B,0x66,0x3F,0x19,0x13,0xC9,0xC6,0xF4,0x31,0x50,0xB5,0x24,0xA8,0xB7,0x63,0x86};

  LogRecord() : timeStamp(0), value(0) {
  }

  virtual ~LogRecord() throw() {}

  int32_t timeStamp;
  double value;

  _LogRecord__isset __isset;

  void __set_timeStamp(const int32_t val) {
    timeStamp = val;
  }

  void __set_value(const double val) {
    value = val;
  }

  bool operator == (const LogRecord & rhs) const
  {
    if (!(timeStamp == rhs.timeStamp))
      return false;
    if (!(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const LogRecord &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LogRecord & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(LogRecord &a, LogRecord &b);

typedef struct _ServiceResult__isset {
  _ServiceResult__isset() : newSessionId(false), resultCode(false), modelUpdate(false), result(false), logRecord(false), schedulerResult(false) {}
  bool newSessionId;
  bool resultCode;
  bool modelUpdate;
  bool result;
  bool logRecord;
  bool schedulerResult;
} _ServiceResult__isset;

class ServiceResult {
 public:

  static const char* ascii_fingerprint; // = "47CD577EC855CBB76DE0010DE5D8B9B3";
  static const uint8_t binary_fingerprint[16]; // = {0x47,0xCD,0x57,0x7E,0xC8,0x55,0xCB,0xB7,0x6D,0xE0,0x01,0x0D,0xE5,0xD8,0xB9,0xB3};

  ServiceResult() : newSessionId(), resultCode((Result_Code::type)0) {
  }

  virtual ~ServiceResult() throw() {}

  std::string newSessionId;
  Result_Code::type resultCode;
  ModelUpdate modelUpdate;
  std::vector<Value>  result;
  std::vector<LogRecord>  logRecord;
   ::siemens::bt::scheduler::SchedulerResult schedulerResult;

  _ServiceResult__isset __isset;

  void __set_newSessionId(const std::string& val) {
    newSessionId = val;
    __isset.newSessionId = true;
  }

  void __set_resultCode(const Result_Code::type val) {
    resultCode = val;
  }

  void __set_modelUpdate(const ModelUpdate& val) {
    modelUpdate = val;
    __isset.modelUpdate = true;
  }

  void __set_result(const std::vector<Value> & val) {
    result = val;
    __isset.result = true;
  }

  void __set_logRecord(const std::vector<LogRecord> & val) {
    logRecord = val;
    __isset.logRecord = true;
  }

  void __set_schedulerResult(const  ::siemens::bt::scheduler::SchedulerResult& val) {
    schedulerResult = val;
    __isset.schedulerResult = true;
  }

  bool operator == (const ServiceResult & rhs) const
  {
    if (__isset.newSessionId != rhs.__isset.newSessionId)
      return false;
    else if (__isset.newSessionId && !(newSessionId == rhs.newSessionId))
      return false;
    if (!(resultCode == rhs.resultCode))
      return false;
    if (__isset.modelUpdate != rhs.__isset.modelUpdate)
      return false;
    else if (__isset.modelUpdate && !(modelUpdate == rhs.modelUpdate))
      return false;
    if (__isset.result != rhs.__isset.result)
      return false;
    else if (__isset.result && !(result == rhs.result))
      return false;
    if (__isset.logRecord != rhs.__isset.logRecord)
      return false;
    else if (__isset.logRecord && !(logRecord == rhs.logRecord))
      return false;
    if (__isset.schedulerResult != rhs.__isset.schedulerResult)
      return false;
    else if (__isset.schedulerResult && !(schedulerResult == rhs.schedulerResult))
      return false;
    return true;
  }
  bool operator != (const ServiceResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ServiceResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(ServiceResult &a, ServiceResult &b);

}}} // namespace

#endif
