/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "DICP_types.h"

#include <algorithm>

namespace dicp {

int _kIfAddrModeValues[] = {
  IfAddrMode::DHCP,
  IfAddrMode::STATIC,
  IfAddrMode::IFAM_AnyOrDummyValue
};
const char* _kIfAddrModeNames[] = {
  "DHCP",
  "STATIC",
  "IFAM_AnyOrDummyValue"
};
const std::map<int, const char*> _IfAddrMode_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kIfAddrModeValues, _kIfAddrModeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kPasswordTypeValues[] = {
  PasswordType::PW_MD5,
  PasswordType::PW_PLAIN
};
const char* _kPasswordTypeNames[] = {
  "PW_MD5",
  "PW_PLAIN"
};
const std::map<int, const char*> _PasswordType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kPasswordTypeValues, _kPasswordTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kIdentificationReasonValues[] = {
  IdentificationReason::SEARCH_RESPONSE,
  IdentificationReason::PIN_PRESSED,
  IdentificationReason::CONFIG_CHANGE,
  IdentificationReason::PASSWORD_SET,
  IdentificationReason::PASSWORD_SET_FAILED,
  IdentificationReason::AUTHENTICATION_FAILED,
  IdentificationReason::CONFIGURING,
  IdentificationReason::UNCONFIGURING,
  IdentificationReason::RESTARTING,
  IdentificationReason::TIME_SET,
  IdentificationReason::WINK_RESPONSE,
  IdentificationReason::IDRE_AnyOrDummyValue
};
const char* _kIdentificationReasonNames[] = {
  "SEARCH_RESPONSE",
  "PIN_PRESSED",
  "CONFIG_CHANGE",
  "PASSWORD_SET",
  "PASSWORD_SET_FAILED",
  "AUTHENTICATION_FAILED",
  "CONFIGURING",
  "UNCONFIGURING",
  "RESTARTING",
  "TIME_SET",
  "WINK_RESPONSE",
  "IDRE_AnyOrDummyValue"
};
const std::map<int, const char*> _IdentificationReason_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(12, _kIdentificationReasonValues, _kIdentificationReasonNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

const char* DevIdent::ascii_fingerprint = "07A9615F837F7D0A952B595DD3020972";
const uint8_t DevIdent::binary_fingerprint[16] = {0x07,0xA9,0x61,0x5F,0x83,0x7F,0x7D,0x0A,0x95,0x2B,0x59,0x5D,0xD3,0x02,0x09,0x72};

uint32_t DevIdent::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->serNr);
          this->__isset.serNr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->modelNam);
          this->__isset.modelNam = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DevIdent::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("DevIdent");

  xfer += oprot->writeFieldBegin("serNr", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->serNr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("modelNam", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->modelNam);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DevIdent &a, DevIdent &b) {
  using ::std::swap;
  swap(a.serNr, b.serNr);
  swap(a.modelNam, b.modelNam);
  swap(a.__isset, b.__isset);
}

const char* BaDevData::ascii_fingerprint = "79868449BC2824A90EDE820408B8453E";
const uint8_t BaDevData::binary_fingerprint[16] = {0x79,0x86,0x84,0x49,0xBC,0x28,0x24,0xA9,0x0E,0xDE,0x82,0x04,0x08,0xB8,0x45,0x3E};

uint32_t BaDevData::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->deviceInst);
          this->__isset.deviceInst = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->deviceName);
          this->__isset.deviceName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->deviceStatus);
          this->__isset.deviceStatus = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->deviceVersion);
          this->__isset.deviceVersion = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->deviceAddr);
          this->__isset.deviceAddr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BaDevData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("BaDevData");

  xfer += oprot->writeFieldBegin("deviceInst", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->deviceInst);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deviceName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->deviceName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deviceStatus", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->deviceStatus);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deviceVersion", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->deviceVersion);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deviceAddr", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->deviceAddr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BaDevData &a, BaDevData &b) {
  using ::std::swap;
  swap(a.deviceInst, b.deviceInst);
  swap(a.deviceName, b.deviceName);
  swap(a.deviceStatus, b.deviceStatus);
  swap(a.deviceVersion, b.deviceVersion);
  swap(a.deviceAddr, b.deviceAddr);
  swap(a.__isset, b.__isset);
}

const char* URIData::ascii_fingerprint = "5B708A954C550ECA9C1A49D3C5CAFAB9";
const uint8_t URIData::binary_fingerprint[16] = {0x5B,0x70,0x8A,0x95,0x4C,0x55,0x0E,0xCA,0x9C,0x1A,0x49,0xD3,0xC5,0xCA,0xFA,0xB9};

uint32_t URIData::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->uriBase);
          this->__isset.uriBase = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->uriPath);
          this->__isset.uriPath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t URIData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("URIData");

  xfer += oprot->writeFieldBegin("uriBase", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->uriBase);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.uriPath) {
    xfer += oprot->writeFieldBegin("uriPath", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->uriPath);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(URIData &a, URIData &b) {
  using ::std::swap;
  swap(a.uriBase, b.uriBase);
  swap(a.uriPath, b.uriPath);
  swap(a.__isset, b.__isset);
}

const char* DevInfo::ascii_fingerprint = "D0297FC5011701BD87898CC36146A565";
const uint8_t DevInfo::binary_fingerprint[16] = {0xD0,0x29,0x7F,0xC5,0x01,0x17,0x01,0xBD,0x87,0x89,0x8C,0xC3,0x61,0x46,0xA5,0x65};

uint32_t DevInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->deviceDescr);
          this->__isset.deviceDescr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->location);
          this->__isset.location = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DevInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("DevInfo");

  if (this->__isset.deviceDescr) {
    xfer += oprot->writeFieldBegin("deviceDescr", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->deviceDescr);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.location) {
    xfer += oprot->writeFieldBegin("location", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->location);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DevInfo &a, DevInfo &b) {
  using ::std::swap;
  swap(a.deviceDescr, b.deviceDescr);
  swap(a.location, b.location);
  swap(a.__isset, b.__isset);
}

const char* BaDev::ascii_fingerprint = "70563A0628F75DF9555F4D24690B1E26";
const uint8_t BaDev::binary_fingerprint[16] = {0x70,0x56,0x3A,0x06,0x28,0xF7,0x5D,0xF9,0x55,0x5F,0x4D,0x24,0x69,0x0B,0x1E,0x26};

uint32_t BaDev::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->pidref);
          this->__isset.pidref = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->deviceInst);
          this->__isset.deviceInst = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->deviceName);
          this->__isset.deviceName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BaDev::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("BaDev");

  xfer += oprot->writeFieldBegin("pidref", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->pidref);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deviceInst", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->deviceInst);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deviceName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->deviceName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BaDev &a, BaDev &b) {
  using ::std::swap;
  swap(a.pidref, b.pidref);
  swap(a.deviceInst, b.deviceInst);
  swap(a.deviceName, b.deviceName);
  swap(a.__isset, b.__isset);
}

const char* BaPar::ascii_fingerprint = "346A7F6D77695CA92963E099D40206BB";
const uint8_t BaPar::binary_fingerprint[16] = {0x34,0x6A,0x7F,0x6D,0x77,0x69,0x5C,0xA9,0x29,0x63,0xE0,0x99,0xD4,0x02,0x06,0xBB};

uint32_t BaPar::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxAPDU);
          this->__isset.maxAPDU = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->aPDUTout);
          this->__isset.aPDUTout = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->retries);
          this->__isset.retries = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->segSupp);
          this->__isset.segSupp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->segTout);
          this->__isset.segTout = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxWind);
          this->__isset.maxWind = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxSegAcc);
          this->__isset.maxSegAcc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BaPar::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("BaPar");

  xfer += oprot->writeFieldBegin("maxAPDU", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->maxAPDU);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("aPDUTout", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->aPDUTout);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("retries", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->retries);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("segSupp", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->segSupp);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.segTout) {
    xfer += oprot->writeFieldBegin("segTout", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->segTout);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.maxWind) {
    xfer += oprot->writeFieldBegin("maxWind", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32(this->maxWind);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.maxSegAcc) {
    xfer += oprot->writeFieldBegin("maxSegAcc", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32(this->maxSegAcc);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BaPar &a, BaPar &b) {
  using ::std::swap;
  swap(a.maxAPDU, b.maxAPDU);
  swap(a.aPDUTout, b.aPDUTout);
  swap(a.retries, b.retries);
  swap(a.segSupp, b.segSupp);
  swap(a.segTout, b.segTout);
  swap(a.maxWind, b.maxWind);
  swap(a.maxSegAcc, b.maxSegAcc);
  swap(a.__isset, b.__isset);
}

const char* BaNw::ascii_fingerprint = "4C26CA8CF7DEAA144AEF359471B9AEA6";
const uint8_t BaNw::binary_fingerprint[16] = {0x4C,0x26,0xCA,0x8C,0xF7,0xDE,0xAA,0x14,0x4A,0xEF,0x35,0x94,0x71,0xB9,0xAE,0xA6};

uint32_t BaNw::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->nwKind);
          this->__isset.nwKind = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxPorts);
          this->__isset.maxPorts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BaNw::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("BaNw");

  if (this->__isset.nwKind) {
    xfer += oprot->writeFieldBegin("nwKind", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->nwKind);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("maxPorts", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->maxPorts);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BaNw &a, BaNw &b) {
  using ::std::swap;
  swap(a.nwKind, b.nwKind);
  swap(a.maxPorts, b.maxPorts);
  swap(a.__isset, b.__isset);
}

const char* BDTEntry::ascii_fingerprint = "614DB859ACF17855F9BC7D08DDD7B32A";
const uint8_t BDTEntry::binary_fingerprint[16] = {0x61,0x4D,0xB8,0x59,0xAC,0xF1,0x78,0x55,0xF9,0xBC,0x7D,0x08,0xDD,0xD7,0xB3,0x2A};

uint32_t BDTEntry::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ipAddr);
          this->__isset.ipAddr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->udpPort);
          this->__isset.udpPort = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->bdmask);
          this->__isset.bdmask = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BDTEntry::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("BDTEntry");

  xfer += oprot->writeFieldBegin("ipAddr", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->ipAddr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("udpPort", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->udpPort);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.bdmask) {
    xfer += oprot->writeFieldBegin("bdmask", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->bdmask);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BDTEntry &a, BDTEntry &b) {
  using ::std::swap;
  swap(a.ipAddr, b.ipAddr);
  swap(a.udpPort, b.udpPort);
  swap(a.bdmask, b.bdmask);
  swap(a.__isset, b.__isset);
}

const char* FDTEntry::ascii_fingerprint = "28C2ECC89260BADB9C70330FBF47BFA8";
const uint8_t FDTEntry::binary_fingerprint[16] = {0x28,0xC2,0xEC,0xC8,0x92,0x60,0xBA,0xDB,0x9C,0x70,0x33,0x0F,0xBF,0x47,0xBF,0xA8};

uint32_t FDTEntry::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ipAddr);
          this->__isset.ipAddr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->udpPort);
          this->__isset.udpPort = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ttl);
          this->__isset.ttl = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FDTEntry::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("FDTEntry");

  xfer += oprot->writeFieldBegin("ipAddr", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->ipAddr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("udpPort", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->udpPort);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ttl", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->ttl);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FDTEntry &a, FDTEntry &b) {
  using ::std::swap;
  swap(a.ipAddr, b.ipAddr);
  swap(a.udpPort, b.udpPort);
  swap(a.ttl, b.ttl);
  swap(a.__isset, b.__isset);
}

const char* BDT::ascii_fingerprint = "9F2B54432A3C837E9DEB0E7C4F2255AD";
const uint8_t BDT::binary_fingerprint[16] = {0x9F,0x2B,0x54,0x43,0x2A,0x3C,0x83,0x7E,0x9D,0xEB,0x0E,0x7C,0x4F,0x22,0x55,0xAD};

uint32_t BDT::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxEntries);
          this->__isset.maxEntries = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->entry.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _etype3;
            xfer += iprot->readListBegin(_etype3, _size0);
            this->entry.resize(_size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              xfer += this->entry[_i4].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.entry = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->natPubIP);
          this->__isset.natPubIP = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BDT::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("BDT");

  xfer += oprot->writeFieldBegin("maxEntries", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->maxEntries);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.entry) {
    xfer += oprot->writeFieldBegin("entry", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->entry.size()));
      std::vector<BDTEntry> ::const_iterator _iter5;
      for (_iter5 = this->entry.begin(); _iter5 != this->entry.end(); ++_iter5)
      {
        xfer += (*_iter5).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.natPubIP) {
    xfer += oprot->writeFieldBegin("natPubIP", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->natPubIP);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BDT &a, BDT &b) {
  using ::std::swap;
  swap(a.maxEntries, b.maxEntries);
  swap(a.entry, b.entry);
  swap(a.natPubIP, b.natPubIP);
  swap(a.__isset, b.__isset);
}

const char* FDT::ascii_fingerprint = "06A5B0433A1EB98667E34D4E311717F9";
const uint8_t FDT::binary_fingerprint[16] = {0x06,0xA5,0xB0,0x43,0x3A,0x1E,0xB9,0x86,0x67,0xE3,0x4D,0x4E,0x31,0x17,0x17,0xF9};

uint32_t FDT::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxEntries);
          this->__isset.maxEntries = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->entry.clear();
            uint32_t _size6;
            ::apache::thrift::protocol::TType _etype9;
            xfer += iprot->readListBegin(_etype9, _size6);
            this->entry.resize(_size6);
            uint32_t _i10;
            for (_i10 = 0; _i10 < _size6; ++_i10)
            {
              xfer += this->entry[_i10].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.entry = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FDT::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("FDT");

  xfer += oprot->writeFieldBegin("maxEntries", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->maxEntries);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.entry) {
    xfer += oprot->writeFieldBegin("entry", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->entry.size()));
      std::vector<FDTEntry> ::const_iterator _iter11;
      for (_iter11 = this->entry.begin(); _iter11 != this->entry.end(); ++_iter11)
      {
        xfer += (*_iter11).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FDT &a, FDT &b) {
  using ::std::swap;
  swap(a.maxEntries, b.maxEntries);
  swap(a.entry, b.entry);
  swap(a.__isset, b.__isset);
}

const char* IPport::ascii_fingerprint = "98760954BB314A5352394FAC6C2E7711";
const uint8_t IPport::binary_fingerprint[16] = {0x98,0x76,0x09,0x54,0xBB,0x31,0x4A,0x53,0x52,0x39,0x4F,0xAC,0x6C,0x2E,0x77,0x11};

uint32_t IPport::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->pid);
          this->__isset.pid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nwRef);
          this->__isset.nwRef = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->nwNb);
          this->__isset.nwNb = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->udpPort);
          this->__isset.udpPort = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->bdt.read(iprot);
          this->__isset.bdt = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->fdt.read(iprot);
          this->__isset.fdt = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->fd.read(iprot);
          this->__isset.fd = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t IPport::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("IPport");

  xfer += oprot->writeFieldBegin("pid", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->pid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nwRef", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->nwRef);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nwNb", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->nwNb);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("udpPort", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->udpPort);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.bdt) {
    xfer += oprot->writeFieldBegin("bdt", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->bdt.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.fdt) {
    xfer += oprot->writeFieldBegin("fdt", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->fdt.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.fd) {
    xfer += oprot->writeFieldBegin("fd", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->fd.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(IPport &a, IPport &b) {
  using ::std::swap;
  swap(a.pid, b.pid);
  swap(a.nwRef, b.nwRef);
  swap(a.nwNb, b.nwNb);
  swap(a.udpPort, b.udpPort);
  swap(a.bdt, b.bdt);
  swap(a.fdt, b.fdt);
  swap(a.fd, b.fd);
  swap(a.__isset, b.__isset);
}

const char* MSTPport::ascii_fingerprint = "4ED39C857B9DD695D18E48009F4AF499";
const uint8_t MSTPport::binary_fingerprint[16] = {0x4E,0xD3,0x9C,0x85,0x7B,0x9D,0xD6,0x95,0xD1,0x8E,0x48,0x00,0x9F,0x4A,0xF4,0x99};

uint32_t MSTPport::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->pid);
          this->__isset.pid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nwRef);
          this->__isset.nwRef = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->nwNb);
          this->__isset.nwNb = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->addr);
          this->__isset.addr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxInfo);
          this->__isset.maxInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxMaster);
          this->__isset.maxMaster = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->slvP);
          this->__isset.slvP = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MSTPport::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("MSTPport");

  xfer += oprot->writeFieldBegin("pid", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->pid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nwRef", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->nwRef);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nwNb", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->nwNb);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->addr);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.maxInfo) {
    xfer += oprot->writeFieldBegin("maxInfo", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->maxInfo);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.maxMaster) {
    xfer += oprot->writeFieldBegin("maxMaster", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32(this->maxMaster);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.slvP) {
    xfer += oprot->writeFieldBegin("slvP", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32(this->slvP);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MSTPport &a, MSTPport &b) {
  using ::std::swap;
  swap(a.pid, b.pid);
  swap(a.nwRef, b.nwRef);
  swap(a.nwNb, b.nwNb);
  swap(a.addr, b.addr);
  swap(a.maxInfo, b.maxInfo);
  swap(a.maxMaster, b.maxMaster);
  swap(a.slvP, b.slvP);
  swap(a.__isset, b.__isset);
}

const char* LONport::ascii_fingerprint = "E6FC066BE76647B97F15E30B9E15D953";
const uint8_t LONport::binary_fingerprint[16] = {0xE6,0xFC,0x06,0x6B,0xE7,0x66,0x47,0xB9,0x7F,0x15,0xE3,0x0B,0x9E,0x15,0xD9,0x53};

uint32_t LONport::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->pid);
          this->__isset.pid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nwRef);
          this->__isset.nwRef = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->nwNb);
          this->__isset.nwNb = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->domain);
          this->__isset.domain = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->channel);
          this->__isset.channel = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->subnet);
          this->__isset.subnet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->node);
          this->__isset.node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t LONport::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("LONport");

  xfer += oprot->writeFieldBegin("pid", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->pid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nwRef", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->nwRef);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nwNb", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->nwNb);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("domain", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->domain);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("channel", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->channel);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("subnet", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->subnet);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("node", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->node);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LONport &a, LONport &b) {
  using ::std::swap;
  swap(a.pid, b.pid);
  swap(a.nwRef, b.nwRef);
  swap(a.nwNb, b.nwNb);
  swap(a.domain, b.domain);
  swap(a.channel, b.channel);
  swap(a.subnet, b.subnet);
  swap(a.node, b.node);
  swap(a.__isset, b.__isset);
}

const char* BaPort::ascii_fingerprint = "446FDDEB2E2BE72282BCBD264F199244";
const uint8_t BaPort::binary_fingerprint[16] = {0x44,0x6F,0xDD,0xEB,0x2E,0x2B,0xE7,0x22,0x82,0xBC,0xBD,0x26,0x4F,0x19,0x92,0x44};

uint32_t BaPort::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ip.read(iprot);
          this->__isset.ip = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->mstp.read(iprot);
          this->__isset.mstp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->lon.read(iprot);
          this->__isset.lon = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BaPort::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("BaPort");

  if (this->__isset.ip) {
    xfer += oprot->writeFieldBegin("ip", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ip.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.mstp) {
    xfer += oprot->writeFieldBegin("mstp", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->mstp.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.lon) {
    xfer += oprot->writeFieldBegin("lon", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->lon.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BaPort &a, BaPort &b) {
  using ::std::swap;
  swap(a.ip, b.ip);
  swap(a.mstp, b.mstp);
  swap(a.lon, b.lon);
  swap(a.__isset, b.__isset);
}

const char* Lan::ascii_fingerprint = "60FCBF422C85117D3131505EDC1C08B8";
const uint8_t Lan::binary_fingerprint[16] = {0x60,0xFC,0xBF,0x42,0x2C,0x85,0x11,0x7D,0x31,0x31,0x50,0x5E,0xDC,0x1C,0x08,0xB8};

uint32_t Lan::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nwID);
          this->__isset.nwID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ifMode);
          this->__isset.ifMode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ipAddr);
          this->__isset.ipAddr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->netmask);
          this->__isset.netmask = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->gtWay);
          this->__isset.gtWay = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->type);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->macAddr);
          this->__isset.macAddr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Lan::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Lan");

  xfer += oprot->writeFieldBegin("nwID", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->nwID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ifMode", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->ifMode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ipAddr", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->ipAddr);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.netmask) {
    xfer += oprot->writeFieldBegin("netmask", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->netmask);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.gtWay) {
    xfer += oprot->writeFieldBegin("gtWay", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->gtWay);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.type) {
    xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.macAddr) {
    xfer += oprot->writeFieldBegin("macAddr", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->macAddr);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Lan &a, Lan &b) {
  using ::std::swap;
  swap(a.nwID, b.nwID);
  swap(a.ifMode, b.ifMode);
  swap(a.ipAddr, b.ipAddr);
  swap(a.netmask, b.netmask);
  swap(a.gtWay, b.gtWay);
  swap(a.type, b.type);
  swap(a.macAddr, b.macAddr);
  swap(a.__isset, b.__isset);
}

const char* Rs485::ascii_fingerprint = "614DB859ACF17855F9BC7D08DDD7B32A";
const uint8_t Rs485::binary_fingerprint[16] = {0x61,0x4D,0xB8,0x59,0xAC,0xF1,0x78,0x55,0xF9,0xBC,0x7D,0x08,0xDD,0xD7,0xB3,0x2A};

uint32_t Rs485::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nwID);
          this->__isset.nwID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->baudRate);
          this->__isset.baudRate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->type);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Rs485::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Rs485");

  xfer += oprot->writeFieldBegin("nwID", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->nwID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("baudRate", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->baudRate);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.type) {
    xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->type);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Rs485 &a, Rs485 &b) {
  using ::std::swap;
  swap(a.nwID, b.nwID);
  swap(a.baudRate, b.baudRate);
  swap(a.type, b.type);
  swap(a.__isset, b.__isset);
}

const char* Eia709::ascii_fingerprint = "4BF81DD46A7371532E49811022D58D36";
const uint8_t Eia709::binary_fingerprint[16] = {0x4B,0xF8,0x1D,0xD4,0x6A,0x73,0x71,0x53,0x2E,0x49,0x81,0x10,0x22,0xD5,0x8D,0x36};

uint32_t Eia709::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nwID);
          this->__isset.nwID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->type);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->neuronId);
          this->__isset.neuronId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Eia709::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Eia709");

  xfer += oprot->writeFieldBegin("nwID", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->nwID);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.type) {
    xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.neuronId) {
    xfer += oprot->writeFieldBegin("neuronId", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->neuronId);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Eia709 &a, Eia709 &b) {
  using ::std::swap;
  swap(a.nwID, b.nwID);
  swap(a.type, b.type);
  swap(a.neuronId, b.neuronId);
  swap(a.__isset, b.__isset);
}

const char* NwItf::ascii_fingerprint = "880310AF397DF8B6FA3032F13AE3571E";
const uint8_t NwItf::binary_fingerprint[16] = {0x88,0x03,0x10,0xAF,0x39,0x7D,0xF8,0xB6,0xFA,0x30,0x32,0xF1,0x3A,0xE3,0x57,0x1E};

uint32_t NwItf::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->lanItf.read(iprot);
          this->__isset.lanItf = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->rs485Itf.read(iprot);
          this->__isset.rs485Itf = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->eiaItf.read(iprot);
          this->__isset.eiaItf = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NwItf::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("NwItf");

  if (this->__isset.lanItf) {
    xfer += oprot->writeFieldBegin("lanItf", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->lanItf.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.rs485Itf) {
    xfer += oprot->writeFieldBegin("rs485Itf", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->rs485Itf.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.eiaItf) {
    xfer += oprot->writeFieldBegin("eiaItf", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->eiaItf.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NwItf &a, NwItf &b) {
  using ::std::swap;
  swap(a.lanItf, b.lanItf);
  swap(a.rs485Itf, b.rs485Itf);
  swap(a.eiaItf, b.eiaItf);
  swap(a.__isset, b.__isset);
}

const char* TimeSet::ascii_fingerprint = "18B162B1D15D8D46509D3911A9F1C2AA";
const uint8_t TimeSet::binary_fingerprint[16] = {0x18,0xB1,0x62,0xB1,0xD1,0x5D,0x8D,0x46,0x50,0x9D,0x39,0x11,0xA9,0xF1,0xC2,0xAA};

uint32_t TimeSet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tz);
          this->__isset.tz = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uTCOffs);
          this->__isset.uTCOffs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TimeSet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TimeSet");

  xfer += oprot->writeFieldBegin("tz", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->tz);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.uTCOffs) {
    xfer += oprot->writeFieldBegin("uTCOffs", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->uTCOffs);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TimeSet &a, TimeSet &b) {
  using ::std::swap;
  swap(a.tz, b.tz);
  swap(a.uTCOffs, b.uTCOffs);
  swap(a.__isset, b.__isset);
}

const char* DiscoverServiceData::ascii_fingerprint = "AB879940BD15B6B25691265F7384B271";
const uint8_t DiscoverServiceData::binary_fingerprint[16] = {0xAB,0x87,0x99,0x40,0xBD,0x15,0xB6,0xB2,0x56,0x91,0x26,0x5F,0x73,0x84,0xB2,0x71};

uint32_t DiscoverServiceData::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authToken);
          this->__isset.authToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->origin);
          this->__isset.origin = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->scopeFilter);
          this->__isset.scopeFilter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DiscoverServiceData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("DiscoverServiceData");

  xfer += oprot->writeFieldBegin("authToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("origin", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->origin);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("scopeFilter", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->scopeFilter);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DiscoverServiceData &a, DiscoverServiceData &b) {
  using ::std::swap;
  swap(a.authToken, b.authToken);
  swap(a.origin, b.origin);
  swap(a.scopeFilter, b.scopeFilter);
  swap(a.__isset, b.__isset);
}

const char* WinkServiceData::ascii_fingerprint = "AB879940BD15B6B25691265F7384B271";
const uint8_t WinkServiceData::binary_fingerprint[16] = {0xAB,0x87,0x99,0x40,0xBD,0x15,0xB6,0xB2,0x56,0x91,0x26,0x5F,0x73,0x84,0xB2,0x71};

uint32_t WinkServiceData::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authToken);
          this->__isset.authToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->origin);
          this->__isset.origin = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->scopeFilter);
          this->__isset.scopeFilter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WinkServiceData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("WinkServiceData");

  xfer += oprot->writeFieldBegin("authToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("origin", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->origin);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("scopeFilter", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->scopeFilter);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WinkServiceData &a, WinkServiceData &b) {
  using ::std::swap;
  swap(a.authToken, b.authToken);
  swap(a.origin, b.origin);
  swap(a.scopeFilter, b.scopeFilter);
  swap(a.__isset, b.__isset);
}

const char* IdentificationServiceData::ascii_fingerprint = "1E4772ECE87829D5259083813D940D71";
const uint8_t IdentificationServiceData::binary_fingerprint[16] = {0x1E,0x47,0x72,0xEC,0xE8,0x78,0x29,0xD5,0x25,0x90,0x83,0x81,0x3D,0x94,0x0D,0x71};

uint32_t IdentificationServiceData::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authToken);
          this->__isset.authToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->origin);
          this->__isset.origin = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->reason);
          this->__isset.reason = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->devIdent.read(iprot);
          this->__isset.devIdent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->baDev.read(iprot);
          this->__isset.baDev = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->devInfo.read(iprot);
          this->__isset.devInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->lanItf.read(iprot);
          this->__isset.lanItf = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->rs485Itf.read(iprot);
          this->__isset.rs485Itf = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->uridata.read(iprot);
          this->__isset.uridata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->utctime);
          this->__isset.utctime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t IdentificationServiceData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("IdentificationServiceData");

  xfer += oprot->writeFieldBegin("authToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("origin", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->origin);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("reason", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->reason);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devIdent", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->devIdent.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("baDev", ::apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->baDev.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.devInfo) {
    xfer += oprot->writeFieldBegin("devInfo", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->devInfo.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.lanItf) {
    xfer += oprot->writeFieldBegin("lanItf", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->lanItf.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.rs485Itf) {
    xfer += oprot->writeFieldBegin("rs485Itf", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->rs485Itf.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.uridata) {
    xfer += oprot->writeFieldBegin("uridata", ::apache::thrift::protocol::T_STRUCT, 9);
    xfer += this->uridata.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.utctime) {
    xfer += oprot->writeFieldBegin("utctime", ::apache::thrift::protocol::T_I64, 10);
    xfer += oprot->writeI64(this->utctime);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(IdentificationServiceData &a, IdentificationServiceData &b) {
  using ::std::swap;
  swap(a.authToken, b.authToken);
  swap(a.origin, b.origin);
  swap(a.reason, b.reason);
  swap(a.devIdent, b.devIdent);
  swap(a.baDev, b.baDev);
  swap(a.devInfo, b.devInfo);
  swap(a.lanItf, b.lanItf);
  swap(a.rs485Itf, b.rs485Itf);
  swap(a.uridata, b.uridata);
  swap(a.utctime, b.utctime);
  swap(a.__isset, b.__isset);
}

const char* ConfigureServiceData::ascii_fingerprint = "17C51ECC42A6421A315F94E001FC8E0A";
const uint8_t ConfigureServiceData::binary_fingerprint[16] = {0x17,0xC5,0x1E,0xCC,0x42,0xA6,0x42,0x1A,0x31,0x5F,0x94,0xE0,0x01,0xFC,0x8E,0x0A};

uint32_t ConfigureServiceData::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authToken);
          this->__isset.authToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->origin);
          this->__isset.origin = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->devIdent.read(iprot);
          this->__isset.devIdent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->baDev.read(iprot);
          this->__isset.baDev = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->baPar.read(iprot);
          this->__isset.baPar = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->baNw.read(iprot);
          this->__isset.baNw = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->baPort.read(iprot);
          this->__isset.baPort = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->nwItf.read(iprot);
          this->__isset.nwItf = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->timeSet.read(iprot);
          this->__isset.timeSet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ConfigureServiceData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ConfigureServiceData");

  xfer += oprot->writeFieldBegin("authToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("origin", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->origin);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devIdent", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->devIdent.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("baDev", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->baDev.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("baPar", ::apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->baPar.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("baNw", ::apache::thrift::protocol::T_STRUCT, 6);
  xfer += this->baNw.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("baPort", ::apache::thrift::protocol::T_STRUCT, 7);
  xfer += this->baPort.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nwItf", ::apache::thrift::protocol::T_STRUCT, 8);
  xfer += this->nwItf.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("timeSet", ::apache::thrift::protocol::T_STRUCT, 9);
  xfer += this->timeSet.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ConfigureServiceData &a, ConfigureServiceData &b) {
  using ::std::swap;
  swap(a.authToken, b.authToken);
  swap(a.origin, b.origin);
  swap(a.devIdent, b.devIdent);
  swap(a.baDev, b.baDev);
  swap(a.baPar, b.baPar);
  swap(a.baNw, b.baNw);
  swap(a.baPort, b.baPort);
  swap(a.nwItf, b.nwItf);
  swap(a.timeSet, b.timeSet);
  swap(a.__isset, b.__isset);
}

const char* UnconfigureServiceData::ascii_fingerprint = "41717AA5DE93CA2904301806B5D069EF";
const uint8_t UnconfigureServiceData::binary_fingerprint[16] = {0x41,0x71,0x7A,0xA5,0xDE,0x93,0xCA,0x29,0x04,0x30,0x18,0x06,0xB5,0xD0,0x69,0xEF};

uint32_t UnconfigureServiceData::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authToken);
          this->__isset.authToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->origin);
          this->__isset.origin = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->devIdent.read(iprot);
          this->__isset.devIdent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->unconfigureLevel);
          this->__isset.unconfigureLevel = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UnconfigureServiceData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("UnconfigureServiceData");

  xfer += oprot->writeFieldBegin("authToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("origin", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->origin);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devIdent", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->devIdent.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("unconfigureLevel", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->unconfigureLevel);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UnconfigureServiceData &a, UnconfigureServiceData &b) {
  using ::std::swap;
  swap(a.authToken, b.authToken);
  swap(a.origin, b.origin);
  swap(a.devIdent, b.devIdent);
  swap(a.unconfigureLevel, b.unconfigureLevel);
  swap(a.__isset, b.__isset);
}

const char* SetTimeServiceData::ascii_fingerprint = "5F9965D46A4F3845985AC0F9B81C3C69";
const uint8_t SetTimeServiceData::binary_fingerprint[16] = {0x5F,0x99,0x65,0xD4,0x6A,0x4F,0x38,0x45,0x98,0x5A,0xC0,0xF9,0xB8,0x1C,0x3C,0x69};

uint32_t SetTimeServiceData::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authToken);
          this->__isset.authToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->origin);
          this->__isset.origin = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->scopeFilter);
          this->__isset.scopeFilter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->utctime);
          this->__isset.utctime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SetTimeServiceData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SetTimeServiceData");

  xfer += oprot->writeFieldBegin("authToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("origin", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->origin);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("scopeFilter", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->scopeFilter);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("utctime", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->utctime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SetTimeServiceData &a, SetTimeServiceData &b) {
  using ::std::swap;
  swap(a.authToken, b.authToken);
  swap(a.origin, b.origin);
  swap(a.scopeFilter, b.scopeFilter);
  swap(a.utctime, b.utctime);
  swap(a.__isset, b.__isset);
}

const char* SetPasswordServiceData::ascii_fingerprint = "C18AD26BF3FFAD5198DC3D25D5D7A521";
const uint8_t SetPasswordServiceData::binary_fingerprint[16] = {0xC1,0x8A,0xD2,0x6B,0xF3,0xFF,0xAD,0x51,0x98,0xDC,0x3D,0x25,0xD5,0xD7,0xA5,0x21};

uint32_t SetPasswordServiceData::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authToken);
          this->__isset.authToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->origin);
          this->__isset.origin = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->scopeFilter);
          this->__isset.scopeFilter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->type);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->newpassword);
          this->__isset.newpassword = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SetPasswordServiceData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SetPasswordServiceData");

  xfer += oprot->writeFieldBegin("authToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("origin", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->origin);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("scopeFilter", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->scopeFilter);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("newpassword", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->newpassword);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SetPasswordServiceData &a, SetPasswordServiceData &b) {
  using ::std::swap;
  swap(a.authToken, b.authToken);
  swap(a.origin, b.origin);
  swap(a.scopeFilter, b.scopeFilter);
  swap(a.type, b.type);
  swap(a.newpassword, b.newpassword);
  swap(a.__isset, b.__isset);
}

} // namespace
