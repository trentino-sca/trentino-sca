/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "Device_types.h"

#include <algorithm>

namespace siemens { namespace bt { namespace device {

const char* Data::ascii_fingerprint = "FFFD5F8A97DF7A6362AB6F6B1439B09B";
const uint8_t Data::binary_fingerprint[16] = {0xFF,0xFD,0x5F,0x8A,0x97,0xDF,0x7A,0x63,0x62,0xAB,0x6F,0x6B,0x14,0x39,0xB0,0x9B};

uint32_t Data::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast0;
          xfer += iprot->readI32(ecast0);
          this->s7State = ( ::siemens::bt::type::ControlProgramState::type)ecast0;
          this->__isset.s7State = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->baProperties.clear();
            uint32_t _size1;
            ::apache::thrift::protocol::TType _ktype2;
            ::apache::thrift::protocol::TType _vtype3;
            xfer += iprot->readMapBegin(_ktype2, _vtype3, _size1);
            uint32_t _i5;
            for (_i5 = 0; _i5 < _size1; ++_i5)
            {
               ::siemens::bt::type::Property_Type::type _key6;
              int32_t ecast8;
              xfer += iprot->readI32(ecast8);
              _key6 = ( ::siemens::bt::type::Property_Type::type)ecast8;
              std::string& _val7 = this->baProperties[_key6];
              xfer += iprot->readString(_val7);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.baProperties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->bus.clear();
            uint32_t _size9;
            ::apache::thrift::protocol::TType _ktype10;
            ::apache::thrift::protocol::TType _vtype11;
            xfer += iprot->readMapBegin(_ktype10, _vtype11, _size9);
            uint32_t _i13;
            for (_i13 = 0; _i13 < _size9; ++_i13)
            {
               ::siemens::bt::channel::Channel_Label::type _key14;
              int32_t ecast16;
              xfer += iprot->readI32(ecast16);
              _key14 = ( ::siemens::bt::channel::Channel_Label::type)ecast16;
               ::siemens::bt::channel::BusData& _val15 = this->bus[_key14];
              xfer += _val15.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.bus = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Data::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Data");

  if (this->__isset.s7State) {
    xfer += oprot->writeFieldBegin("s7State", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32((int32_t)this->s7State);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.baProperties) {
    xfer += oprot->writeFieldBegin("baProperties", ::apache::thrift::protocol::T_MAP, 2);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->baProperties.size()));
      std::map< ::siemens::bt::type::Property_Type::type, std::string> ::const_iterator _iter17;
      for (_iter17 = this->baProperties.begin(); _iter17 != this->baProperties.end(); ++_iter17)
      {
        xfer += oprot->writeI32((int32_t)_iter17->first);
        xfer += oprot->writeString(_iter17->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.bus) {
    xfer += oprot->writeFieldBegin("bus", ::apache::thrift::protocol::T_MAP, 3);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->bus.size()));
      std::map< ::siemens::bt::channel::Channel_Label::type,  ::siemens::bt::channel::BusData> ::const_iterator _iter18;
      for (_iter18 = this->bus.begin(); _iter18 != this->bus.end(); ++_iter18)
      {
        xfer += oprot->writeI32((int32_t)_iter18->first);
        xfer += _iter18->second.write(oprot);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Data &a, Data &b) {
  using ::std::swap;
  swap(a.s7State, b.s7State);
  swap(a.baProperties, b.baProperties);
  swap(a.bus, b.bus);
  swap(a.__isset, b.__isset);
}

}}} // namespace
