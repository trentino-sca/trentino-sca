/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "Types_types.h"

#include <algorithm>

namespace siemens { namespace bt { namespace type {

int _kBA_DATA_TYPEValues[] = {
  BA_DATA_TYPE::BA_NULL,
  BA_DATA_TYPE::BA_BOOL,
  BA_DATA_TYPE::BA_UINT,
  BA_DATA_TYPE::BA_INT,
  BA_DATA_TYPE::BA_REAL,
  BA_DATA_TYPE::BA_DOUBLE,
  BA_DATA_TYPE::BA_OCTET_STRING,
  BA_DATA_TYPE::BA_CHAR_STRING,
  BA_DATA_TYPE::BA_BIT_STRING,
  BA_DATA_TYPE::BA_ENUMERATED,
  BA_DATA_TYPE::BA_DATE,
  BA_DATA_TYPE::BA_TIME,
  BA_DATA_TYPE::BA_OBJ_ID
};
const char* _kBA_DATA_TYPENames[] = {
  "BA_NULL",
  "BA_BOOL",
  "BA_UINT",
  "BA_INT",
  "BA_REAL",
  "BA_DOUBLE",
  "BA_OCTET_STRING",
  "BA_CHAR_STRING",
  "BA_BIT_STRING",
  "BA_ENUMERATED",
  "BA_DATE",
  "BA_TIME",
  "BA_OBJ_ID"
};
const std::map<int, const char*> _BA_DATA_TYPE_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(13, _kBA_DATA_TYPEValues, _kBA_DATA_TYPENames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kProperty_TypeValues[] = {
  Property_Type::BA_PROP_ACKED_TRANSITIONS,
  Property_Type::BA_PROP_ACK_REQUIRED,
  Property_Type::BA_PROP_ACTION,
  Property_Type::BA_PROP_ACTION_TEXT,
  Property_Type::BA_PROP_ACTIVE_TEXT,
  Property_Type::BA_PROP_ACTIVE_VT_SESSION,
  Property_Type::BA_PROP_ALARM_VALUE,
  Property_Type::BA_PROP_ALARM_VALUES,
  Property_Type::BA_PROP_ALL,
  Property_Type::BA_PROP_ALL_WRITES_SUCCESSFUL,
  Property_Type::BA_PROP_APDU_SEGMENT_TIMEOUT,
  Property_Type::BA_PROP_APDU_TIMEOUT,
  Property_Type::BA_PROP_APPLICATION_SOFTWARE_VERSION,
  Property_Type::BA_PROP_ARCHIVE,
  Property_Type::BA_PROP_BIAS,
  Property_Type::BA_PROP_CHANGE_OF_STATE_COUNT,
  Property_Type::BA_PROP_CHANGE_OF_STATE_TIME,
  Property_Type::BA_PROP_NOTIFICATION_CLASS,
  Property_Type::BA_PROP_CONTROLLED_VARIABLE_REFERENCE,
  Property_Type::BA_PROP_CONTROLLED_VARIABLE_UNITS,
  Property_Type::BA_PROP_CONTROLLED_VARIABLE_VALUE,
  Property_Type::BA_PROP_COV_INCREMENT,
  Property_Type::BA_PROP_DATELIST,
  Property_Type::BA_PROP_DAYLIGHT_SAVINGS_STATUS,
  Property_Type::BA_PROP_DEADBAND,
  Property_Type::BA_PROP_DERIVATIVE_CONSTANT,
  Property_Type::BA_PROP_DERIVATIVE_CONSTANT_UNITS,
  Property_Type::BA_PROP_DESCRIPTION,
  Property_Type::BA_PROP_DESCRIPTION_OF_HALT,
  Property_Type::BA_PROP_DEVICE_ADDRESS_BINDING,
  Property_Type::BA_PROP_DEVICE_TYPE,
  Property_Type::BA_PROP_EFFECTIVE_PERIOD,
  Property_Type::BA_PROP_ELAPSED_ACTIVE_TIME,
  Property_Type::BA_PROP_ERROR_LIMIT,
  Property_Type::BA_PROP_EVENT_ENABLE,
  Property_Type::BA_PROP_EVENT_STATE,
  Property_Type::BA_PROP_EVENT_TYPE,
  Property_Type::BA_PROP_EXCEPTION_SCHEDULE,
  Property_Type::BA_PROP_FAULT_VALUES,
  Property_Type::BA_PROP_FEEDBACK_VALUE,
  Property_Type::BA_PROP_FILE_ACCESS_METHOD,
  Property_Type::BA_PROP_FILE_SIZE,
  Property_Type::BA_PROP_FILE_TYPE,
  Property_Type::BA_PROP_FIRMWARE_REVISION,
  Property_Type::BA_PROP_HIGH_LIMIT,
  Property_Type::BA_PROP_INACTIVE_TEXT,
  Property_Type::BA_PROP_IN_PROCESS,
  Property_Type::BA_PROP_INSTANCE_OF,
  Property_Type::BA_PROP_INTEGRAL_CONSTANT,
  Property_Type::BA_PROP_INTEGRAL_CONSTANT_UNITS,
  Property_Type::BA_PROP_ISSUE_CONFIRMED_NOTIFICATIONS,
  Property_Type::BA_PROP_LIMIT_ENABLE,
  Property_Type::BA_PROP_LIST_OF_GROUP_MEMBERS,
  Property_Type::BA_PROP_LIST_OF_OBJECT_PROPERTY_REFERENCES,
  Property_Type::BA_PROP_LIST_OF_SESSION_KEYS,
  Property_Type::BA_PROP_LOCAL_DATE,
  Property_Type::BA_PROP_LOCAL_TIME,
  Property_Type::BA_PROP_LOCATION,
  Property_Type::BA_PROP_LOW_LIMIT,
  Property_Type::BA_PROP_MANIPULATED_VARIABLE_REFERENCE,
  Property_Type::BA_PROP_MAXIMUM_OUTPUT,
  Property_Type::BA_PROP_MAX_APDU_LENGTH_ACCEPTED,
  Property_Type::BA_PROP_MAX_INFO_FRAMES,
  Property_Type::BA_PROP_MAX_MASTER,
  Property_Type::BA_PROP_MAX_PRES_VALUE,
  Property_Type::BA_PROP_MINIMUM_OFF_TIME,
  Property_Type::BA_PROP_MINIMUM_ON_TIME,
  Property_Type::BA_PROP_MINIMUM_OUTPUT,
  Property_Type::BA_PROP_MIN_PRES_VALUE,
  Property_Type::BA_PROP_MODEL_NAME,
  Property_Type::BA_PROP_MODIFICATION_DATE,
  Property_Type::BA_PROP_NOTIFY_TYPE,
  Property_Type::BA_PROP_NUMBER_OF_APDU_RETRIES,
  Property_Type::BA_PROP_NUMBER_OF_STATES,
  Property_Type::BA_PROP_OBJECT_IDENTIFIER,
  Property_Type::BA_PROP_OBJECT_LIST,
  Property_Type::BA_PROP_OBJECT_NAME,
  Property_Type::BA_PROP_OBJECT_PROPERTY_REFERENCE,
  Property_Type::BA_PROP_OBJECT_TYPE,
  Property_Type::BA_PROP_OPTIONAL,
  Property_Type::BA_PROP_OUT_OF_SERVICE,
  Property_Type::BA_PROP_OUTPUT_UNITS,
  Property_Type::BA_PROP_EVENT_PARAMETERS,
  Property_Type::BA_PROP_POLARITY,
  Property_Type::BA_PROP_PRESENT_VALUE,
  Property_Type::BA_PROP_PRIORITY,
  Property_Type::BA_PROP_PRIORITY_ARRAY,
  Property_Type::BA_PROP_PRIORITY_FOR_WRITING,
  Property_Type::BA_PROP_PROCESS_IDENTIFIER,
  Property_Type::BA_PROP_PROGRAM_CHANGE,
  Property_Type::BA_PROP_PROGRAM_LOCATION,
  Property_Type::BA_PROP_PROGRAM_STATE,
  Property_Type::BA_PROP_PROPORTIONAL_CONSTANT,
  Property_Type::BA_PROP_PROPORTIONAL_CONSTANT_UNITS,
  Property_Type::BA_PROP_PROTOCOL_CONFORMANCE_CLASS,
  Property_Type::BA_PROP_PROTOCOL_OBJECT_TYPES_SUPPORTED,
  Property_Type::BA_PROP_PROTOCOL_SERVICES_SUPPORTED,
  Property_Type::BA_PROP_PROTOCOL_VERSION,
  Property_Type::BA_PROP_READ_ONLY,
  Property_Type::BA_PROP_REASON_FOR_HALT,
  Property_Type::BA_PROP_RECIPIENT,
  Property_Type::BA_PROP_RECIPIENT_LIST,
  Property_Type::BA_PROP_RELIABILITY,
  Property_Type::BA_PROP_RELINQUISH_DEFAULT,
  Property_Type::BA_PROP_REQUIRED,
  Property_Type::BA_PROP_RESOLUTION,
  Property_Type::BA_PROP_SEGMENTATION_SUPPORTED,
  Property_Type::BA_PROP_SETPOINT,
  Property_Type::BA_PROP_SETPOINT_REFERENCE,
  Property_Type::BA_PROP_STATE_TEXT,
  Property_Type::BA_PROP_STATUS_FLAGS,
  Property_Type::BA_PROP_SYSTEM_STATUS,
  Property_Type::BA_PROP_TIME_DELAY,
  Property_Type::BA_PROP_TIME_OF_ACTIVE_TIME_RESET,
  Property_Type::BA_PROP_TIME_OF_STATE_COUNT_RESET,
  Property_Type::BA_PROP_TIME_SYNCHRONIZATION_RECIPIENTS,
  Property_Type::BA_PROP_UNITS,
  Property_Type::BA_PROP_UPDATE_INTERVAL,
  Property_Type::BA_PROP_UTC_OFFSET,
  Property_Type::BA_PROP_VENDOR_IDENTIFIER,
  Property_Type::BA_PROP_VENDOR_NAME,
  Property_Type::BA_PROP_VT_CLASSES_SUPPORTED,
  Property_Type::BA_PROP_WEEKLY_SCHEDULE,
  Property_Type::BA_PROP_ATTEMPTED_SAMPLES,
  Property_Type::BA_PROP_AVERAGE_VALUE,
  Property_Type::BA_PROP_BUFFER_SIZE,
  Property_Type::BA_PROP_CLIENT_COV_INCREMENT,
  Property_Type::BA_PROP_COV_RESUBSCRIPTION_INTERVAL,
  Property_Type::BA_PROP_CURRENT_NOTIFY_TIME,
  Property_Type::BA_PROP_EVENT_TIME_STAMPS,
  Property_Type::BA_PROP_LOG_BUFFER,
  Property_Type::BA_PROP_LOG_DEVICE_OBJECT_PROPERTY,
  Property_Type::BA_PROP_ENABLE,
  Property_Type::BA_PROP_LOG_INTERVAL,
  Property_Type::BA_PROP_MAXIMUM_VALUE,
  Property_Type::BA_PROP_MINIMUM_VALUE,
  Property_Type::BA_PROP_NOTIFICATION_THRESHOLD,
  Property_Type::BA_PROP_PREVIOUS_NOTIFY_TIME,
  Property_Type::BA_PROP_PROTOCOL_REVISION,
  Property_Type::BA_PROP_RECORDS_SINCE_NOTIFICATION,
  Property_Type::BA_PROP_RECORD_COUNT,
  Property_Type::BA_PROP_START_TIME,
  Property_Type::BA_PROP_STOP_TIME,
  Property_Type::BA_PROP_STOP_WHEN_FULL,
  Property_Type::BA_PROP_TOTAL_RECORD_COUNT,
  Property_Type::BA_PROP_VALID_SAMPLES,
  Property_Type::BA_PROP_WINDOW_INTERVAL,
  Property_Type::BA_PROP_WINDOW_SAMPLES,
  Property_Type::BA_PROP_MAXIMUM_VALUE_TIMESTAMP,
  Property_Type::BA_PROP_MINIMUM_VALUE_TIMESTAMP,
  Property_Type::BA_PROP_VARIANCE_VALUE,
  Property_Type::BA_PROP_ACTIVE_COV_SUBSCRIPTIONS,
  Property_Type::BA_PROP_BACKUP_FAILURE_TIMEOUT,
  Property_Type::BA_PROP_CONFIGURATION_FILES,
  Property_Type::BA_PROP_DATABASE_REVISION,
  Property_Type::BA_PROP_DIRECT_READING,
  Property_Type::BA_PROP_LAST_RESTORE_TIME,
  Property_Type::BA_PROP_MAINTENANCE_REQUIRED,
  Property_Type::BA_PROP_MEMBER_OF,
  Property_Type::BA_PROP_MODE,
  Property_Type::BA_PROP_OPERATION_REQUIRED,
  Property_Type::BA_PROP_SETTING,
  Property_Type::BA_PROP_SILENCED,
  Property_Type::BA_PROP_TRACKING_VALUE,
  Property_Type::BA_PROP_ZONE_MEMBERS,
  Property_Type::BA_PROP_LIFE_SAFETY_ALARM_VALUES,
  Property_Type::BA_PROP_MAX_SEGMENTS_ACCEPTED,
  Property_Type::BA_PROP_PROFILE_NAME,
  Property_Type::BA_PROP_AUTO_SLAVE_DISCOVERY,
  Property_Type::BA_PROP_MANUAL_SLAVE_ADDRESS_BINDING,
  Property_Type::BA_PROP_SLAVE_ADDRESS_BINDING,
  Property_Type::BA_PROP_SLAVE_PROXY_ENABLE,
  Property_Type::BA_PROP_LAST_NOTIFY_RECORD,
  Property_Type::BA_PROP_SCHEDULE_DEFAULT,
  Property_Type::BA_PROP_ACCEPTED_MODES,
  Property_Type::BA_PROP_ADJUST_VALUE,
  Property_Type::BA_PROP_COUNT,
  Property_Type::BA_PROP_COUNT_BEFORE_CHANGE,
  Property_Type::BA_PROP_COUNT_CHANGE_TIME,
  Property_Type::BA_PROP_COV_PERIOD,
  Property_Type::BA_PROP_INPUT_REFERENCE,
  Property_Type::BA_PROP_LIMIT_MONITORING_INTERVAL,
  Property_Type::BA_PROP_LOGGING_OBJECT,
  Property_Type::BA_PROP_LOGGING_RECORD,
  Property_Type::BA_PROP_PRESCALE,
  Property_Type::BA_PROP_PULSE_RATE,
  Property_Type::BA_PROP_SCALE,
  Property_Type::BA_PROP_SCALE_FACTOR,
  Property_Type::BA_PROP_UPDATE_TIME,
  Property_Type::BA_PROP_VALUE_BEFORE_CHANGE,
  Property_Type::BA_PROP_VALUE_SET,
  Property_Type::BA_PROP_VALUE_CHANGE_TIME,
  Property_Type::BA_PROP_ALIGN_INTERVALS,
  Property_Type::BA_PROP_INTERVAL_OFFSET,
  Property_Type::BA_PROP_LAST_RESTART_REASON,
  Property_Type::BA_PROP_LOGGING_TYPE,
  Property_Type::BA_PROP_RESTART_NOTIFICATION_RECIPIENTS,
  Property_Type::BA_PROP_TIME_OF_DEVICE_RESTART,
  Property_Type::BA_PROP_TIME_SYNCHRONIZATION_INTERVAL,
  Property_Type::BA_PROP_TRIGGER,
  Property_Type::BA_PROP_UTC_TIME_SYNCHRONIZATION_RECIPIENTS,
  Property_Type::BA_PROP_NODE_SUBTYPE,
  Property_Type::BA_PROP_NODE_TYPE,
  Property_Type::BA_PROP_STRUCTURED_OBJECT_LIST,
  Property_Type::BA_PROP_SUBORDINATE_ANNOTATIONS,
  Property_Type::BA_PROP_SUBORDINATE_LIST,
  Property_Type::BA_PROP_ACTUAL_SHED_LEVEL,
  Property_Type::BA_PROP_DUTY_WINDOW,
  Property_Type::BA_PROP_EXPECTED_SHED_LEVEL,
  Property_Type::BA_PROP_FULL_DUTY_BASELINE,
  Property_Type::BA_PROP_REQUESTED_SHED_LEVEL,
  Property_Type::BA_PROP_SHED_DURATION,
  Property_Type::BA_PROP_SHED_LEVEL_DESCRIPTIONS,
  Property_Type::BA_PROP_SHED_LEVELS,
  Property_Type::BA_PROP_DOOR_ALARM_STATE,
  Property_Type::BA_PROP_DOOR_EXTENDED_PULSE_TIME,
  Property_Type::BA_PROP_DOOR_MEMBERS,
  Property_Type::BA_PROP_DOOR_OPEN_TOO_LONG_TIME,
  Property_Type::BA_PROP_DOOR_PULSE_TIME,
  Property_Type::BA_PROP_DOOR_STATUS,
  Property_Type::BA_PROP_DOOR_UNLOCK_DELAY_TIME,
  Property_Type::BA_PROP_LOCK_STATUS,
  Property_Type::BA_PROP_MASKED_ALARM_VALUES,
  Property_Type::BA_PROP_SECURED_STATUS,
  Property_Type::BA_PROP_BACKUP_AND_RESTORE_STATE,
  Property_Type::BA_PROP_BACKUP_PREPARATION_TIME,
  Property_Type::BA_PROP_RESTORE_COMPLETION_TIME,
  Property_Type::BA_PROP_RESTORE_PREPARATION_TIME,
  Property_Type::BA_PROP_USER_DESIGNATION,
  Property_Type::BA_PROP_SURROUND,
  Property_Type::BA_PROP_INTERFACE_LIST,
  Property_Type::BA_PROP_LOCAL_LIST,
  Property_Type::BA_PROP_HIERARCHY_LIST,
  Property_Type::BA_PROP_ELEMENT_TYPE,
  Property_Type::BA_PROP_OBJECT_TAG,
  Property_Type::BA_PROP_FUNCTION_NAME,
  Property_Type::BA_PROP_LOW_VALUE,
  Property_Type::BA_PROP_HIGH_VALUE,
  Property_Type::BA_PROP_PARAMETER_KIND,
  Property_Type::BA_PROP_ALARM_ENABLE,
  Property_Type::BA_PROP_LOCKED,
  Property_Type::BA_PROP_TIME_OF_ACKED,
  Property_Type::BA_PROP_ACK_INITIALS,
  Property_Type::BA_PROP_MESSAGE_TEXT,
  Property_Type::BA_PROP_SLOPE,
  Property_Type::BA_PROP_INTERCEPT,
  Property_Type::BA_PROP_ADDRESS,
  Property_Type::BA_PROP_COMMISSIONING_STATE,
  Property_Type::BA_PROP_NAME_REFERENCE,
  Property_Type::BA_PROP_FEEDBACK_ADDR,
  Property_Type::BA_PROP_DESTINATION_LIST,
  Property_Type::BA_PROP_SITE_NAME,
  Property_Type::BA_PROP_PRIMARY_DEVICE,
  Property_Type::BA_PROP_GLOBAL_OBJECTS_MODIFICATION_TIME,
  Property_Type::BA_PROP_GLOBAL_OBJECTS_UPDATE_TIME,
  Property_Type::BA_PROP_SYNCH_REQUEST_PERIOD,
  Property_Type::BA_PROP_PROGRAM_MODIFICATION_TIME,
  Property_Type::BA_PROP_MIN_CYCLE_TIME,
  Property_Type::BA_PROP_MAX_CYCLE_TIME,
  Property_Type::BA_PROP_CYCLE_TIME_STATISTICS,
  Property_Type::BA_PROP_MEMORY_STATISTICS,
  Property_Type::BA_PROP_COMMUNICATION_STATISTICS,
  Property_Type::BA_PROP_SERIAL_LINE_STATISTICS,
  Property_Type::BA_PROP_DIAGNOSTICS,
  Property_Type::BA_PROP_MAIN_PARAMETER,
  Property_Type::BA_PROP_ACCESS_RIGHT,
  Property_Type::BA_PROP_MAX_SIZE,
  Property_Type::BA_PROP_MIN_SIZE,
  Property_Type::BA_PROP_ENABLE_ACTIVE_TIME,
  Property_Type::BA_PROP_ELAPSED_TIME_LIMIT,
  Property_Type::BA_PROP_TOTAL_ACTIVE_TIME,
  Property_Type::BA_PROP_SHADOW_DEV_OBJ_ID,
  Property_Type::BA_PROP_SHADOW_DEV_OBJ_NAME,
  Property_Type::BA_PROP_EXPIRED_DATE,
  Property_Type::BA_PROP_FEEDBACK_POLARITY,
  Property_Type::BA_PROP_FEEDBACK_SLOPE,
  Property_Type::BA_PROP_FEEDBACK_INTERCEPT,
  Property_Type::BA_PROP_EXCEPTIONS,
  Property_Type::BA_PROP_NEXT_VALUE,
  Property_Type::BA_PROP_NEXT_TIME,
  Property_Type::BA_PROP_PARAMETER_LIST,
  Property_Type::BA_PROP_LIST_OF_NAME_REFERENCE,
  Property_Type::BA_PROP_DAYLIGHT_SAVING_BEGIN_DATE,
  Property_Type::BA_PROP_DAYLIGHT_SAVING_BEGIN_TIME,
  Property_Type::BA_PROP_DAYLIGHT_SAVING_END_DATE,
  Property_Type::BA_PROP_DAYLIGHT_SAVING_END_TIME,
  Property_Type::BA_PROP_OPERATING_HOURS_MESSAGE,
  Property_Type::BA_PROP_EXPIRED,
  Property_Type::BA_PROP_ELAPSED_TIME,
  Property_Type::BA_PROP_MAX_INSTR_COUNT,
  Property_Type::BA_PROP_RECLAIM_TIME,
  Property_Type::BA_PROP_YESTERDAY,
  Property_Type::BA_PROP_NEXT_DATE,
  Property_Type::BA_PROP_VISIBILITY,
  Property_Type::BA_PROP_SERVER_TYPE,
  Property_Type::BA_PROP_NAME_RESOLUTION_INTERVAL,
  Property_Type::BA_PROP_SHADOW_APDU_SEGMENT_TIMEOUT,
  Property_Type::BA_PROP_SHADOW_APDU_TIMEOUT,
  Property_Type::BA_PROP_SHADOW_MAX_APDU_LENGTH_ACCEPTED,
  Property_Type::BA_PROP_SHADOW_NUMBER_OF_APDU_RETRIES,
  Property_Type::BA_PROP_GLOBAL,
  Property_Type::BA_PROP_STARTUP_STATISTIC,
  Property_Type::BA_PROP_DATETIME_SUBTYPE,
  Property_Type::BA_PROP_USERS,
  Property_Type::BA_PROP_USERGROUPS,
  Property_Type::BA_PROP_SCOPES,
  Property_Type::BA_PROP_LAST_MODIFICATION,
  Property_Type::BA_PROP_GROUP,
  Property_Type::BA_PROP_MAXNR_CALL_REPETITIONS,
  Property_Type::BA_PROP_TERMINATION_TIME_VALUE,
  Property_Type::BA_PROP_ACCESS_PASSWORD,
  Property_Type::BA_PROP_COM_INTERFACE_LIST,
  Property_Type::BA_PROP_CONNECTION_LIST,
  Property_Type::BA_PROP_MODEM_STATISTICS,
  Property_Type::BA_PROP_MODEM_SETTINGS,
  Property_Type::BA_PROP_MODEM_STATUS,
  Property_Type::BA_PROP_CONNECT,
  Property_Type::BA_PROP_NETWORK_NUMBER,
  Property_Type::BA_PROP_ALARM_PRIO_LIMIT,
  Property_Type::BA_PROP_TOMORROW,
  Property_Type::BA_PROP_DAY_AFTER_TOMORROW,
  Property_Type::BA_PROP_INTERVAL,
  Property_Type::BA_PROP_LAST_MESSAGE,
  Property_Type::BA_PROP_GROUP_MEMBERS,
  Property_Type::BA_PROP_ROOM_MEMBERS,
  Property_Type::BA_PROP_MENU_LINES,
  Property_Type::BA_PROP_TIME_DELAY1,
  Property_Type::BA_PROP_TIME_DELAY2,
  Property_Type::BA_PROP_IO_STATISTICS,
  Property_Type::BA_PROP_DELAY_ON,
  Property_Type::BA_PROP_DELAY_OFF,
  Property_Type::BA_PROP_ALARM_COLLECTION_REF,
  Property_Type::BA_PROP_ALARM_CLASS,
  Property_Type::BA_PROP_SWITCH_UP,
  Property_Type::BA_PROP_SWITCH_DOWN,
  Property_Type::BA_PROP_PRESENT_POWER,
  Property_Type::BA_PROP_CONTROLLED_POWER,
  Property_Type::BA_PROP_IP_PARAMETERS,
  Property_Type::BA_PROP_DPX_SUBSTITUTION_VALUE,
  Property_Type::BA_PROP_DPX_DESCRIPTION_LIST,
  Property_Type::BA_PROP_DPX_ALARM_FUNCTION,
  Property_Type::BA_PROP_DPX_HEARTBEAT,
  Property_Type::BA_PROP_DPX_JITTER_SUPPRESS,
  Property_Type::BA_PROP_DPX_RELIABILITY_ERROR_LIST,
  Property_Type::BA_PROP_DPX_POLLING_CYCLE,
  Property_Type::BA_PROP_DPX_EVENT_COUNT,
  Property_Type::BA_PROP_DPX_EXTENDED_NOTIFY,
  Property_Type::BA_PROP_DPX_LOG_STATUS,
  Property_Type::BA_PROP_DPX_SET_VALUE,
  Property_Type::BA_PROP_DPX_INTEGRAL_TIME,
  Property_Type::BA_PROP_DPX_NEUTRAL_ZONE,
  Property_Type::BA_PROP_DPX_DERIVATIVE_TIME,
  Property_Type::BA_PROP_DPX_TI0TO100,
  Property_Type::BA_PROP_DPX_TI100TO0,
  Property_Type::BA_PROP_DPX_LOOP_STATE,
  Property_Type::BA_PROP_DPX_SETPOINT_RESOLUTION,
  Property_Type::BA_PROP_DPX_SETPOINT_HIGH_VALUE,
  Property_Type::BA_PROP_DPX_SETPOINT_LOW_VALUE,
  Property_Type::BA_PROP_DPX_ENABLE_LOG,
  Property_Type::BA_PROP_DPX_ALARM_CLASS_TEXT,
  Property_Type::BA_PROP_DPX_EXTENDED_COMMAND,
  Property_Type::BA_PROP_DPX_FILE_OPERATION,
  Property_Type::BA_PROP_DPX_PULSECOUNT,
  Property_Type::BA_PROP_DPX_DATA_TIME_STAMP,
  Property_Type::BA_PROP_DPX_DATA_SOURCE,
  Property_Type::BA_PROP_DPX_SERIALIZATION_IN_PROGRESS,
  Property_Type::BA_PROP_DPX_AVAILABLE_FILE_STORAGE,
  Property_Type::BA_PROP_DPX_DEVICE_INFO_REFERENCE,
  Property_Type::BA_PROP_DPX_SCALE_FACTOR,
  Property_Type::BA_PROP_DPX_COUNT,
  Property_Type::BA_PROP_DPX_COUNT_BEFORE_RESET,
  Property_Type::BA_PROP_DPX_COV_PERIOD,
  Property_Type::BA_PROP_DPX_RESET_TIME,
  Property_Type::BA_PROP_DPX_RESET_VALUE,
  Property_Type::BA_PROP_DPX_TOTAL_COUNT,
  Property_Type::BA_PROP_DPX_UPDATE_TIME,
  Property_Type::BA_PROP_DPX_S_IN_PROCESS,
  Property_Type::BA_PROP_DPX_S_FEEDBACK_VALUE,
  Property_Type::BA_PROP_DPX_RESOLUTION,
  Property_Type::BA_PROP_DPX_S_UNIT,
  Property_Type::BA_PROP_DPX_S_INACTIVE_TEXT,
  Property_Type::BA_PROP_DPX_S_ACTIVE_TEXT,
  Property_Type::BA_PROP_DPX_S_NUMBER_OF_STATES,
  Property_Type::BA_PROP_DPX_S_STATE_TEXT,
  Property_Type::BA_PROP_DPX_S_RECIPIENT_LIST,
  Property_Type::BA_PROP_DPX_S_BUFFER_SIZE,
  Property_Type::BA_PROP_DPX_S_RECORD_COUNT,
  Property_Type::BA_PROP_DPX_S_NOTIFICATION_THRESHOLD,
  Property_Type::BA_PROP_DPX_S_BCKUP_SRVR_LIST,
  Property_Type::BA_PROP_DPX_S_OUT_OF_SERVICE,
  Property_Type::BA_PROP_DPX_S_ELAPSED_ACTIVE_TIME,
  Property_Type::BA_PROP_DPX_S_TIME_OF_ACTIVE_TIME_RESET,
  Property_Type::BA_PROP_DPX_S_MINIMUM_ON_TIME,
  Property_Type::BA_PROP_DPX_S_MINIMUM_OFF_TIME,
  Property_Type::BA_PROP_DPX_S_COV_RESUBSCRIPTION_INTERVAL,
  Property_Type::BA_PROP_DPX_ACTUAL_VALUE,
  Property_Type::BA_PROP_DPX_S_RELIABILITY,
  Property_Type::BA_PROP_DPX_S_STATUS_FLAGS,
  Property_Type::BA_PROP_DPX_ENABLE_CHANGE_OF_STATE_COUNT,
  Property_Type::BA_PROP_DPX_TECHNICAL_DESIGNATION,
  Property_Type::BA_PROP_DS7_INPUT_PTP,
  Property_Type::BA_PROP_DS1_ENABLE_MEMORIZE_FUNCTION,
  Property_Type::BA_PROP_DS1_RESOLUTION,
  Property_Type::BA_PROP_DS1_MIN_PRESENT_VALUE,
  Property_Type::BA_PROP_DS1_MAX_PRESENT_VALUE,
  Property_Type::BA_PROP_DS1_PRESENT_COMMAND,
  Property_Type::BA_PROP_DS1_RELIABILITY,
  Property_Type::BA_PROP_DS1_SIEMENS_URL,
  Property_Type::BA_PROP_DS1_LIST_OF_ITEM_ATTRIBUTES,
  Property_Type::BA_PROP_DS1_LIST_OF_ANNOTATIONS,
  Property_Type::BA_PROP_DS1_LIST_OF_OBJECT_PROPERTY_REF,
  Property_Type::BA_PROP_DS1_GROUP_MASTER,
  Property_Type::BA_PROP_DS1_GROUP_MEMBERS,
  Property_Type::BA_PROP_DS1_COLLECTED_DATA,
  Property_Type::BA_PROP_DS1_GROUP_COMMAND,
  Property_Type::BA_PROP_DS1_GROUP_NUMBER,
  Property_Type::BA_PROP_DS1_GROUP_CATEGORY_TEXT,
  Property_Type::BA_PROP_DS1_GROUP_CATEGORY,
  Property_Type::BA_PROP_DS1_SOURCE_PROPERTY_ID,
  Property_Type::BA_PROP_DS1_SOURCE_OBJECT_TAG,
  Property_Type::BA_PROP_DS1_MEMORIZE_VALUE,
  Property_Type::BA_PROP_DS1_RAMP_RATE,
  Property_Type::BA_PROP_DS1_BINARY_THRESHOLD,
  Property_Type::BA_PROP_DS1_BINARY_PRESENT_VALUE,
  Property_Type::BA_PROP_DS1_BURN_IN_TIME,
  Property_Type::BA_PROP_DS1_FADE_TIME,
  Property_Type::BA_PROP_DS1_IN_PROCESS,
  Property_Type::BA_PROP_DS1_LIFECYCLE_STATE,
  Property_Type::BA_PROP_DS1_LIFE_TIME,
  Property_Type::BA_PROP_DS1_MIN_ACTUAL_VALUE,
  Property_Type::BA_PROP_DS1_MAX_ACTUAL_VALUE,
  Property_Type::BA_PROP_DS1_COMPRESSION,
  Property_Type::BA_PROP_DS1_CHECKSUM,
  Property_Type::BA_PROP_DS1_FILE_FEATURES,
  Property_Type::BA_PROP_DS1_RT_SEQUENCE_COUNT,
  Property_Type::BA_PROP_DS1_ENGINEERING_COUNT,
  Property_Type::BA_PROP_DS1_PROGRESS_VALUE,
  Property_Type::BA_PROP_DS1_CONTROL_COMMAND,
  Property_Type::BA_PROP_DS1_RELINQUISH_DEFAULT_CONTROL,
  Property_Type::BA_PROP_DS1_SUBORDINATE_ATTRIBUTES,
  Property_Type::BA_PROP_DS1_PERIPHERAL_DEVICE_TYPE,
  Property_Type::BA_PROP_DS1_ABORT_COMMAND,
  Property_Type::BA_PROP_DS1_LASTMOVING_DIRECTION,
  Property_Type::BA_PROP_DS1_LIGHTING_VALUE,
  Property_Type::BA_PROP_DS1_LIGHTING_STATE,
  Property_Type::BA_PROP_DS1_IOADDRESS,
  Property_Type::BA_PROP_DS1_PRESENT_PRIORITY,
  Property_Type::BA_PROP_DS1_UPDATE_COUNT,
  Property_Type::BA_PROP_DS1_DEVICE_COMMAND,
  Property_Type::BA_PROP_DS1_ORPHAN_LIST,
  Property_Type::BA_PROP_DS1_FIELD_BUS_INFO,
  Property_Type::BA_PROP_DS1_DEVICE_COMMAND_RESULT,
  Property_Type::BA_PROP_DS1_FIELD_BUS_COMMAND,
  Property_Type::BA_PROP_DS1_SERIAL_NUMBER,
  Property_Type::BA_PROP_DS1_PERIPHERAL_DEVICE_INFO,
  Property_Type::BA_PROP_DS1_BA_PROTOTYPE,
  Property_Type::BA_PROP_DS1_COMMISSIONING_INFO,
  Property_Type::BA_PROP_DS1_COMMISSIONING_STATE,
  Property_Type::BA_PROP_DS1_CORRECTION_FACTOR,
  Property_Type::BA_PROP_DS1_CORRECTION_OFFSET,
  Property_Type::BA_PROP_DS1_TRACKING_VALUE,
  Property_Type::BA_PROP_DS1_S1_DEVICE_FEATURES,
  Property_Type::BA_PROP_DS1_ITEM_LIST,
  Property_Type::BA_PROP_DS1_DATA_TIMESTAMP,
  Property_Type::BA_PROP_DS1_OBJECT_ATTRIBUTES,
  Property_Type::BA_PROP_DS1_INTERNAL_OVERRIDE,
  Property_Type::BA_PROP_DS1_AVAILABLE_FLASH,
  Property_Type::BA_PROP_DS1_AVAILABLE_MEMORY,
  Property_Type::BA_PROP_ISA_EVENT_MESSAGE_TEXTS,
  Property_Type::BA_PROP_ISA_FUNCTION_SETS,
  Property_Type::BA_PROP_ISA_VERSION,
  Property_Type::BA_PROP_PPCL_STATEMENT,
  Property_Type::BA_PROP_DS1_SOURCE_DATA_TAG,
  Property_Type::BA_PROP_DS1_SOURCE_PROPERTY_TAG,
  Property_Type::BA_PROP_DS1_ITEM_VALUE_DATA_TAG,
  Property_Type::BA_PROP_DS1_ITEM_VALUE_OPERATION,
  Property_Type::BA_PROP_DS1_ITEM_VALUE_PRIORITY,
  Property_Type::BA_PROP_DS1_ITEM_VALUE,
  Property_Type::BA_PROP_DS1_ITEM_RELIABILITY,
  Property_Type::BA_PROP_DS1_COLLECTED_DATA_SEQ_NUMBER,
  Property_Type::BA_PROP_ANYORDUMMY_VALUE
};
const char* _kProperty_TypeNames[] = {
  "BA_PROP_ACKED_TRANSITIONS",
  "BA_PROP_ACK_REQUIRED",
  "BA_PROP_ACTION",
  "BA_PROP_ACTION_TEXT",
  "BA_PROP_ACTIVE_TEXT",
  "BA_PROP_ACTIVE_VT_SESSION",
  "BA_PROP_ALARM_VALUE",
  "BA_PROP_ALARM_VALUES",
  "BA_PROP_ALL",
  "BA_PROP_ALL_WRITES_SUCCESSFUL",
  "BA_PROP_APDU_SEGMENT_TIMEOUT",
  "BA_PROP_APDU_TIMEOUT",
  "BA_PROP_APPLICATION_SOFTWARE_VERSION",
  "BA_PROP_ARCHIVE",
  "BA_PROP_BIAS",
  "BA_PROP_CHANGE_OF_STATE_COUNT",
  "BA_PROP_CHANGE_OF_STATE_TIME",
  "BA_PROP_NOTIFICATION_CLASS",
  "BA_PROP_CONTROLLED_VARIABLE_REFERENCE",
  "BA_PROP_CONTROLLED_VARIABLE_UNITS",
  "BA_PROP_CONTROLLED_VARIABLE_VALUE",
  "BA_PROP_COV_INCREMENT",
  "BA_PROP_DATELIST",
  "BA_PROP_DAYLIGHT_SAVINGS_STATUS",
  "BA_PROP_DEADBAND",
  "BA_PROP_DERIVATIVE_CONSTANT",
  "BA_PROP_DERIVATIVE_CONSTANT_UNITS",
  "BA_PROP_DESCRIPTION",
  "BA_PROP_DESCRIPTION_OF_HALT",
  "BA_PROP_DEVICE_ADDRESS_BINDING",
  "BA_PROP_DEVICE_TYPE",
  "BA_PROP_EFFECTIVE_PERIOD",
  "BA_PROP_ELAPSED_ACTIVE_TIME",
  "BA_PROP_ERROR_LIMIT",
  "BA_PROP_EVENT_ENABLE",
  "BA_PROP_EVENT_STATE",
  "BA_PROP_EVENT_TYPE",
  "BA_PROP_EXCEPTION_SCHEDULE",
  "BA_PROP_FAULT_VALUES",
  "BA_PROP_FEEDBACK_VALUE",
  "BA_PROP_FILE_ACCESS_METHOD",
  "BA_PROP_FILE_SIZE",
  "BA_PROP_FILE_TYPE",
  "BA_PROP_FIRMWARE_REVISION",
  "BA_PROP_HIGH_LIMIT",
  "BA_PROP_INACTIVE_TEXT",
  "BA_PROP_IN_PROCESS",
  "BA_PROP_INSTANCE_OF",
  "BA_PROP_INTEGRAL_CONSTANT",
  "BA_PROP_INTEGRAL_CONSTANT_UNITS",
  "BA_PROP_ISSUE_CONFIRMED_NOTIFICATIONS",
  "BA_PROP_LIMIT_ENABLE",
  "BA_PROP_LIST_OF_GROUP_MEMBERS",
  "BA_PROP_LIST_OF_OBJECT_PROPERTY_REFERENCES",
  "BA_PROP_LIST_OF_SESSION_KEYS",
  "BA_PROP_LOCAL_DATE",
  "BA_PROP_LOCAL_TIME",
  "BA_PROP_LOCATION",
  "BA_PROP_LOW_LIMIT",
  "BA_PROP_MANIPULATED_VARIABLE_REFERENCE",
  "BA_PROP_MAXIMUM_OUTPUT",
  "BA_PROP_MAX_APDU_LENGTH_ACCEPTED",
  "BA_PROP_MAX_INFO_FRAMES",
  "BA_PROP_MAX_MASTER",
  "BA_PROP_MAX_PRES_VALUE",
  "BA_PROP_MINIMUM_OFF_TIME",
  "BA_PROP_MINIMUM_ON_TIME",
  "BA_PROP_MINIMUM_OUTPUT",
  "BA_PROP_MIN_PRES_VALUE",
  "BA_PROP_MODEL_NAME",
  "BA_PROP_MODIFICATION_DATE",
  "BA_PROP_NOTIFY_TYPE",
  "BA_PROP_NUMBER_OF_APDU_RETRIES",
  "BA_PROP_NUMBER_OF_STATES",
  "BA_PROP_OBJECT_IDENTIFIER",
  "BA_PROP_OBJECT_LIST",
  "BA_PROP_OBJECT_NAME",
  "BA_PROP_OBJECT_PROPERTY_REFERENCE",
  "BA_PROP_OBJECT_TYPE",
  "BA_PROP_OPTIONAL",
  "BA_PROP_OUT_OF_SERVICE",
  "BA_PROP_OUTPUT_UNITS",
  "BA_PROP_EVENT_PARAMETERS",
  "BA_PROP_POLARITY",
  "BA_PROP_PRESENT_VALUE",
  "BA_PROP_PRIORITY",
  "BA_PROP_PRIORITY_ARRAY",
  "BA_PROP_PRIORITY_FOR_WRITING",
  "BA_PROP_PROCESS_IDENTIFIER",
  "BA_PROP_PROGRAM_CHANGE",
  "BA_PROP_PROGRAM_LOCATION",
  "BA_PROP_PROGRAM_STATE",
  "BA_PROP_PROPORTIONAL_CONSTANT",
  "BA_PROP_PROPORTIONAL_CONSTANT_UNITS",
  "BA_PROP_PROTOCOL_CONFORMANCE_CLASS",
  "BA_PROP_PROTOCOL_OBJECT_TYPES_SUPPORTED",
  "BA_PROP_PROTOCOL_SERVICES_SUPPORTED",
  "BA_PROP_PROTOCOL_VERSION",
  "BA_PROP_READ_ONLY",
  "BA_PROP_REASON_FOR_HALT",
  "BA_PROP_RECIPIENT",
  "BA_PROP_RECIPIENT_LIST",
  "BA_PROP_RELIABILITY",
  "BA_PROP_RELINQUISH_DEFAULT",
  "BA_PROP_REQUIRED",
  "BA_PROP_RESOLUTION",
  "BA_PROP_SEGMENTATION_SUPPORTED",
  "BA_PROP_SETPOINT",
  "BA_PROP_SETPOINT_REFERENCE",
  "BA_PROP_STATE_TEXT",
  "BA_PROP_STATUS_FLAGS",
  "BA_PROP_SYSTEM_STATUS",
  "BA_PROP_TIME_DELAY",
  "BA_PROP_TIME_OF_ACTIVE_TIME_RESET",
  "BA_PROP_TIME_OF_STATE_COUNT_RESET",
  "BA_PROP_TIME_SYNCHRONIZATION_RECIPIENTS",
  "BA_PROP_UNITS",
  "BA_PROP_UPDATE_INTERVAL",
  "BA_PROP_UTC_OFFSET",
  "BA_PROP_VENDOR_IDENTIFIER",
  "BA_PROP_VENDOR_NAME",
  "BA_PROP_VT_CLASSES_SUPPORTED",
  "BA_PROP_WEEKLY_SCHEDULE",
  "BA_PROP_ATTEMPTED_SAMPLES",
  "BA_PROP_AVERAGE_VALUE",
  "BA_PROP_BUFFER_SIZE",
  "BA_PROP_CLIENT_COV_INCREMENT",
  "BA_PROP_COV_RESUBSCRIPTION_INTERVAL",
  "BA_PROP_CURRENT_NOTIFY_TIME",
  "BA_PROP_EVENT_TIME_STAMPS",
  "BA_PROP_LOG_BUFFER",
  "BA_PROP_LOG_DEVICE_OBJECT_PROPERTY",
  "BA_PROP_ENABLE",
  "BA_PROP_LOG_INTERVAL",
  "BA_PROP_MAXIMUM_VALUE",
  "BA_PROP_MINIMUM_VALUE",
  "BA_PROP_NOTIFICATION_THRESHOLD",
  "BA_PROP_PREVIOUS_NOTIFY_TIME",
  "BA_PROP_PROTOCOL_REVISION",
  "BA_PROP_RECORDS_SINCE_NOTIFICATION",
  "BA_PROP_RECORD_COUNT",
  "BA_PROP_START_TIME",
  "BA_PROP_STOP_TIME",
  "BA_PROP_STOP_WHEN_FULL",
  "BA_PROP_TOTAL_RECORD_COUNT",
  "BA_PROP_VALID_SAMPLES",
  "BA_PROP_WINDOW_INTERVAL",
  "BA_PROP_WINDOW_SAMPLES",
  "BA_PROP_MAXIMUM_VALUE_TIMESTAMP",
  "BA_PROP_MINIMUM_VALUE_TIMESTAMP",
  "BA_PROP_VARIANCE_VALUE",
  "BA_PROP_ACTIVE_COV_SUBSCRIPTIONS",
  "BA_PROP_BACKUP_FAILURE_TIMEOUT",
  "BA_PROP_CONFIGURATION_FILES",
  "BA_PROP_DATABASE_REVISION",
  "BA_PROP_DIRECT_READING",
  "BA_PROP_LAST_RESTORE_TIME",
  "BA_PROP_MAINTENANCE_REQUIRED",
  "BA_PROP_MEMBER_OF",
  "BA_PROP_MODE",
  "BA_PROP_OPERATION_REQUIRED",
  "BA_PROP_SETTING",
  "BA_PROP_SILENCED",
  "BA_PROP_TRACKING_VALUE",
  "BA_PROP_ZONE_MEMBERS",
  "BA_PROP_LIFE_SAFETY_ALARM_VALUES",
  "BA_PROP_MAX_SEGMENTS_ACCEPTED",
  "BA_PROP_PROFILE_NAME",
  "BA_PROP_AUTO_SLAVE_DISCOVERY",
  "BA_PROP_MANUAL_SLAVE_ADDRESS_BINDING",
  "BA_PROP_SLAVE_ADDRESS_BINDING",
  "BA_PROP_SLAVE_PROXY_ENABLE",
  "BA_PROP_LAST_NOTIFY_RECORD",
  "BA_PROP_SCHEDULE_DEFAULT",
  "BA_PROP_ACCEPTED_MODES",
  "BA_PROP_ADJUST_VALUE",
  "BA_PROP_COUNT",
  "BA_PROP_COUNT_BEFORE_CHANGE",
  "BA_PROP_COUNT_CHANGE_TIME",
  "BA_PROP_COV_PERIOD",
  "BA_PROP_INPUT_REFERENCE",
  "BA_PROP_LIMIT_MONITORING_INTERVAL",
  "BA_PROP_LOGGING_OBJECT",
  "BA_PROP_LOGGING_RECORD",
  "BA_PROP_PRESCALE",
  "BA_PROP_PULSE_RATE",
  "BA_PROP_SCALE",
  "BA_PROP_SCALE_FACTOR",
  "BA_PROP_UPDATE_TIME",
  "BA_PROP_VALUE_BEFORE_CHANGE",
  "BA_PROP_VALUE_SET",
  "BA_PROP_VALUE_CHANGE_TIME",
  "BA_PROP_ALIGN_INTERVALS",
  "BA_PROP_INTERVAL_OFFSET",
  "BA_PROP_LAST_RESTART_REASON",
  "BA_PROP_LOGGING_TYPE",
  "BA_PROP_RESTART_NOTIFICATION_RECIPIENTS",
  "BA_PROP_TIME_OF_DEVICE_RESTART",
  "BA_PROP_TIME_SYNCHRONIZATION_INTERVAL",
  "BA_PROP_TRIGGER",
  "BA_PROP_UTC_TIME_SYNCHRONIZATION_RECIPIENTS",
  "BA_PROP_NODE_SUBTYPE",
  "BA_PROP_NODE_TYPE",
  "BA_PROP_STRUCTURED_OBJECT_LIST",
  "BA_PROP_SUBORDINATE_ANNOTATIONS",
  "BA_PROP_SUBORDINATE_LIST",
  "BA_PROP_ACTUAL_SHED_LEVEL",
  "BA_PROP_DUTY_WINDOW",
  "BA_PROP_EXPECTED_SHED_LEVEL",
  "BA_PROP_FULL_DUTY_BASELINE",
  "BA_PROP_REQUESTED_SHED_LEVEL",
  "BA_PROP_SHED_DURATION",
  "BA_PROP_SHED_LEVEL_DESCRIPTIONS",
  "BA_PROP_SHED_LEVELS",
  "BA_PROP_DOOR_ALARM_STATE",
  "BA_PROP_DOOR_EXTENDED_PULSE_TIME",
  "BA_PROP_DOOR_MEMBERS",
  "BA_PROP_DOOR_OPEN_TOO_LONG_TIME",
  "BA_PROP_DOOR_PULSE_TIME",
  "BA_PROP_DOOR_STATUS",
  "BA_PROP_DOOR_UNLOCK_DELAY_TIME",
  "BA_PROP_LOCK_STATUS",
  "BA_PROP_MASKED_ALARM_VALUES",
  "BA_PROP_SECURED_STATUS",
  "BA_PROP_BACKUP_AND_RESTORE_STATE",
  "BA_PROP_BACKUP_PREPARATION_TIME",
  "BA_PROP_RESTORE_COMPLETION_TIME",
  "BA_PROP_RESTORE_PREPARATION_TIME",
  "BA_PROP_USER_DESIGNATION",
  "BA_PROP_SURROUND",
  "BA_PROP_INTERFACE_LIST",
  "BA_PROP_LOCAL_LIST",
  "BA_PROP_HIERARCHY_LIST",
  "BA_PROP_ELEMENT_TYPE",
  "BA_PROP_OBJECT_TAG",
  "BA_PROP_FUNCTION_NAME",
  "BA_PROP_LOW_VALUE",
  "BA_PROP_HIGH_VALUE",
  "BA_PROP_PARAMETER_KIND",
  "BA_PROP_ALARM_ENABLE",
  "BA_PROP_LOCKED",
  "BA_PROP_TIME_OF_ACKED",
  "BA_PROP_ACK_INITIALS",
  "BA_PROP_MESSAGE_TEXT",
  "BA_PROP_SLOPE",
  "BA_PROP_INTERCEPT",
  "BA_PROP_ADDRESS",
  "BA_PROP_COMMISSIONING_STATE",
  "BA_PROP_NAME_REFERENCE",
  "BA_PROP_FEEDBACK_ADDR",
  "BA_PROP_DESTINATION_LIST",
  "BA_PROP_SITE_NAME",
  "BA_PROP_PRIMARY_DEVICE",
  "BA_PROP_GLOBAL_OBJECTS_MODIFICATION_TIME",
  "BA_PROP_GLOBAL_OBJECTS_UPDATE_TIME",
  "BA_PROP_SYNCH_REQUEST_PERIOD",
  "BA_PROP_PROGRAM_MODIFICATION_TIME",
  "BA_PROP_MIN_CYCLE_TIME",
  "BA_PROP_MAX_CYCLE_TIME",
  "BA_PROP_CYCLE_TIME_STATISTICS",
  "BA_PROP_MEMORY_STATISTICS",
  "BA_PROP_COMMUNICATION_STATISTICS",
  "BA_PROP_SERIAL_LINE_STATISTICS",
  "BA_PROP_DIAGNOSTICS",
  "BA_PROP_MAIN_PARAMETER",
  "BA_PROP_ACCESS_RIGHT",
  "BA_PROP_MAX_SIZE",
  "BA_PROP_MIN_SIZE",
  "BA_PROP_ENABLE_ACTIVE_TIME",
  "BA_PROP_ELAPSED_TIME_LIMIT",
  "BA_PROP_TOTAL_ACTIVE_TIME",
  "BA_PROP_SHADOW_DEV_OBJ_ID",
  "BA_PROP_SHADOW_DEV_OBJ_NAME",
  "BA_PROP_EXPIRED_DATE",
  "BA_PROP_FEEDBACK_POLARITY",
  "BA_PROP_FEEDBACK_SLOPE",
  "BA_PROP_FEEDBACK_INTERCEPT",
  "BA_PROP_EXCEPTIONS",
  "BA_PROP_NEXT_VALUE",
  "BA_PROP_NEXT_TIME",
  "BA_PROP_PARAMETER_LIST",
  "BA_PROP_LIST_OF_NAME_REFERENCE",
  "BA_PROP_DAYLIGHT_SAVING_BEGIN_DATE",
  "BA_PROP_DAYLIGHT_SAVING_BEGIN_TIME",
  "BA_PROP_DAYLIGHT_SAVING_END_DATE",
  "BA_PROP_DAYLIGHT_SAVING_END_TIME",
  "BA_PROP_OPERATING_HOURS_MESSAGE",
  "BA_PROP_EXPIRED",
  "BA_PROP_ELAPSED_TIME",
  "BA_PROP_MAX_INSTR_COUNT",
  "BA_PROP_RECLAIM_TIME",
  "BA_PROP_YESTERDAY",
  "BA_PROP_NEXT_DATE",
  "BA_PROP_VISIBILITY",
  "BA_PROP_SERVER_TYPE",
  "BA_PROP_NAME_RESOLUTION_INTERVAL",
  "BA_PROP_SHADOW_APDU_SEGMENT_TIMEOUT",
  "BA_PROP_SHADOW_APDU_TIMEOUT",
  "BA_PROP_SHADOW_MAX_APDU_LENGTH_ACCEPTED",
  "BA_PROP_SHADOW_NUMBER_OF_APDU_RETRIES",
  "BA_PROP_GLOBAL",
  "BA_PROP_STARTUP_STATISTIC",
  "BA_PROP_DATETIME_SUBTYPE",
  "BA_PROP_USERS",
  "BA_PROP_USERGROUPS",
  "BA_PROP_SCOPES",
  "BA_PROP_LAST_MODIFICATION",
  "BA_PROP_GROUP",
  "BA_PROP_MAXNR_CALL_REPETITIONS",
  "BA_PROP_TERMINATION_TIME_VALUE",
  "BA_PROP_ACCESS_PASSWORD",
  "BA_PROP_COM_INTERFACE_LIST",
  "BA_PROP_CONNECTION_LIST",
  "BA_PROP_MODEM_STATISTICS",
  "BA_PROP_MODEM_SETTINGS",
  "BA_PROP_MODEM_STATUS",
  "BA_PROP_CONNECT",
  "BA_PROP_NETWORK_NUMBER",
  "BA_PROP_ALARM_PRIO_LIMIT",
  "BA_PROP_TOMORROW",
  "BA_PROP_DAY_AFTER_TOMORROW",
  "BA_PROP_INTERVAL",
  "BA_PROP_LAST_MESSAGE",
  "BA_PROP_GROUP_MEMBERS",
  "BA_PROP_ROOM_MEMBERS",
  "BA_PROP_MENU_LINES",
  "BA_PROP_TIME_DELAY1",
  "BA_PROP_TIME_DELAY2",
  "BA_PROP_IO_STATISTICS",
  "BA_PROP_DELAY_ON",
  "BA_PROP_DELAY_OFF",
  "BA_PROP_ALARM_COLLECTION_REF",
  "BA_PROP_ALARM_CLASS",
  "BA_PROP_SWITCH_UP",
  "BA_PROP_SWITCH_DOWN",
  "BA_PROP_PRESENT_POWER",
  "BA_PROP_CONTROLLED_POWER",
  "BA_PROP_IP_PARAMETERS",
  "BA_PROP_DPX_SUBSTITUTION_VALUE",
  "BA_PROP_DPX_DESCRIPTION_LIST",
  "BA_PROP_DPX_ALARM_FUNCTION",
  "BA_PROP_DPX_HEARTBEAT",
  "BA_PROP_DPX_JITTER_SUPPRESS",
  "BA_PROP_DPX_RELIABILITY_ERROR_LIST",
  "BA_PROP_DPX_POLLING_CYCLE",
  "BA_PROP_DPX_EVENT_COUNT",
  "BA_PROP_DPX_EXTENDED_NOTIFY",
  "BA_PROP_DPX_LOG_STATUS",
  "BA_PROP_DPX_SET_VALUE",
  "BA_PROP_DPX_INTEGRAL_TIME",
  "BA_PROP_DPX_NEUTRAL_ZONE",
  "BA_PROP_DPX_DERIVATIVE_TIME",
  "BA_PROP_DPX_TI0TO100",
  "BA_PROP_DPX_TI100TO0",
  "BA_PROP_DPX_LOOP_STATE",
  "BA_PROP_DPX_SETPOINT_RESOLUTION",
  "BA_PROP_DPX_SETPOINT_HIGH_VALUE",
  "BA_PROP_DPX_SETPOINT_LOW_VALUE",
  "BA_PROP_DPX_ENABLE_LOG",
  "BA_PROP_DPX_ALARM_CLASS_TEXT",
  "BA_PROP_DPX_EXTENDED_COMMAND",
  "BA_PROP_DPX_FILE_OPERATION",
  "BA_PROP_DPX_PULSECOUNT",
  "BA_PROP_DPX_DATA_TIME_STAMP",
  "BA_PROP_DPX_DATA_SOURCE",
  "BA_PROP_DPX_SERIALIZATION_IN_PROGRESS",
  "BA_PROP_DPX_AVAILABLE_FILE_STORAGE",
  "BA_PROP_DPX_DEVICE_INFO_REFERENCE",
  "BA_PROP_DPX_SCALE_FACTOR",
  "BA_PROP_DPX_COUNT",
  "BA_PROP_DPX_COUNT_BEFORE_RESET",
  "BA_PROP_DPX_COV_PERIOD",
  "BA_PROP_DPX_RESET_TIME",
  "BA_PROP_DPX_RESET_VALUE",
  "BA_PROP_DPX_TOTAL_COUNT",
  "BA_PROP_DPX_UPDATE_TIME",
  "BA_PROP_DPX_S_IN_PROCESS",
  "BA_PROP_DPX_S_FEEDBACK_VALUE",
  "BA_PROP_DPX_RESOLUTION",
  "BA_PROP_DPX_S_UNIT",
  "BA_PROP_DPX_S_INACTIVE_TEXT",
  "BA_PROP_DPX_S_ACTIVE_TEXT",
  "BA_PROP_DPX_S_NUMBER_OF_STATES",
  "BA_PROP_DPX_S_STATE_TEXT",
  "BA_PROP_DPX_S_RECIPIENT_LIST",
  "BA_PROP_DPX_S_BUFFER_SIZE",
  "BA_PROP_DPX_S_RECORD_COUNT",
  "BA_PROP_DPX_S_NOTIFICATION_THRESHOLD",
  "BA_PROP_DPX_S_BCKUP_SRVR_LIST",
  "BA_PROP_DPX_S_OUT_OF_SERVICE",
  "BA_PROP_DPX_S_ELAPSED_ACTIVE_TIME",
  "BA_PROP_DPX_S_TIME_OF_ACTIVE_TIME_RESET",
  "BA_PROP_DPX_S_MINIMUM_ON_TIME",
  "BA_PROP_DPX_S_MINIMUM_OFF_TIME",
  "BA_PROP_DPX_S_COV_RESUBSCRIPTION_INTERVAL",
  "BA_PROP_DPX_ACTUAL_VALUE",
  "BA_PROP_DPX_S_RELIABILITY",
  "BA_PROP_DPX_S_STATUS_FLAGS",
  "BA_PROP_DPX_ENABLE_CHANGE_OF_STATE_COUNT",
  "BA_PROP_DPX_TECHNICAL_DESIGNATION",
  "BA_PROP_DS7_INPUT_PTP",
  "BA_PROP_DS1_ENABLE_MEMORIZE_FUNCTION",
  "BA_PROP_DS1_RESOLUTION",
  "BA_PROP_DS1_MIN_PRESENT_VALUE",
  "BA_PROP_DS1_MAX_PRESENT_VALUE",
  "BA_PROP_DS1_PRESENT_COMMAND",
  "BA_PROP_DS1_RELIABILITY",
  "BA_PROP_DS1_SIEMENS_URL",
  "BA_PROP_DS1_LIST_OF_ITEM_ATTRIBUTES",
  "BA_PROP_DS1_LIST_OF_ANNOTATIONS",
  "BA_PROP_DS1_LIST_OF_OBJECT_PROPERTY_REF",
  "BA_PROP_DS1_GROUP_MASTER",
  "BA_PROP_DS1_GROUP_MEMBERS",
  "BA_PROP_DS1_COLLECTED_DATA",
  "BA_PROP_DS1_GROUP_COMMAND",
  "BA_PROP_DS1_GROUP_NUMBER",
  "BA_PROP_DS1_GROUP_CATEGORY_TEXT",
  "BA_PROP_DS1_GROUP_CATEGORY",
  "BA_PROP_DS1_SOURCE_PROPERTY_ID",
  "BA_PROP_DS1_SOURCE_OBJECT_TAG",
  "BA_PROP_DS1_MEMORIZE_VALUE",
  "BA_PROP_DS1_RAMP_RATE",
  "BA_PROP_DS1_BINARY_THRESHOLD",
  "BA_PROP_DS1_BINARY_PRESENT_VALUE",
  "BA_PROP_DS1_BURN_IN_TIME",
  "BA_PROP_DS1_FADE_TIME",
  "BA_PROP_DS1_IN_PROCESS",
  "BA_PROP_DS1_LIFECYCLE_STATE",
  "BA_PROP_DS1_LIFE_TIME",
  "BA_PROP_DS1_MIN_ACTUAL_VALUE",
  "BA_PROP_DS1_MAX_ACTUAL_VALUE",
  "BA_PROP_DS1_COMPRESSION",
  "BA_PROP_DS1_CHECKSUM",
  "BA_PROP_DS1_FILE_FEATURES",
  "BA_PROP_DS1_RT_SEQUENCE_COUNT",
  "BA_PROP_DS1_ENGINEERING_COUNT",
  "BA_PROP_DS1_PROGRESS_VALUE",
  "BA_PROP_DS1_CONTROL_COMMAND",
  "BA_PROP_DS1_RELINQUISH_DEFAULT_CONTROL",
  "BA_PROP_DS1_SUBORDINATE_ATTRIBUTES",
  "BA_PROP_DS1_PERIPHERAL_DEVICE_TYPE",
  "BA_PROP_DS1_ABORT_COMMAND",
  "BA_PROP_DS1_LASTMOVING_DIRECTION",
  "BA_PROP_DS1_LIGHTING_VALUE",
  "BA_PROP_DS1_LIGHTING_STATE",
  "BA_PROP_DS1_IOADDRESS",
  "BA_PROP_DS1_PRESENT_PRIORITY",
  "BA_PROP_DS1_UPDATE_COUNT",
  "BA_PROP_DS1_DEVICE_COMMAND",
  "BA_PROP_DS1_ORPHAN_LIST",
  "BA_PROP_DS1_FIELD_BUS_INFO",
  "BA_PROP_DS1_DEVICE_COMMAND_RESULT",
  "BA_PROP_DS1_FIELD_BUS_COMMAND",
  "BA_PROP_DS1_SERIAL_NUMBER",
  "BA_PROP_DS1_PERIPHERAL_DEVICE_INFO",
  "BA_PROP_DS1_BA_PROTOTYPE",
  "BA_PROP_DS1_COMMISSIONING_INFO",
  "BA_PROP_DS1_COMMISSIONING_STATE",
  "BA_PROP_DS1_CORRECTION_FACTOR",
  "BA_PROP_DS1_CORRECTION_OFFSET",
  "BA_PROP_DS1_TRACKING_VALUE",
  "BA_PROP_DS1_S1_DEVICE_FEATURES",
  "BA_PROP_DS1_ITEM_LIST",
  "BA_PROP_DS1_DATA_TIMESTAMP",
  "BA_PROP_DS1_OBJECT_ATTRIBUTES",
  "BA_PROP_DS1_INTERNAL_OVERRIDE",
  "BA_PROP_DS1_AVAILABLE_FLASH",
  "BA_PROP_DS1_AVAILABLE_MEMORY",
  "BA_PROP_ISA_EVENT_MESSAGE_TEXTS",
  "BA_PROP_ISA_FUNCTION_SETS",
  "BA_PROP_ISA_VERSION",
  "BA_PROP_PPCL_STATEMENT",
  "BA_PROP_DS1_SOURCE_DATA_TAG",
  "BA_PROP_DS1_SOURCE_PROPERTY_TAG",
  "BA_PROP_DS1_ITEM_VALUE_DATA_TAG",
  "BA_PROP_DS1_ITEM_VALUE_OPERATION",
  "BA_PROP_DS1_ITEM_VALUE_PRIORITY",
  "BA_PROP_DS1_ITEM_VALUE",
  "BA_PROP_DS1_ITEM_RELIABILITY",
  "BA_PROP_DS1_COLLECTED_DATA_SEQ_NUMBER",
  "BA_PROP_ANYORDUMMY_VALUE"
};
const std::map<int, const char*> _Property_Type_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(481, _kProperty_TypeValues, _kProperty_TypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kObject_TypeValues[] = {
  Object_Type::BA_OBJ_ANALOG_INPUT,
  Object_Type::BA_OBJ_ANALOG_OUTPUT,
  Object_Type::BA_OBJ_ANALOG_VALUE,
  Object_Type::BA_OBJ_BINARY_INPUT,
  Object_Type::BA_OBJ_BINARY_OUTPUT,
  Object_Type::BA_OBJ_BINARY_VALUE,
  Object_Type::BA_OBJ_CALENDAR,
  Object_Type::BA_OBJ_COMMAND,
  Object_Type::BA_OBJ_DEVICE,
  Object_Type::BA_OBJ_EVENT_ENROLLMENT,
  Object_Type::BA_OBJ_FILE,
  Object_Type::BA_OBJ_GROUP,
  Object_Type::BA_OBJ_LOOP,
  Object_Type::BA_OBJ_MULTISTATE_INPUT,
  Object_Type::BA_OBJ_MULTISTATE_OUTPUT,
  Object_Type::BA_OBJ_NOTIFICATION_CLASS,
  Object_Type::BA_OBJ_PROGRAM,
  Object_Type::BA_OBJ_SCHEDULE,
  Object_Type::BA_OBJ_AVERAGING,
  Object_Type::BA_OBJ_MULTISTATE_VALUE,
  Object_Type::BA_OBJ_TREND_LOG,
  Object_Type::BA_OBJ_LIFE_SAFETY_POINT,
  Object_Type::BA_OBJ_LIFE_SAFETY_ZONE,
  Object_Type::BA_OBJ_ACCUMULATOR,
  Object_Type::BA_OBJ_PULSE_CONVERTER,
  Object_Type::BA_OBJ_EVENT_LOG,
  Object_Type::BA_OBJ_GLOBAL_GROUP,
  Object_Type::BA_OBJ_TREND_LOG_MULTIPLE,
  Object_Type::BA_OBJ_LOAD_CONTROL,
  Object_Type::BA_OBJ_STRUCTURED_VIEW,
  Object_Type::BA_OBJ_ACCESS_DOOR,
  Object_Type::BA_OBJ_ACCESS_CREDENTIAL,
  Object_Type::BA_OBJ_ACCESS_POINT,
  Object_Type::BA_OBJ_ACCESS_RIGHTS,
  Object_Type::BA_OBJ_ACCESS_USER,
  Object_Type::BA_OBJ_ACCESS_ZONE,
  Object_Type::BA_OBJ_CREDENTIAL_DATA_INPUT,
  Object_Type::BA_OBJ_BITSTRING_VALUE,
  Object_Type::BA_OBJ_CHARACTERSTRING_VALUE,
  Object_Type::BA_OBJ_DATE_PATTERN_VALUE,
  Object_Type::BA_OBJ_DATE_VALUE,
  Object_Type::BA_OBJ_DATETIME_PATTERN_VALUE,
  Object_Type::BA_OBJ_DATETIME_VALUE,
  Object_Type::BA_OBJ_INTEGER_VALUE,
  Object_Type::BA_OBJ_LARGE_ANALOG_VALUE,
  Object_Type::BA_OBJ_OCTETSTRING_VALUE,
  Object_Type::BA_OBJ_POSITIVE_INTEGER_VALUE,
  Object_Type::BA_OBJ_TIME_PATTERN_VALUE,
  Object_Type::BA_OBJ_TIME_VALUE,
  Object_Type::BA_OBJ_HIERARCHY,
  Object_Type::BA_OBJ_BLOCK,
  Object_Type::BA_OBJ_CMN_ALM,
  Object_Type::BA_OBJ_DEVINFO,
  Object_Type::BA_OBJ_DS1_GROUP_MEMBER,
  Object_Type::BA_OBJ_DS1_GROUP_MASTER,
  Object_Type::BA_OBJ_DS1_BLINDS_OUTPUT,
  Object_Type::BA_OBJ_DS1_BLINDS_INPUT,
  Object_Type::BA_OBJ_DS1_LIGHT_OUTPUT_ANALOG,
  Object_Type::BA_OBJ_DS1_LIGHT_OUTPUT_BINARY,
  Object_Type::BA_OBJ_DS1_LIGHT_INPUT,
  Object_Type::BA_OBJ_ANYORDUMMY_VALUE
};
const char* _kObject_TypeNames[] = {
  "BA_OBJ_ANALOG_INPUT",
  "BA_OBJ_ANALOG_OUTPUT",
  "BA_OBJ_ANALOG_VALUE",
  "BA_OBJ_BINARY_INPUT",
  "BA_OBJ_BINARY_OUTPUT",
  "BA_OBJ_BINARY_VALUE",
  "BA_OBJ_CALENDAR",
  "BA_OBJ_COMMAND",
  "BA_OBJ_DEVICE",
  "BA_OBJ_EVENT_ENROLLMENT",
  "BA_OBJ_FILE",
  "BA_OBJ_GROUP",
  "BA_OBJ_LOOP",
  "BA_OBJ_MULTISTATE_INPUT",
  "BA_OBJ_MULTISTATE_OUTPUT",
  "BA_OBJ_NOTIFICATION_CLASS",
  "BA_OBJ_PROGRAM",
  "BA_OBJ_SCHEDULE",
  "BA_OBJ_AVERAGING",
  "BA_OBJ_MULTISTATE_VALUE",
  "BA_OBJ_TREND_LOG",
  "BA_OBJ_LIFE_SAFETY_POINT",
  "BA_OBJ_LIFE_SAFETY_ZONE",
  "BA_OBJ_ACCUMULATOR",
  "BA_OBJ_PULSE_CONVERTER",
  "BA_OBJ_EVENT_LOG",
  "BA_OBJ_GLOBAL_GROUP",
  "BA_OBJ_TREND_LOG_MULTIPLE",
  "BA_OBJ_LOAD_CONTROL",
  "BA_OBJ_STRUCTURED_VIEW",
  "BA_OBJ_ACCESS_DOOR",
  "BA_OBJ_ACCESS_CREDENTIAL",
  "BA_OBJ_ACCESS_POINT",
  "BA_OBJ_ACCESS_RIGHTS",
  "BA_OBJ_ACCESS_USER",
  "BA_OBJ_ACCESS_ZONE",
  "BA_OBJ_CREDENTIAL_DATA_INPUT",
  "BA_OBJ_BITSTRING_VALUE",
  "BA_OBJ_CHARACTERSTRING_VALUE",
  "BA_OBJ_DATE_PATTERN_VALUE",
  "BA_OBJ_DATE_VALUE",
  "BA_OBJ_DATETIME_PATTERN_VALUE",
  "BA_OBJ_DATETIME_VALUE",
  "BA_OBJ_INTEGER_VALUE",
  "BA_OBJ_LARGE_ANALOG_VALUE",
  "BA_OBJ_OCTETSTRING_VALUE",
  "BA_OBJ_POSITIVE_INTEGER_VALUE",
  "BA_OBJ_TIME_PATTERN_VALUE",
  "BA_OBJ_TIME_VALUE",
  "BA_OBJ_HIERARCHY",
  "BA_OBJ_BLOCK",
  "BA_OBJ_CMN_ALM",
  "BA_OBJ_DEVINFO",
  "BA_OBJ_DS1_GROUP_MEMBER",
  "BA_OBJ_DS1_GROUP_MASTER",
  "BA_OBJ_DS1_BLINDS_OUTPUT",
  "BA_OBJ_DS1_BLINDS_INPUT",
  "BA_OBJ_DS1_LIGHT_OUTPUT_ANALOG",
  "BA_OBJ_DS1_LIGHT_OUTPUT_BINARY",
  "BA_OBJ_DS1_LIGHT_INPUT",
  "BA_OBJ_ANYORDUMMY_VALUE"
};
const std::map<int, const char*> _Object_Type_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(61, _kObject_TypeValues, _kObject_TypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kObject_PrototypeValues[] = {
  Object_Prototype::BA_PROT_ANALOGINPUT,
  Object_Prototype::BA_PROT_ANALOGPROCESSVALUE,
  Object_Prototype::BA_PROT_ANALOGOUTPUT,
  Object_Prototype::BA_PROT_BINARYINPUT,
  Object_Prototype::BA_PROT_BINARYPROCESSVALUE,
  Object_Prototype::BA_PROT_BINARYOUTPUT,
  Object_Prototype::BA_PROT_MULTISTATEINPUT,
  Object_Prototype::BA_PROT_MULTISTATEPROCESSVALUE,
  Object_Prototype::BA_PROT_MULTISTATEOUTPUT,
  Object_Prototype::BA_PROT_DEVICEOBJECT,
  Object_Prototype::BA_PROT_ANALOGCONFIGVALUE,
  Object_Prototype::BA_PROT_ANALOGCALCULATEDVALUE,
  Object_Prototype::BA_PROT_BINARYCONFIGVALUE,
  Object_Prototype::BA_PROT_BINARYCALCULATEDVALUE,
  Object_Prototype::BA_PROT_MULTISTATECONFIGVALUE,
  Object_Prototype::BA_PROT_MULTISTATECALCULATEDVALUE,
  Object_Prototype::BA_PROT_UNSIGNEDCONFIGVALUE,
  Object_Prototype::BA_PROT_LIGHTINPUT,
  Object_Prototype::BA_PROT_LIGHTOUTPUTANALOG,
  Object_Prototype::BA_PROT_LIGHTOUTPUTBINARY,
  Object_Prototype::BA_PROT_BLINDSINPUT,
  Object_Prototype::BA_PROT_BLINDSOUTPUT,
  Object_Prototype::BA_PROT_PERIPHERALDEVICE,
  Object_Prototype::BA_PROT_FIELDBUSMANAGEMENT,
  Object_Prototype::BA_PROT_FILEOBJECT,
  Object_Prototype::BA_PROT_COMMAND,
  Object_Prototype::BA_PROT_GROUPMASTER,
  Object_Prototype::BA_PROT_GROUPMEMBER,
  Object_Prototype::BA_PROT_EVENTLOG,
  Object_Prototype::BA_PROT_TRENDLOG_SIMPLE,
  Object_Prototype::BA_PROT_NOTIFICATIONCLASS,
  Object_Prototype::BA_PROT_VNOBJECTFUNCTIONAL,
  Object_Prototype::BA_PROT_VNOBJECTCOLLECTION,
  Object_Prototype::BA_PROT_VNOBJECTDEVICE,
  Object_Prototype::BA_PROT_VNOBJECTNETWORK,
  Object_Prototype::BA_PROT_VNOBJECTAREA,
  Object_Prototype::BA_PROT_ANYORDUMMY_VALUE
};
const char* _kObject_PrototypeNames[] = {
  "BA_PROT_ANALOGINPUT",
  "BA_PROT_ANALOGPROCESSVALUE",
  "BA_PROT_ANALOGOUTPUT",
  "BA_PROT_BINARYINPUT",
  "BA_PROT_BINARYPROCESSVALUE",
  "BA_PROT_BINARYOUTPUT",
  "BA_PROT_MULTISTATEINPUT",
  "BA_PROT_MULTISTATEPROCESSVALUE",
  "BA_PROT_MULTISTATEOUTPUT",
  "BA_PROT_DEVICEOBJECT",
  "BA_PROT_ANALOGCONFIGVALUE",
  "BA_PROT_ANALOGCALCULATEDVALUE",
  "BA_PROT_BINARYCONFIGVALUE",
  "BA_PROT_BINARYCALCULATEDVALUE",
  "BA_PROT_MULTISTATECONFIGVALUE",
  "BA_PROT_MULTISTATECALCULATEDVALUE",
  "BA_PROT_UNSIGNEDCONFIGVALUE",
  "BA_PROT_LIGHTINPUT",
  "BA_PROT_LIGHTOUTPUTANALOG",
  "BA_PROT_LIGHTOUTPUTBINARY",
  "BA_PROT_BLINDSINPUT",
  "BA_PROT_BLINDSOUTPUT",
  "BA_PROT_PERIPHERALDEVICE",
  "BA_PROT_FIELDBUSMANAGEMENT",
  "BA_PROT_FILEOBJECT",
  "BA_PROT_COMMAND",
  "BA_PROT_GROUPMASTER",
  "BA_PROT_GROUPMEMBER",
  "BA_PROT_EVENTLOG",
  "BA_PROT_TRENDLOG_SIMPLE",
  "BA_PROT_NOTIFICATIONCLASS",
  "BA_PROT_VNOBJECTFUNCTIONAL",
  "BA_PROT_VNOBJECTCOLLECTION",
  "BA_PROT_VNOBJECTDEVICE",
  "BA_PROT_VNOBJECTNETWORK",
  "BA_PROT_VNOBJECTAREA",
  "BA_PROT_ANYORDUMMY_VALUE"
};
const std::map<int, const char*> _Object_Prototype_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(37, _kObject_PrototypeValues, _kObject_PrototypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kWrite_PriorityValues[] = {
  Write_Priority::BA_PRIO_MANUAL_LIFE_SAFETY,
  Write_Priority::BA_PRIO_MANUAL_AUTOMATIC_LIFE_SAFETY,
  Write_Priority::BA_PRIO_AVAILABLE3,
  Write_Priority::BA_PRIO_AVAILABLE4,
  Write_Priority::BA_PRIO_CRITICAL_EQUIPT_CTRL,
  Write_Priority::BA_PRIO_MIN_ON_OFF,
  Write_Priority::BA_PRIO_AVAILABLE7,
  Write_Priority::BA_PRIO_MANUAL_OPERATOR,
  Write_Priority::BA_PRIO_AVAILABLE9,
  Write_Priority::BA_PRIO_AVAILABLE10,
  Write_Priority::BA_PRIO_AVAILABLE11,
  Write_Priority::BA_PRIO_AVAILABLE12,
  Write_Priority::BA_PRIO_AVAILABLE13,
  Write_Priority::BA_PRIO_AVAILABLE14,
  Write_Priority::BA_PRIO_AVAILABLE15,
  Write_Priority::BA_PRIO_AVAILABLE16
};
const char* _kWrite_PriorityNames[] = {
  "BA_PRIO_MANUAL_LIFE_SAFETY",
  "BA_PRIO_MANUAL_AUTOMATIC_LIFE_SAFETY",
  "BA_PRIO_AVAILABLE3",
  "BA_PRIO_AVAILABLE4",
  "BA_PRIO_CRITICAL_EQUIPT_CTRL",
  "BA_PRIO_MIN_ON_OFF",
  "BA_PRIO_AVAILABLE7",
  "BA_PRIO_MANUAL_OPERATOR",
  "BA_PRIO_AVAILABLE9",
  "BA_PRIO_AVAILABLE10",
  "BA_PRIO_AVAILABLE11",
  "BA_PRIO_AVAILABLE12",
  "BA_PRIO_AVAILABLE13",
  "BA_PRIO_AVAILABLE14",
  "BA_PRIO_AVAILABLE15",
  "BA_PRIO_AVAILABLE16"
};
const std::map<int, const char*> _Write_Priority_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(16, _kWrite_PriorityValues, _kWrite_PriorityNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kBAPA_READACCESS_TYPEValues[] = {
  BAPA_READACCESS_TYPE::BA_RA_NOACCESS,
  BAPA_READACCESS_TYPE::BA_RA_INTERNAL,
  BAPA_READACCESS_TYPE::BA_RA_EXTENDED_SERVICE,
  BAPA_READACCESS_TYPE::BA_RA_BASIC_SERVICE,
  BAPA_READACCESS_TYPE::BA_RA_ADMINISTRATOR,
  BAPA_READACCESS_TYPE::BA_RA_EXTENDED_OPERATION,
  BAPA_READACCESS_TYPE::BA_RA_STANDARD_OPEARATION,
  BAPA_READACCESS_TYPE::BA_RA_BASIC_OPERATION
};
const char* _kBAPA_READACCESS_TYPENames[] = {
  "BA_RA_NOACCESS",
  "BA_RA_INTERNAL",
  "BA_RA_EXTENDED_SERVICE",
  "BA_RA_BASIC_SERVICE",
  "BA_RA_ADMINISTRATOR",
  "BA_RA_EXTENDED_OPERATION",
  "BA_RA_STANDARD_OPEARATION",
  "BA_RA_BASIC_OPERATION"
};
const std::map<int, const char*> _BAPA_READACCESS_TYPE_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(8, _kBAPA_READACCESS_TYPEValues, _kBAPA_READACCESS_TYPENames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kBAPA_WRITEACCESS_TYPEValues[] = {
  BAPA_WRITEACCESS_TYPE::BA_WR_NOACCESS,
  BAPA_WRITEACCESS_TYPE::BA_WR_INTERNAL,
  BAPA_WRITEACCESS_TYPE::BA_WR_EXTENDED_SERVICE,
  BAPA_WRITEACCESS_TYPE::BA_WR_BASIC_SERVICE,
  BAPA_WRITEACCESS_TYPE::BA_WR_ADMINISTRATOR,
  BAPA_WRITEACCESS_TYPE::BA_WR_EXTENDED_OPERATION,
  BAPA_WRITEACCESS_TYPE::BA_WR_STANDARD_OPEARATION,
  BAPA_WRITEACCESS_TYPE::BA_WR_BASIC_OPERATION
};
const char* _kBAPA_WRITEACCESS_TYPENames[] = {
  "BA_WR_NOACCESS",
  "BA_WR_INTERNAL",
  "BA_WR_EXTENDED_SERVICE",
  "BA_WR_BASIC_SERVICE",
  "BA_WR_ADMINISTRATOR",
  "BA_WR_EXTENDED_OPERATION",
  "BA_WR_STANDARD_OPEARATION",
  "BA_WR_BASIC_OPERATION"
};
const std::map<int, const char*> _BAPA_WRITEACCESS_TYPE_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(8, _kBAPA_WRITEACCESS_TYPEValues, _kBAPA_WRITEACCESS_TYPENames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kPasswordTypeValues[] = {
  PasswordType::PW_PLAIN,
  PasswordType::PW_MD5
};
const char* _kPasswordTypeNames[] = {
  "PW_PLAIN",
  "PW_MD5"
};
const std::map<int, const char*> _PasswordType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kPasswordTypeValues, _kPasswordTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kControlProgramStateValues[] = {
  ControlProgramState::S7_STOP_UPDATE,
  ControlProgramState::S7_STOP_RESET,
  ControlProgramState::S7_STOP_INIT,
  ControlProgramState::S7_STOP_INTERNAL,
  ControlProgramState::S7_START_OB102,
  ControlProgramState::S7_START_OB100,
  ControlProgramState::S7_START_OB101,
  ControlProgramState::S7_RUN,
  ControlProgramState::S7_HALT,
  ControlProgramState::S7_DEFECTIVE,
  ControlProgramState::S7_POWER_OFF,
  ControlProgramState::NO_S7
};
const char* _kControlProgramStateNames[] = {
  "S7_STOP_UPDATE",
  "S7_STOP_RESET",
  "S7_STOP_INIT",
  "S7_STOP_INTERNAL",
  "S7_START_OB102",
  "S7_START_OB100",
  "S7_START_OB101",
  "S7_RUN",
  "S7_HALT",
  "S7_DEFECTIVE",
  "S7_POWER_OFF",
  "NO_S7"
};
const std::map<int, const char*> _ControlProgramState_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(12, _kControlProgramStateValues, _kControlProgramStateNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kDeviceStateValues[] = {
  DeviceState::DEV_RUN,
  DeviceState::DEV_HALT,
  DeviceState::DEV_RESTART,
  DeviceState::DEV_RESET
};
const char* _kDeviceStateNames[] = {
  "DEV_RUN",
  "DEV_HALT",
  "DEV_RESTART",
  "DEV_RESET"
};
const std::map<int, const char*> _DeviceState_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kDeviceStateValues, _kDeviceStateNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kResult_CodeValues[] = {
  Result_Code::RESULT_SUCCESS,
  Result_Code::RESULT_LOCATION_AUTHENTICATION_REQUIRED,
  Result_Code::RESULT_INVALID_ENTRY_ID,
  Result_Code::RESULT_USER_AUTHENTICATION_REQUIRED,
  Result_Code::RESULT_INVALID_CRENDENTIALS,
  Result_Code::RESULT_IMAGE_ERROR,
  Result_Code::RESULT_COMMAND_VALUE_ERROR,
  Result_Code::RESULT_COMMAND_SCHEDULE_ERROR,
  Result_Code::RESULT_COMMAND_TREND_ERROR,
  Result_Code::RESULT_XML_WRITING_FAILED,
  Result_Code::RESULT_OBJECT_NOT_FOUND,
  Result_Code::RESULT_OBJECT_DATA_NOT_READY,
  Result_Code::RESULT_PHASE_LIMIT_EXCEEDED,
  Result_Code::RESULT_SPECIAL_EVENT_LIMIT_EXCEEDED,
  Result_Code::RESULT_PROCESS_ERROR,
  Result_Code::RESULT_INVALID_ELEMENT_NUMBER,
  Result_Code::RESULT_COMMAND_MEMORIZE_FAILED
};
const char* _kResult_CodeNames[] = {
  "RESULT_SUCCESS",
  "RESULT_LOCATION_AUTHENTICATION_REQUIRED",
  "RESULT_INVALID_ENTRY_ID",
  "RESULT_USER_AUTHENTICATION_REQUIRED",
  "RESULT_INVALID_CRENDENTIALS",
  "RESULT_IMAGE_ERROR",
  "RESULT_COMMAND_VALUE_ERROR",
  "RESULT_COMMAND_SCHEDULE_ERROR",
  "RESULT_COMMAND_TREND_ERROR",
  "RESULT_XML_WRITING_FAILED",
  "RESULT_OBJECT_NOT_FOUND",
  "RESULT_OBJECT_DATA_NOT_READY",
  "RESULT_PHASE_LIMIT_EXCEEDED",
  "RESULT_SPECIAL_EVENT_LIMIT_EXCEEDED",
  "RESULT_PROCESS_ERROR",
  "RESULT_INVALID_ELEMENT_NUMBER",
  "RESULT_COMMAND_MEMORIZE_FAILED"
};
const std::map<int, const char*> _Result_Code_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(17, _kResult_CodeValues, _kResult_CodeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kCommand_TypeValues[] = {
  Command_Type::CMD_GET_MODEL_UPDATES,
  Command_Type::CMD_AUTHENTICATION_LOCATION,
  Command_Type::CMD_USER_LOGIN,
  Command_Type::CMD_USER_LOGOUT,
  Command_Type::CMD_SELECT_VIEW,
  Command_Type::CMD_SELECT_FUNCTION,
  Command_Type::CMD_COMMAND_VALUE,
  Command_Type::CMD_MODIFY_SERVER_SETTINGS,
  Command_Type::CMD_SCHEDULE,
  Command_Type::CMD_TREND,
  Command_Type::CMD_ALARM_ACKNOWLEDGE
};
const char* _kCommand_TypeNames[] = {
  "CMD_GET_MODEL_UPDATES",
  "CMD_AUTHENTICATION_LOCATION",
  "CMD_USER_LOGIN",
  "CMD_USER_LOGOUT",
  "CMD_SELECT_VIEW",
  "CMD_SELECT_FUNCTION",
  "CMD_COMMAND_VALUE",
  "CMD_MODIFY_SERVER_SETTINGS",
  "CMD_SCHEDULE",
  "CMD_TREND",
  "CMD_ALARM_ACKNOWLEDGE"
};
const std::map<int, const char*> _Command_Type_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(11, _kCommand_TypeValues, _kCommand_TypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kCoreFunctionValues[] = {
  CoreFunction::CORE_PLANT_VIEW,
  CoreFunction::CORE_FAVOURITES,
  CoreFunction::CORE_ALARMS,
  CoreFunction::CORE_SCHEDULE,
  CoreFunction::CORE_TREND,
  CoreFunction::CORE_SETTINGS,
  CoreFunction::CORE_DEFAULT
};
const char* _kCoreFunctionNames[] = {
  "CORE_PLANT_VIEW",
  "CORE_FAVOURITES",
  "CORE_ALARMS",
  "CORE_SCHEDULE",
  "CORE_TREND",
  "CORE_SETTINGS",
  "CORE_DEFAULT"
};
const std::map<int, const char*> _CoreFunction_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(7, _kCoreFunctionValues, _kCoreFunctionNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kAutoLogoutTimeValues[] = {
  AutoLogoutTime::ALT_5MIN,
  AutoLogoutTime::ALT_10MIN,
  AutoLogoutTime::ALT_15MIN,
  AutoLogoutTime::ALT_30MIN,
  AutoLogoutTime::ALT_45MIN,
  AutoLogoutTime::ALT_60MIN
};
const char* _kAutoLogoutTimeNames[] = {
  "ALT_5MIN",
  "ALT_10MIN",
  "ALT_15MIN",
  "ALT_30MIN",
  "ALT_45MIN",
  "ALT_60MIN"
};
const std::map<int, const char*> _AutoLogoutTime_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kAutoLogoutTimeValues, _kAutoLogoutTimeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kScreenSaverTiOutValues[] = {
  ScreenSaverTiOut::SST_5MIN,
  ScreenSaverTiOut::SST_10MIN,
  ScreenSaverTiOut::SST_15MIN,
  ScreenSaverTiOut::SST_30MIN,
  ScreenSaverTiOut::SST_45MIN,
  ScreenSaverTiOut::SST_60MIN,
  ScreenSaverTiOut::SST_DEFAULT
};
const char* _kScreenSaverTiOutNames[] = {
  "SST_5MIN",
  "SST_10MIN",
  "SST_15MIN",
  "SST_30MIN",
  "SST_45MIN",
  "SST_60MIN",
  "SST_DEFAULT"
};
const std::map<int, const char*> _ScreenSaverTiOut_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(7, _kScreenSaverTiOutValues, _kScreenSaverTiOutNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kNavigBarTiOutValues[] = {
  NavigBarTiOut::NBT_0FF,
  NavigBarTiOut::NBT_5MIN,
  NavigBarTiOut::NBT_10MIN,
  NavigBarTiOut::NBT_15MIN,
  NavigBarTiOut::NBT_30MIN,
  NavigBarTiOut::NBT_45MIN,
  NavigBarTiOut::NBT_60MIN,
  NavigBarTiOut::NBT_DEFAULT
};
const char* _kNavigBarTiOutNames[] = {
  "NBT_0FF",
  "NBT_5MIN",
  "NBT_10MIN",
  "NBT_15MIN",
  "NBT_30MIN",
  "NBT_45MIN",
  "NBT_60MIN",
  "NBT_DEFAULT"
};
const std::map<int, const char*> _NavigBarTiOut_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(8, _kNavigBarTiOutValues, _kNavigBarTiOutNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kKeyBoardLayoutValues[] = {
  KeyBoardLayout::KBL_STANDARD,
  KeyBoardLayout::KBL_RUSSIAN
};
const char* _kKeyBoardLayoutNames[] = {
  "KBL_STANDARD",
  "KBL_RUSSIAN"
};
const std::map<int, const char*> _KeyBoardLayout_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kKeyBoardLayoutValues, _kKeyBoardLayoutNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kDateFormatValues[] = {
  DateFormat::DF_DDMMYYYY_DOT,
  DateFormat::DF_DDMMYYYY_FSLASH,
  DateFormat::DF_DDMMYYYY_DASH,
  DateFormat::DF_YYYYMMDD_DOT,
  DateFormat::DF_YYYYMMDD_FSLASH,
  DateFormat::DF_YYYYMMDD_DASH,
  DateFormat::DF_MMDDYYYY_DASH,
  DateFormat::DF_MMDDYYYY_FSLASH
};
const char* _kDateFormatNames[] = {
  "DF_DDMMYYYY_DOT",
  "DF_DDMMYYYY_FSLASH",
  "DF_DDMMYYYY_DASH",
  "DF_YYYYMMDD_DOT",
  "DF_YYYYMMDD_FSLASH",
  "DF_YYYYMMDD_DASH",
  "DF_MMDDYYYY_DASH",
  "DF_MMDDYYYY_FSLASH"
};
const std::map<int, const char*> _DateFormat_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(8, _kDateFormatValues, _kDateFormatNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTimeFormatValues[] = {
  TimeFormat::TF_24H,
  TimeFormat::TF_12H
};
const char* _kTimeFormatNames[] = {
  "TF_24H",
  "TF_12H"
};
const std::map<int, const char*> _TimeFormat_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kTimeFormatValues, _kTimeFormatNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kStyleValues[] = {
  Style::STYLE_DEFAULT,
  Style::STYLE_INVISIBLE,
  Style::STYLE_RED,
  Style::STYLE_GREEN,
  Style::STYLE_YELLOW,
  Style::STYLE_RED_BOLD,
  Style::STYLE_GREEN_BOLD,
  Style::STYLE_YELLOW_BOLD,
  Style::STYLE_BLUE,
  Style::STYLE_BLUE_BOLD
};
const char* _kStyleNames[] = {
  "STYLE_DEFAULT",
  "STYLE_INVISIBLE",
  "STYLE_RED",
  "STYLE_GREEN",
  "STYLE_YELLOW",
  "STYLE_RED_BOLD",
  "STYLE_GREEN_BOLD",
  "STYLE_YELLOW_BOLD",
  "STYLE_BLUE",
  "STYLE_BLUE_BOLD"
};
const std::map<int, const char*> _Style_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(10, _kStyleValues, _kStyleNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kIndicatorValues[] = {
  Indicator::ALARM_ACKNOWLEDGE_NEEDED,
  Indicator::ALARM_RESET_NEEDED,
  Indicator::ALARM_NOTHING_NEEDED,
  Indicator::NO_ALARM_ACKNOWLEDGE_NEEDED,
  Indicator::NO_ALARM_RESET_NEEDED,
  Indicator::OVERRIDDEN,
  Indicator::OUT_OF_SERVICE,
  Indicator::LIFE_SAFETY,
  Indicator::CRITICAL_OPERATION,
  Indicator::ON_OFF_DELAY,
  Indicator::MANUAL_SWITCH,
  Indicator::SYSTEM_OPERATOR,
  Indicator::TRANSIENT
};
const char* _kIndicatorNames[] = {
  "ALARM_ACKNOWLEDGE_NEEDED",
  "ALARM_RESET_NEEDED",
  "ALARM_NOTHING_NEEDED",
  "NO_ALARM_ACKNOWLEDGE_NEEDED",
  "NO_ALARM_RESET_NEEDED",
  "OVERRIDDEN",
  "OUT_OF_SERVICE",
  "LIFE_SAFETY",
  "CRITICAL_OPERATION",
  "ON_OFF_DELAY",
  "MANUAL_SWITCH",
  "SYSTEM_OPERATOR",
  "TRANSIENT"
};
const std::map<int, const char*> _Indicator_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(13, _kIndicatorValues, _kIndicatorNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kAlarmFunctionValues[] = {
  AlarmFunction::NONE,
  AlarmFunction::ACKNOWLEDGE,
  AlarmFunction::RESET,
  AlarmFunction::ACKNOWLEDGE_RESET
};
const char* _kAlarmFunctionNames[] = {
  "NONE",
  "ACKNOWLEDGE",
  "RESET",
  "ACKNOWLEDGE_RESET"
};
const std::map<int, const char*> _AlarmFunction_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kAlarmFunctionValues, _kAlarmFunctionNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kAnchorValues[] = {
  Anchor::ANCHOR_TOP_LEFT,
  Anchor::ANCHOR_BOTTOM_LEFT,
  Anchor::ANCHOR_TOP_RIGHT,
  Anchor::ANCHOR_BOTTOM_RIGHT,
  Anchor::ANCHOR_TOP_CENTER,
  Anchor::ANCHOR_BOTTOM_CENTER,
  Anchor::ANCHOR_CENTER
};
const char* _kAnchorNames[] = {
  "ANCHOR_TOP_LEFT",
  "ANCHOR_BOTTOM_LEFT",
  "ANCHOR_TOP_RIGHT",
  "ANCHOR_BOTTOM_RIGHT",
  "ANCHOR_TOP_CENTER",
  "ANCHOR_BOTTOM_CENTER",
  "ANCHOR_CENTER"
};
const std::map<int, const char*> _Anchor_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(7, _kAnchorValues, _kAnchorNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kRelativePositionValues[] = {
  RelativePosition::INVISIBLE,
  RelativePosition::POSITION_LEFT,
  RelativePosition::POSITION_ABOVE,
  RelativePosition::POSITION_BELOW
};
const char* _kRelativePositionNames[] = {
  "INVISIBLE",
  "POSITION_LEFT",
  "POSITION_ABOVE",
  "POSITION_BELOW"
};
const std::map<int, const char*> _RelativePosition_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kRelativePositionValues, _kRelativePositionNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kManipulatorTypeValues[] = {
  ManipulatorType::SETVALUE,
  ManipulatorType::SETSIZE,
  ManipulatorType::NAVIGATE_TO,
  ManipulatorType::NAVIGATE_TO_COLLECTION_MEMBER,
  ManipulatorType::NAVIGATE_BACK
};
const char* _kManipulatorTypeNames[] = {
  "SETVALUE",
  "SETSIZE",
  "NAVIGATE_TO",
  "NAVIGATE_TO_COLLECTION_MEMBER",
  "NAVIGATE_BACK"
};
const std::map<int, const char*> _ManipulatorType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kManipulatorTypeValues, _kManipulatorTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kModeValues[] = {
  Mode::MANUAL,
  Mode::AUTOMATIC
};
const char* _kModeNames[] = {
  "MANUAL",
  "AUTOMATIC"
};
const std::map<int, const char*> _Mode_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kModeValues, _kModeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kGraphicPageElementTypeValues[] = {
  GraphicPageElementType::PANE,
  GraphicPageElementType::LINK,
  GraphicPageElementType::PROCESSVALUE,
  GraphicPageElementType::SETTINGS
};
const char* _kGraphicPageElementTypeNames[] = {
  "PANE",
  "LINK",
  "PROCESSVALUE",
  "SETTINGS"
};
const std::map<int, const char*> _GraphicPageElementType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kGraphicPageElementTypeValues, _kGraphicPageElementTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kBehaviorTypeValues[] = {
  BehaviorType::NORMAL,
  BehaviorType::TRIGGER_FEEDBACK,
  BehaviorType::TRIGGER_TOGGLE,
  BehaviorType::SCENE,
  BehaviorType::LGT_RELATIVE,
  BehaviorType::LGT_ABSOLUTE,
  BehaviorType::BLIND
};
const char* _kBehaviorTypeNames[] = {
  "NORMAL",
  "TRIGGER_FEEDBACK",
  "TRIGGER_TOGGLE",
  "SCENE",
  "LGT_RELATIVE",
  "LGT_ABSOLUTE",
  "BLIND"
};
const std::map<int, const char*> _BehaviorType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(7, _kBehaviorTypeValues, _kBehaviorTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kCommandValueTypeValues[] = {
  CommandValueType::CMD_VALUE,
  CommandValueType::CMD_MEMORIZE,
  CommandValueType::CMD_LIGHT_CONTROL,
  CommandValueType::CMD_BLIND_CONTROL
};
const char* _kCommandValueTypeNames[] = {
  "CMD_VALUE",
  "CMD_MEMORIZE",
  "CMD_LIGHT_CONTROL",
  "CMD_BLIND_CONTROL"
};
const std::map<int, const char*> _CommandValueType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kCommandValueTypeValues, _kCommandValueTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kLightOperationValues[] = {
  LightOperation::LIGHT_OP_STOP,
  LightOperation::LIGHT_OP_START_DIM_UP,
  LightOperation::LIGHT_OP_START_DIM_DOWN,
  LightOperation::LIGHT_OP_STEP_UP,
  LightOperation::LIGHT_OP_STEP_DOWN,
  LightOperation::LIGHT_OP_SWITCH_ON,
  LightOperation::LIGHT_OP_SWITCH_OFF,
  LightOperation::LIGHT_OP_GOTO_LEVEL
};
const char* _kLightOperationNames[] = {
  "LIGHT_OP_STOP",
  "LIGHT_OP_START_DIM_UP",
  "LIGHT_OP_START_DIM_DOWN",
  "LIGHT_OP_STEP_UP",
  "LIGHT_OP_STEP_DOWN",
  "LIGHT_OP_SWITCH_ON",
  "LIGHT_OP_SWITCH_OFF",
  "LIGHT_OP_GOTO_LEVEL"
};
const std::map<int, const char*> _LightOperation_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(8, _kLightOperationValues, _kLightOperationNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kBlindOperationValues[] = {
  BlindOperation::BLIND_OP_STOP,
  BlindOperation::BLIND_OP_MOVE_UP,
  BlindOperation::BLIND_OP_MOVE_DOWN,
  BlindOperation::BLIND_OP_STOP_OR_STEP_UP,
  BlindOperation::BLIND_OP_STOP_OR_STEP_DOWN,
  BlindOperation::BLIND_OP_GOTO_HEIGHT,
  BlindOperation::BLIND_OP_GOTO_ANGLE,
  BlindOperation::BLIND_OP_GOTO_POSITION,
  BlindOperation::BLIND_OP_GOTO_PREDEFINED_POSITION,
  BlindOperation::BLIND_OP_NO_OPERATION
};
const char* _kBlindOperationNames[] = {
  "BLIND_OP_STOP",
  "BLIND_OP_MOVE_UP",
  "BLIND_OP_MOVE_DOWN",
  "BLIND_OP_STOP_OR_STEP_UP",
  "BLIND_OP_STOP_OR_STEP_DOWN",
  "BLIND_OP_GOTO_HEIGHT",
  "BLIND_OP_GOTO_ANGLE",
  "BLIND_OP_GOTO_POSITION",
  "BLIND_OP_GOTO_PREDEFINED_POSITION",
  "BLIND_OP_NO_OPERATION"
};
const std::map<int, const char*> _BlindOperation_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(10, _kBlindOperationValues, _kBlindOperationNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kPaneKindValues[] = {
  PaneKind::PANE_APPLICATION,
  PaneKind::PANE_PAGES,
  PaneKind::PANE_STATUS,
  PaneKind::PANE_CONTENT,
  PaneKind::PANE_NAVIGATION
};
const char* _kPaneKindNames[] = {
  "PANE_APPLICATION",
  "PANE_PAGES",
  "PANE_STATUS",
  "PANE_CONTENT",
  "PANE_NAVIGATION"
};
const std::map<int, const char*> _PaneKind_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kPaneKindValues, _kPaneKindNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kElementTypeValues[] = {
  ElementType::ELEM_TYPE_MODIFY_TP,
  ElementType::ELEM_TYPE_MODIFY_RUT1,
  ElementType::ELEM_TYPE_MODIFY_RUT2,
  ElementType::ELEM_TYPE_TRIGGER,
  ElementType::ELEM_TYPE_READ_ONLY
};
const char* _kElementTypeNames[] = {
  "ELEM_TYPE_MODIFY_TP",
  "ELEM_TYPE_MODIFY_RUT1",
  "ELEM_TYPE_MODIFY_RUT2",
  "ELEM_TYPE_TRIGGER",
  "ELEM_TYPE_READ_ONLY"
};
const std::map<int, const char*> _ElementType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kElementTypeValues, _kElementTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kElementSizeValues[] = {
  ElementSize::ELEM_SIZE_NORMAL,
  ElementSize::ELEM_SIZE_STATUSBAR
};
const char* _kElementSizeNames[] = {
  "ELEM_SIZE_NORMAL",
  "ELEM_SIZE_STATUSBAR"
};
const std::map<int, const char*> _ElementSize_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kElementSizeValues, _kElementSizeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

const char* AccessInfo::ascii_fingerprint = "69EF77542FBF7A8DD68310C9FF3B44BD";
const uint8_t AccessInfo::binary_fingerprint[16] = {0x69,0xEF,0x77,0x54,0x2F,0xBF,0x7A,0x8D,0xD6,0x83,0x10,0xC9,0xFF,0x3B,0x44,0xBD};

uint32_t AccessInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast0;
          xfer += iprot->readI32(ecast0);
          this->readAccess = (BAPA_READACCESS_TYPE::type)ecast0;
          this->__isset.readAccess = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast1;
          xfer += iprot->readI32(ecast1);
          this->writeAccess = (BAPA_WRITEACCESS_TYPE::type)ecast1;
          this->__isset.writeAccess = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccessInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccessInfo");

  xfer += oprot->writeFieldBegin("readAccess", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->readAccess);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("writeAccess", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->writeAccess);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AccessInfo &a, AccessInfo &b) {
  using ::std::swap;
  swap(a.readAccess, b.readAccess);
  swap(a.writeAccess, b.writeAccess);
  swap(a.__isset, b.__isset);
}

const char* TypeInfo::ascii_fingerprint = "AF0818C7C201361BB560A69DC4A4C4FF";
const uint8_t TypeInfo::binary_fingerprint[16] = {0xAF,0x08,0x18,0xC7,0xC2,0x01,0x36,0x1B,0xB5,0x60,0xA6,0x9D,0xC4,0xA4,0xC4,0xFF};

uint32_t TypeInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->defValue);
          this->__isset.defValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minValue);
          this->__isset.minValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxValue);
          this->__isset.maxValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->resolution);
          this->__isset.resolution = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->minLength);
          this->__isset.minLength = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxLength);
          this->__isset.maxLength = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->arrayIndex);
          this->__isset.arrayIndex = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->stringIndex);
          this->__isset.stringIndex = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->unit);
          this->__isset.unit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->textGroup);
          this->__isset.textGroup = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TypeInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TypeInfo");

  xfer += oprot->writeFieldBegin("defValue", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->defValue);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minValue", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minValue);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxValue", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->maxValue);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("resolution", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->resolution);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minLength", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->minLength);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxLength", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->maxLength);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("arrayIndex", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->arrayIndex);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stringIndex", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32(this->stringIndex);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("unit", ::apache::thrift::protocol::T_STRING, 9);
  xfer += oprot->writeString(this->unit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("textGroup", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->textGroup);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TypeInfo &a, TypeInfo &b) {
  using ::std::swap;
  swap(a.defValue, b.defValue);
  swap(a.minValue, b.minValue);
  swap(a.maxValue, b.maxValue);
  swap(a.resolution, b.resolution);
  swap(a.minLength, b.minLength);
  swap(a.maxLength, b.maxLength);
  swap(a.arrayIndex, b.arrayIndex);
  swap(a.stringIndex, b.stringIndex);
  swap(a.unit, b.unit);
  swap(a.textGroup, b.textGroup);
  swap(a.__isset, b.__isset);
}

const char* Property_Info::ascii_fingerprint = "15E523F8C5AB8B390E1F2FB28A16D286";
const uint8_t Property_Info::binary_fingerprint[16] = {0x15,0xE5,0x23,0xF8,0xC5,0xAB,0x8B,0x39,0x0E,0x1F,0x2F,0xB2,0x8A,0x16,0xD2,0x86};

uint32_t Property_Info::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast2;
          xfer += iprot->readI32(ecast2);
          this->data_type = (BA_DATA_TYPE::type)ecast2;
          this->__isset.data_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->accessInfo.read(iprot);
          this->__isset.accessInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->typeInfo.read(iprot);
          this->__isset.typeInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Property_Info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Property_Info");

  xfer += oprot->writeFieldBegin("data_type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->data_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("accessInfo", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->accessInfo.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("typeInfo", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->typeInfo.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Property_Info &a, Property_Info &b) {
  using ::std::swap;
  swap(a.data_type, b.data_type);
  swap(a.accessInfo, b.accessInfo);
  swap(a.typeInfo, b.typeInfo);
  swap(a.__isset, b.__isset);
}

const char* PropertyDesc_Info::ascii_fingerprint = "56D24419FDA5C3858E5DB4F31B1006B6";
const uint8_t PropertyDesc_Info::binary_fingerprint[16] = {0x56,0xD2,0x44,0x19,0xFD,0xA5,0xC3,0x85,0x8E,0x5D,0xB4,0xF3,0x1B,0x10,0x06,0xB6};

uint32_t PropertyDesc_Info::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast3;
          xfer += iprot->readI32(ecast3);
          this->propertyType = (Property_Type::type)ecast3;
          this->__isset.propertyType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->propertyInfo.read(iprot);
          this->__isset.propertyInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PropertyDesc_Info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("PropertyDesc_Info");

  xfer += oprot->writeFieldBegin("propertyType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->propertyType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("propertyInfo", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->propertyInfo.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PropertyDesc_Info &a, PropertyDesc_Info &b) {
  using ::std::swap;
  swap(a.propertyType, b.propertyType);
  swap(a.propertyInfo, b.propertyInfo);
  swap(a.__isset, b.__isset);
}

const char* Object_Id::ascii_fingerprint = "DE035C7565A0274CBA4FB0CDABB89798";
const uint8_t Object_Id::binary_fingerprint[16] = {0xDE,0x03,0x5C,0x75,0x65,0xA0,0x27,0x4C,0xBA,0x4F,0xB0,0xCD,0xAB,0xB8,0x97,0x98};

uint32_t Object_Id::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->device_instance);
          this->__isset.device_instance = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast4;
          xfer += iprot->readI32(ecast4);
          this->object_type = (Object_Type::type)ecast4;
          this->__isset.object_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->object_instance);
          this->__isset.object_instance = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Object_Id::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Object_Id");

  xfer += oprot->writeFieldBegin("device_instance", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->device_instance);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("object_type", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->object_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("object_instance", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->object_instance);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Object_Id &a, Object_Id &b) {
  using ::std::swap;
  swap(a.device_instance, b.device_instance);
  swap(a.object_type, b.object_type);
  swap(a.object_instance, b.object_instance);
  swap(a.__isset, b.__isset);
}

const char* User::ascii_fingerprint = "3D5565560ECA89BA0D971A984FCB6ADB";
const uint8_t User::binary_fingerprint[16] = {0x3D,0x55,0x65,0x56,0x0E,0xCA,0x89,0xBA,0x0D,0x97,0x1A,0x98,0x4F,0xCB,0x6A,0xDB};

uint32_t User::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->username);
          this->__isset.username = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->password);
          this->__isset.password = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->autologin);
          this->__isset.autologin = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->firstname);
          this->__isset.firstname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->lastname);
          this->__isset.lastname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->language);
          this->__isset.language = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->country);
          this->__isset.country = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->web_theme);
          this->__isset.web_theme = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->email);
          this->__isset.email = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->comment);
          this->__isset.comment = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t User::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("User");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("username", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->username);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("password", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->password);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("autologin", ::apache::thrift::protocol::T_I16, 5);
  xfer += oprot->writeI16(this->autologin);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("firstname", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->firstname);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lastname", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString(this->lastname);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("language", ::apache::thrift::protocol::T_STRING, 8);
  xfer += oprot->writeString(this->language);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("country", ::apache::thrift::protocol::T_STRING, 9);
  xfer += oprot->writeString(this->country);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("web_theme", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->web_theme);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("email", ::apache::thrift::protocol::T_STRING, 11);
  xfer += oprot->writeString(this->email);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("comment", ::apache::thrift::protocol::T_STRING, 12);
  xfer += oprot->writeString(this->comment);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(User &a, User &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.username, b.username);
  swap(a.password, b.password);
  swap(a.autologin, b.autologin);
  swap(a.firstname, b.firstname);
  swap(a.lastname, b.lastname);
  swap(a.language, b.language);
  swap(a.country, b.country);
  swap(a.web_theme, b.web_theme);
  swap(a.email, b.email);
  swap(a.comment, b.comment);
  swap(a.__isset, b.__isset);
}

const char* FileTransferLocation::ascii_fingerprint = "BFF0E21728CB005F9AA5774A41542B8D";
const uint8_t FileTransferLocation::binary_fingerprint[16] = {0xBF,0xF0,0xE2,0x17,0x28,0xCB,0x00,0x5F,0x9A,0xA5,0x77,0x4A,0x41,0x54,0x2B,0x8D};

uint32_t FileTransferLocation::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->path);
          this->__isset.path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->localpath);
          this->__isset.localpath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->description);
          this->__isset.description = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->comment);
          this->__isset.comment = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FileTransferLocation::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("FileTransferLocation");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("path", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->path);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("localpath", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->localpath);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("description", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->description);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("comment", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->comment);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FileTransferLocation &a, FileTransferLocation &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.path, b.path);
  swap(a.localpath, b.localpath);
  swap(a.description, b.description);
  swap(a.comment, b.comment);
  swap(a.__isset, b.__isset);
}

const char* Password::ascii_fingerprint = "D6FD826D949221396F4FFC3ECCD3D192";
const uint8_t Password::binary_fingerprint[16] = {0xD6,0xFD,0x82,0x6D,0x94,0x92,0x21,0x39,0x6F,0x4F,0xFC,0x3E,0xCC,0xD3,0xD1,0x92};

uint32_t Password::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->password);
          this->__isset.password = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast5;
          xfer += iprot->readI32(ecast5);
          this->type = (PasswordType::type)ecast5;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Password::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Password");

  xfer += oprot->writeFieldBegin("password", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->password);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Password &a, Password &b) {
  using ::std::swap;
  swap(a.password, b.password);
  swap(a.type, b.type);
  swap(a.__isset, b.__isset);
}

const char* Location::ascii_fingerprint = "841D887883305BADAC7BA25B7B7428AE";
const uint8_t Location::binary_fingerprint[16] = {0x84,0x1D,0x88,0x78,0x83,0x30,0x5B,0xAD,0xAC,0x7B,0xA2,0x5B,0x7B,0x74,0x28,0xAE};

uint32_t Location::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->description);
          this->__isset.description = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->password);
          this->__isset.password = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->home.read(iprot);
          this->__isset.home = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->systemNavigationEntries.clear();
            uint32_t _size6;
            ::apache::thrift::protocol::TType _etype9;
            xfer += iprot->readListBegin(_etype9, _size6);
            this->systemNavigationEntries.resize(_size6);
            uint32_t _i10;
            for (_i10 = 0; _i10 < _size6; ++_i10)
            {
              xfer += this->systemNavigationEntries[_i10].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.systemNavigationEntries = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Location::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Location");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("description", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->description);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("password", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->password);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("home", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->home.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("systemNavigationEntries", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->systemNavigationEntries.size()));
    std::vector<Object_Id> ::const_iterator _iter11;
    for (_iter11 = this->systemNavigationEntries.begin(); _iter11 != this->systemNavigationEntries.end(); ++_iter11)
    {
      xfer += (*_iter11).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Location &a, Location &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.description, b.description);
  swap(a.password, b.password);
  swap(a.home, b.home);
  swap(a.systemNavigationEntries, b.systemNavigationEntries);
  swap(a.__isset, b.__isset);
}

const char* AuthenticationResult::ascii_fingerprint = "5A1DBEF86C04C9F02A196C53D3CE8444";
const uint8_t AuthenticationResult::binary_fingerprint[16] = {0x5A,0x1D,0xBE,0xF8,0x6C,0x04,0xC9,0xF0,0x2A,0x19,0x6C,0x53,0xD3,0xCE,0x84,0x44};

uint32_t AuthenticationResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_authenticationToken = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->authenticationToken);
          isset_authenticationToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->user.read(iprot);
          this->__isset.user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->location.read(iprot);
          this->__isset.location = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_authenticationToken)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AuthenticationResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AuthenticationResult");

  xfer += oprot->writeFieldBegin("authenticationToken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->authenticationToken);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.user) {
    xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->user.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.location) {
    xfer += oprot->writeFieldBegin("location", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->location.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AuthenticationResult &a, AuthenticationResult &b) {
  using ::std::swap;
  swap(a.authenticationToken, b.authenticationToken);
  swap(a.user, b.user);
  swap(a.location, b.location);
  swap(a.__isset, b.__isset);
}

const char* Model::ascii_fingerprint = "EFB929595D312AC8F305D5A794CFEDA1";
const uint8_t Model::binary_fingerprint[16] = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

uint32_t Model::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->locationDescription);
          this->__isset.locationDescription = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Model::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Model");

  xfer += oprot->writeFieldBegin("locationDescription", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->locationDescription);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Model &a, Model &b) {
  using ::std::swap;
  swap(a.locationDescription, b.locationDescription);
  swap(a.__isset, b.__isset);
}

const char* AuthenticationLocationParameters::ascii_fingerprint = "07A9615F837F7D0A952B595DD3020972";
const uint8_t AuthenticationLocationParameters::binary_fingerprint[16] = {0x07,0xA9,0x61,0x5F,0x83,0x7F,0x7D,0x0A,0x95,0x2B,0x59,0x5D,0xD3,0x02,0x09,0x72};

uint32_t AuthenticationLocationParameters::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->locationName);
          this->__isset.locationName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->password);
          this->__isset.password = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AuthenticationLocationParameters::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AuthenticationLocationParameters");

  xfer += oprot->writeFieldBegin("locationName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->locationName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("password", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->password);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AuthenticationLocationParameters &a, AuthenticationLocationParameters &b) {
  using ::std::swap;
  swap(a.locationName, b.locationName);
  swap(a.password, b.password);
  swap(a.__isset, b.__isset);
}

const char* UserLoginParameters::ascii_fingerprint = "07A9615F837F7D0A952B595DD3020972";
const uint8_t UserLoginParameters::binary_fingerprint[16] = {0x07,0xA9,0x61,0x5F,0x83,0x7F,0x7D,0x0A,0x95,0x2B,0x59,0x5D,0xD3,0x02,0x09,0x72};

uint32_t UserLoginParameters::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->UserName);
          this->__isset.UserName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->password);
          this->__isset.password = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UserLoginParameters::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("UserLoginParameters");

  xfer += oprot->writeFieldBegin("UserName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->UserName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("password", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->password);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UserLoginParameters &a, UserLoginParameters &b) {
  using ::std::swap;
  swap(a.UserName, b.UserName);
  swap(a.password, b.password);
  swap(a.__isset, b.__isset);
}

const char* GetModelUpdateParameters::ascii_fingerprint = "5892306F7B861249AE8E27C8ED619593";
const uint8_t GetModelUpdateParameters::binary_fingerprint[16] = {0x58,0x92,0x30,0x6F,0x7B,0x86,0x12,0x49,0xAE,0x8E,0x27,0xC8,0xED,0x61,0x95,0x93};

uint32_t GetModelUpdateParameters::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->keepAlive);
          this->__isset.keepAlive = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GetModelUpdateParameters::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("GetModelUpdateParameters");

  xfer += oprot->writeFieldBegin("keepAlive", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->keepAlive);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetModelUpdateParameters &a, GetModelUpdateParameters &b) {
  using ::std::swap;
  swap(a.keepAlive, b.keepAlive);
  swap(a.__isset, b.__isset);
}

const char* SelectFunctionParameters::ascii_fingerprint = "8BBB3D0C3B370CB38F2D1340BB79F0AA";
const uint8_t SelectFunctionParameters::binary_fingerprint[16] = {0x8B,0xBB,0x3D,0x0C,0x3B,0x37,0x0C,0xB3,0x8F,0x2D,0x13,0x40,0xBB,0x79,0xF0,0xAA};

uint32_t SelectFunctionParameters::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast12;
          xfer += iprot->readI32(ecast12);
          this->currentFunction = (CoreFunction::type)ecast12;
          this->__isset.currentFunction = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SelectFunctionParameters::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SelectFunctionParameters");

  xfer += oprot->writeFieldBegin("currentFunction", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->currentFunction);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SelectFunctionParameters &a, SelectFunctionParameters &b) {
  using ::std::swap;
  swap(a.currentFunction, b.currentFunction);
  swap(a.__isset, b.__isset);
}

const char* SelectViewParamaters::ascii_fingerprint = "EFB929595D312AC8F305D5A794CFEDA1";
const uint8_t SelectViewParamaters::binary_fingerprint[16] = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

uint32_t SelectViewParamaters::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->viewId);
          this->__isset.viewId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SelectViewParamaters::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SelectViewParamaters");

  xfer += oprot->writeFieldBegin("viewId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->viewId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SelectViewParamaters &a, SelectViewParamaters &b) {
  using ::std::swap;
  swap(a.viewId, b.viewId);
  swap(a.__isset, b.__isset);
}

const char* Commandvalue::ascii_fingerprint = "1CD307461D05254E6B6D22C598F85F09";
const uint8_t Commandvalue::binary_fingerprint[16] = {0x1C,0xD3,0x07,0x46,0x1D,0x05,0x25,0x4E,0x6B,0x6D,0x22,0xC5,0x98,0xF8,0x5F,0x09};

uint32_t Commandvalue::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->Discretevalue);
          this->__isset.Discretevalue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->Analogvalue);
          this->__isset.Analogvalue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Commandvalue::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Commandvalue");

  if (this->__isset.Discretevalue) {
    xfer += oprot->writeFieldBegin("Discretevalue", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->Discretevalue);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.Analogvalue) {
    xfer += oprot->writeFieldBegin("Analogvalue", ::apache::thrift::protocol::T_DOUBLE, 2);
    xfer += oprot->writeDouble(this->Analogvalue);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Commandvalue &a, Commandvalue &b) {
  using ::std::swap;
  swap(a.Discretevalue, b.Discretevalue);
  swap(a.Analogvalue, b.Analogvalue);
  swap(a.__isset, b.__isset);
}

const char* LightControlParameters::ascii_fingerprint = "00B53363534FC7B58834DAAFE9A17C1D";
const uint8_t LightControlParameters::binary_fingerprint[16] = {0x00,0xB5,0x33,0x63,0x53,0x4F,0xC7,0xB5,0x88,0x34,0xDA,0xAF,0xE9,0xA1,0x7C,0x1D};

uint32_t LightControlParameters::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast13;
          xfer += iprot->readI32(ecast13);
          this->operation = (LightOperation::type)ecast13;
          this->__isset.operation = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t LightControlParameters::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("LightControlParameters");

  xfer += oprot->writeFieldBegin("operation", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->operation);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.value) {
    xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_DOUBLE, 2);
    xfer += oprot->writeDouble(this->value);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LightControlParameters &a, LightControlParameters &b) {
  using ::std::swap;
  swap(a.operation, b.operation);
  swap(a.value, b.value);
  swap(a.__isset, b.__isset);
}

const char* BlindControlParameters::ascii_fingerprint = "505E64E7CF65D7D247CABC9C35A55E4D";
const uint8_t BlindControlParameters::binary_fingerprint[16] = {0x50,0x5E,0x64,0xE7,0xCF,0x65,0xD7,0xD2,0x47,0xCA,0xBC,0x9C,0x35,0xA5,0x5E,0x4D};

uint32_t BlindControlParameters::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast14;
          xfer += iprot->readI32(ecast14);
          this->operation = (BlindOperation::type)ecast14;
          this->__isset.operation = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->height);
          this->__isset.height = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->angle);
          this->__isset.angle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->predefinedPos);
          this->__isset.predefinedPos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BlindControlParameters::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("BlindControlParameters");

  xfer += oprot->writeFieldBegin("operation", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->operation);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.height) {
    xfer += oprot->writeFieldBegin("height", ::apache::thrift::protocol::T_DOUBLE, 2);
    xfer += oprot->writeDouble(this->height);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.angle) {
    xfer += oprot->writeFieldBegin("angle", ::apache::thrift::protocol::T_DOUBLE, 3);
    xfer += oprot->writeDouble(this->angle);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.predefinedPos) {
    xfer += oprot->writeFieldBegin("predefinedPos", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->predefinedPos);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BlindControlParameters &a, BlindControlParameters &b) {
  using ::std::swap;
  swap(a.operation, b.operation);
  swap(a.height, b.height);
  swap(a.angle, b.angle);
  swap(a.predefinedPos, b.predefinedPos);
  swap(a.__isset, b.__isset);
}

const char* CommandValueParameters::ascii_fingerprint = "9B1D159CC19E847651795C1AD8293C7C";
const uint8_t CommandValueParameters::binary_fingerprint[16] = {0x9B,0x1D,0x15,0x9C,0xC1,0x9E,0x84,0x76,0x51,0x79,0x5C,0x1A,0xD8,0x29,0x3C,0x7C};

uint32_t CommandValueParameters::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->elementId);
          this->__isset.elementId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->commandvalue.read(iprot);
          this->__isset.commandvalue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast15;
          xfer += iprot->readI32(ecast15);
          this->commandValueType = (CommandValueType::type)ecast15;
          this->__isset.commandValueType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->placeableElementId);
          this->__isset.placeableElementId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->lightControlParameters.read(iprot);
          this->__isset.lightControlParameters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->blindControlParameters.read(iprot);
          this->__isset.blindControlParameters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CommandValueParameters::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CommandValueParameters");

  if (this->__isset.elementId) {
    xfer += oprot->writeFieldBegin("elementId", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->elementId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.commandvalue) {
    xfer += oprot->writeFieldBegin("commandvalue", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->commandvalue.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.commandValueType) {
    xfer += oprot->writeFieldBegin("commandValueType", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32((int32_t)this->commandValueType);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.placeableElementId) {
    xfer += oprot->writeFieldBegin("placeableElementId", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->placeableElementId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.lightControlParameters) {
    xfer += oprot->writeFieldBegin("lightControlParameters", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->lightControlParameters.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.blindControlParameters) {
    xfer += oprot->writeFieldBegin("blindControlParameters", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->blindControlParameters.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CommandValueParameters &a, CommandValueParameters &b) {
  using ::std::swap;
  swap(a.elementId, b.elementId);
  swap(a.commandvalue, b.commandvalue);
  swap(a.commandValueType, b.commandValueType);
  swap(a.placeableElementId, b.placeableElementId);
  swap(a.lightControlParameters, b.lightControlParameters);
  swap(a.blindControlParameters, b.blindControlParameters);
  swap(a.__isset, b.__isset);
}

const char* ServerSettingParameters::ascii_fingerprint = "780899D8BF621CD4E9439B0D56879B06";
const uint8_t ServerSettingParameters::binary_fingerprint[16] = {0x78,0x08,0x99,0xD8,0xBF,0x62,0x1C,0xD4,0xE9,0x43,0x9B,0x0D,0x56,0x87,0x9B,0x06};

uint32_t ServerSettingParameters::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->languageSymbol);
          this->__isset.languageSymbol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast16;
          xfer += iprot->readI32(ecast16);
          this->timeFormat = (TimeFormat::type)ecast16;
          this->__isset.timeFormat = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast17;
          xfer += iprot->readI32(ecast17);
          this->dateFormat = (DateFormat::type)ecast17;
          this->__isset.dateFormat = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast18;
          xfer += iprot->readI32(ecast18);
          this->keyboardLayout = (KeyBoardLayout::type)ecast18;
          this->__isset.keyboardLayout = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast19;
          xfer += iprot->readI32(ecast19);
          this->autoLogoutTime = (AutoLogoutTime::type)ecast19;
          this->__isset.autoLogoutTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast20;
          xfer += iprot->readI32(ecast20);
          this->navigBarTiOut = (NavigBarTiOut::type)ecast20;
          this->__isset.navigBarTiOut = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast21;
          xfer += iprot->readI32(ecast21);
          this->screenSaverTiOut = (ScreenSaverTiOut::type)ecast21;
          this->__isset.screenSaverTiOut = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ServerSettingParameters::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ServerSettingParameters");

  if (this->__isset.languageSymbol) {
    xfer += oprot->writeFieldBegin("languageSymbol", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->languageSymbol);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.timeFormat) {
    xfer += oprot->writeFieldBegin("timeFormat", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32((int32_t)this->timeFormat);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.dateFormat) {
    xfer += oprot->writeFieldBegin("dateFormat", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32((int32_t)this->dateFormat);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.keyboardLayout) {
    xfer += oprot->writeFieldBegin("keyboardLayout", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32((int32_t)this->keyboardLayout);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.autoLogoutTime) {
    xfer += oprot->writeFieldBegin("autoLogoutTime", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32((int32_t)this->autoLogoutTime);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.navigBarTiOut) {
    xfer += oprot->writeFieldBegin("navigBarTiOut", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32((int32_t)this->navigBarTiOut);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.screenSaverTiOut) {
    xfer += oprot->writeFieldBegin("screenSaverTiOut", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32((int32_t)this->screenSaverTiOut);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ServerSettingParameters &a, ServerSettingParameters &b) {
  using ::std::swap;
  swap(a.languageSymbol, b.languageSymbol);
  swap(a.timeFormat, b.timeFormat);
  swap(a.dateFormat, b.dateFormat);
  swap(a.keyboardLayout, b.keyboardLayout);
  swap(a.autoLogoutTime, b.autoLogoutTime);
  swap(a.navigBarTiOut, b.navigBarTiOut);
  swap(a.screenSaverTiOut, b.screenSaverTiOut);
  swap(a.__isset, b.__isset);
}

const char* TDate::ascii_fingerprint = "874362235FCCF77E284413CBBBA335FE";
const uint8_t TDate::binary_fingerprint[16] = {0x87,0x43,0x62,0x23,0x5F,0xCC,0xF7,0x7E,0x28,0x44,0x13,0xCB,0xBB,0xA3,0x35,0xFE};

uint32_t TDate::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->year);
          this->__isset.year = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->month);
          this->__isset.month = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->day);
          this->__isset.day = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TDate::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TDate");

  xfer += oprot->writeFieldBegin("year", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->year);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("month", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte(this->month);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("day", ::apache::thrift::protocol::T_BYTE, 3);
  xfer += oprot->writeByte(this->day);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDate &a, TDate &b) {
  using ::std::swap;
  swap(a.year, b.year);
  swap(a.month, b.month);
  swap(a.day, b.day);
  swap(a.__isset, b.__isset);
}

const char* ServiceCommand::ascii_fingerprint = "A4A3C67348E627A83D8D710546C88307";
const uint8_t ServiceCommand::binary_fingerprint[16] = {0xA4,0xA3,0xC6,0x73,0x48,0xE6,0x27,0xA8,0x3D,0x8D,0x71,0x05,0x46,0xC8,0x83,0x07};

uint32_t ServiceCommand::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast22;
          xfer += iprot->readI32(ecast22);
          this->commandType = (Command_Type::type)ecast22;
          this->__isset.commandType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->authenticateLocationParameters.read(iprot);
          this->__isset.authenticateLocationParameters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userLoginParameters.read(iprot);
          this->__isset.userLoginParameters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->getModelUpdateParameters.read(iprot);
          this->__isset.getModelUpdateParameters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->selectFunctionParameters.read(iprot);
          this->__isset.selectFunctionParameters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->selectViewParameters.read(iprot);
          this->__isset.selectViewParameters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->commandValueParameters.read(iprot);
          this->__isset.commandValueParameters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->schedulerParameters.read(iprot);
          this->__isset.schedulerParameters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->serverSettingParameters.read(iprot);
          this->__isset.serverSettingParameters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->trendParameters.read(iprot);
          this->__isset.trendParameters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ServiceCommand::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ServiceCommand");

  xfer += oprot->writeFieldBegin("commandType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->commandType);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.authenticateLocationParameters) {
    xfer += oprot->writeFieldBegin("authenticateLocationParameters", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->authenticateLocationParameters.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.userLoginParameters) {
    xfer += oprot->writeFieldBegin("userLoginParameters", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->userLoginParameters.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.getModelUpdateParameters) {
    xfer += oprot->writeFieldBegin("getModelUpdateParameters", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->getModelUpdateParameters.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.selectFunctionParameters) {
    xfer += oprot->writeFieldBegin("selectFunctionParameters", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->selectFunctionParameters.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.selectViewParameters) {
    xfer += oprot->writeFieldBegin("selectViewParameters", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->selectViewParameters.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.commandValueParameters) {
    xfer += oprot->writeFieldBegin("commandValueParameters", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->commandValueParameters.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.schedulerParameters) {
    xfer += oprot->writeFieldBegin("schedulerParameters", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->schedulerParameters.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.serverSettingParameters) {
    xfer += oprot->writeFieldBegin("serverSettingParameters", ::apache::thrift::protocol::T_STRUCT, 9);
    xfer += this->serverSettingParameters.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.trendParameters) {
    xfer += oprot->writeFieldBegin("trendParameters", ::apache::thrift::protocol::T_STRUCT, 10);
    xfer += this->trendParameters.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ServiceCommand &a, ServiceCommand &b) {
  using ::std::swap;
  swap(a.commandType, b.commandType);
  swap(a.authenticateLocationParameters, b.authenticateLocationParameters);
  swap(a.userLoginParameters, b.userLoginParameters);
  swap(a.getModelUpdateParameters, b.getModelUpdateParameters);
  swap(a.selectFunctionParameters, b.selectFunctionParameters);
  swap(a.selectViewParameters, b.selectViewParameters);
  swap(a.commandValueParameters, b.commandValueParameters);
  swap(a.schedulerParameters, b.schedulerParameters);
  swap(a.serverSettingParameters, b.serverSettingParameters);
  swap(a.trendParameters, b.trendParameters);
  swap(a.__isset, b.__isset);
}

const char* Value::ascii_fingerprint = "6BBB8001263E90C2A4941342220FEF78";
const uint8_t Value::binary_fingerprint[16] = {0x6B,0xBB,0x80,0x01,0x26,0x3E,0x90,0xC2,0xA4,0x94,0x13,0x42,0x22,0x0F,0xEF,0x78};

uint32_t Value::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->boolValue);
          this->__isset.boolValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->intValue);
          this->__isset.intValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->doubleValue);
          this->__isset.doubleValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->stringValue);
          this->__isset.stringValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Value::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Value");

  if (this->__isset.boolValue) {
    xfer += oprot->writeFieldBegin("boolValue", ::apache::thrift::protocol::T_BOOL, 1);
    xfer += oprot->writeBool(this->boolValue);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.intValue) {
    xfer += oprot->writeFieldBegin("intValue", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->intValue);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.doubleValue) {
    xfer += oprot->writeFieldBegin("doubleValue", ::apache::thrift::protocol::T_DOUBLE, 3);
    xfer += oprot->writeDouble(this->doubleValue);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.stringValue) {
    xfer += oprot->writeFieldBegin("stringValue", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->stringValue);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Value &a, Value &b) {
  using ::std::swap;
  swap(a.boolValue, b.boolValue);
  swap(a.intValue, b.intValue);
  swap(a.doubleValue, b.doubleValue);
  swap(a.stringValue, b.stringValue);
  swap(a.__isset, b.__isset);
}

const char* ManipulatorCommand::ascii_fingerprint = "D81B1CDEE01C42D6163926D4A502355D";
const uint8_t ManipulatorCommand::binary_fingerprint[16] = {0xD8,0x1B,0x1C,0xDE,0xE0,0x1C,0x42,0xD6,0x16,0x39,0x26,0xD4,0xA5,0x02,0x35,0x5D};

uint32_t ManipulatorCommand::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast23;
          xfer += iprot->readI32(ecast23);
          this->manipulatortype = (ManipulatorType::type)ecast23;
          this->__isset.manipulatortype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->attribute);
          this->__isset.attribute = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->value.read(iprot);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->size_index);
          this->__isset.size_index = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ManipulatorCommand::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ManipulatorCommand");

  xfer += oprot->writeFieldBegin("manipulatortype", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->manipulatortype);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.attribute) {
    xfer += oprot->writeFieldBegin("attribute", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->attribute);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.value) {
    xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->value.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.size_index) {
    xfer += oprot->writeFieldBegin("size_index", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->size_index);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ManipulatorCommand &a, ManipulatorCommand &b) {
  using ::std::swap;
  swap(a.manipulatortype, b.manipulatortype);
  swap(a.attribute, b.attribute);
  swap(a.value, b.value);
  swap(a.size_index, b.size_index);
  swap(a.__isset, b.__isset);
}

const char* ModelUpdate::ascii_fingerprint = "552FD285AC4A1FC6A540FF03A0348B00";
const uint8_t ModelUpdate::binary_fingerprint[16] = {0x55,0x2F,0xD2,0x85,0xAC,0x4A,0x1F,0xC6,0xA5,0x40,0xFF,0x03,0xA0,0x34,0x8B,0x00};

uint32_t ModelUpdate::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->viewstate);
          this->__isset.viewstate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->updateinstruction.clear();
            uint32_t _size24;
            ::apache::thrift::protocol::TType _etype27;
            xfer += iprot->readListBegin(_etype27, _size24);
            this->updateinstruction.resize(_size24);
            uint32_t _i28;
            for (_i28 = 0; _i28 < _size24; ++_i28)
            {
              xfer += this->updateinstruction[_i28].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.updateinstruction = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ModelUpdate::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ModelUpdate");

  xfer += oprot->writeFieldBegin("viewstate", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->viewstate);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("updateinstruction", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->updateinstruction.size()));
    std::vector<ManipulatorCommand> ::const_iterator _iter29;
    for (_iter29 = this->updateinstruction.begin(); _iter29 != this->updateinstruction.end(); ++_iter29)
    {
      xfer += (*_iter29).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ModelUpdate &a, ModelUpdate &b) {
  using ::std::swap;
  swap(a.viewstate, b.viewstate);
  swap(a.updateinstruction, b.updateinstruction);
  swap(a.__isset, b.__isset);
}

const char* LogRecord::ascii_fingerprint = "0B663F1913C9C6F43150B524A8B76386";
const uint8_t LogRecord::binary_fingerprint[16] = {0x0B,0x66,0x3F,0x19,0x13,0xC9,0xC6,0xF4,0x31,0x50,0xB5,0x24,0xA8,0xB7,0x63,0x86};

uint32_t LogRecord::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->timeStamp);
          this->__isset.timeStamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t LogRecord::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("LogRecord");

  xfer += oprot->writeFieldBegin("timeStamp", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->timeStamp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LogRecord &a, LogRecord &b) {
  using ::std::swap;
  swap(a.timeStamp, b.timeStamp);
  swap(a.value, b.value);
  swap(a.__isset, b.__isset);
}

const char* ServiceResult::ascii_fingerprint = "47CD577EC855CBB76DE0010DE5D8B9B3";
const uint8_t ServiceResult::binary_fingerprint[16] = {0x47,0xCD,0x57,0x7E,0xC8,0x55,0xCB,0xB7,0x6D,0xE0,0x01,0x0D,0xE5,0xD8,0xB9,0xB3};

uint32_t ServiceResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->newSessionId);
          this->__isset.newSessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast30;
          xfer += iprot->readI32(ecast30);
          this->resultCode = (Result_Code::type)ecast30;
          this->__isset.resultCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->modelUpdate.read(iprot);
          this->__isset.modelUpdate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->result.clear();
            uint32_t _size31;
            ::apache::thrift::protocol::TType _etype34;
            xfer += iprot->readListBegin(_etype34, _size31);
            this->result.resize(_size31);
            uint32_t _i35;
            for (_i35 = 0; _i35 < _size31; ++_i35)
            {
              xfer += this->result[_i35].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->logRecord.clear();
            uint32_t _size36;
            ::apache::thrift::protocol::TType _etype39;
            xfer += iprot->readListBegin(_etype39, _size36);
            this->logRecord.resize(_size36);
            uint32_t _i40;
            for (_i40 = 0; _i40 < _size36; ++_i40)
            {
              xfer += this->logRecord[_i40].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.logRecord = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->schedulerResult.read(iprot);
          this->__isset.schedulerResult = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ServiceResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ServiceResult");

  if (this->__isset.newSessionId) {
    xfer += oprot->writeFieldBegin("newSessionId", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->newSessionId);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("resultCode", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->resultCode);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.modelUpdate) {
    xfer += oprot->writeFieldBegin("modelUpdate", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->modelUpdate.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.result) {
    xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->result.size()));
      std::vector<Value> ::const_iterator _iter41;
      for (_iter41 = this->result.begin(); _iter41 != this->result.end(); ++_iter41)
      {
        xfer += (*_iter41).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.logRecord) {
    xfer += oprot->writeFieldBegin("logRecord", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->logRecord.size()));
      std::vector<LogRecord> ::const_iterator _iter42;
      for (_iter42 = this->logRecord.begin(); _iter42 != this->logRecord.end(); ++_iter42)
      {
        xfer += (*_iter42).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.schedulerResult) {
    xfer += oprot->writeFieldBegin("schedulerResult", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->schedulerResult.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ServiceResult &a, ServiceResult &b) {
  using ::std::swap;
  swap(a.newSessionId, b.newSessionId);
  swap(a.resultCode, b.resultCode);
  swap(a.modelUpdate, b.modelUpdate);
  swap(a.result, b.result);
  swap(a.logRecord, b.logRecord);
  swap(a.schedulerResult, b.schedulerResult);
  swap(a.__isset, b.__isset);
}

}}} // namespace
